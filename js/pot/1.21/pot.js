/*!
 * Pot.js - JavaScript library
 *
 * Pot.js is an implemental utility library
 *  that can execute JavaScript without burdening the CPU.
 *
 * Version 1.21, 2012-09-21
 * Copyright (c) 2012 polygon planet <polygon.planet.aqua@gmail.com>
 * Dual licensed under the MIT or GPL v2 licenses.
 * https://github.com/polygonplanet/Pot.js
 * http://polygonplanet.github.com/Pot.js/
 */
/**
 * Project Pot.js
 *
 * @description
 *  <p>
 *  Pot.js is a JavaScript library that can be performed without causing
 *   stress to the UI and the CPU load by using easy loop iteration functions.
 *  With respect to load, you can implement a particular application without
 *   requiring the programmer to be aware of.
 *  Pot.js is built around the asynchronous processing
 *   and iterator with Deferred.
 *  Pot.Deferred is a Deferred object like MochiKit (or JSDeferred like).
 *  That makes it possible to various iterations (forEach, filter, map,
 *   reduce, zip, repeat, some etc.).
 *  Moreover, Pot.js is an utility library that handles string processes with
 *   various algorithms,
 *   and it has the Signal object that can write like aspect-oriented (AOP),
 *   and it has the Event object for DOM listener,
 *   and treats it the File API for HTML5. etc.
 *  And, Pot.js never pollute the prototype of the global objects.
 *  We only define the 'Pot' object in the global scope basically.
 *  You can use Pot.js with other available libraries without fear of conflict.
 *  Pot.js is a cross-browser library that works on a Web browser, Node.js,
 *   userscript (Greasemonkey, Scriptish) XUL, or (Firefox Add-ons) etc.
 *  PotLite.js is a light version that extracts only the part of asynchronous
 *   processing (Deferred etc.) has been implemented in Pot.js.
 *  </p>
 *
 * @description
 *  <p>
 *  Pot.js は、
 *   JavaScript のループ処理における CPU 負荷を抑え、
 *   UI にストレスを与えることなく実行できるライブラリです。
 *  負荷に関して、とくにプログラマが意識する必要なく
 *   アプリケーションを実装することができます。
 *  Pot.js は、Deferred による非同期処理や、
 *   非同期イテレータを中心に作られています。
 *  MochiKit ライク (または JSDeferred ライク) な Pot.Deferred によって、
 *   多様なイテレート (forEach, filter, map, reduce, zip, repeat, some など)
 *   を可能とします。
 *  また、様々なアルゴリズムを扱った文字列処理や、
 *   アスペクト指向 (AOP) で書ける シグナルやイベント処理、
 *   HTML5 に関する File API などを扱うことができる
 *   汎用ユーティリティライブラリです。
 *  そして、グローバルオブジェクトの prototype を汚染しません。
 *  基本的にグローバルに定義されるのは 'Pot' オブジェクトだけなので
 *   コンフリクトの心配なく、他の JavaScript ライブラリと共に利用できます。
 *  Pot.js は、クロスブラウザであり、Web ブラウザ上や Node.js、
 *   userscript (Greasemonkey, Scriptish) や
 *   XUL (Firefox アドオン) 上などで動きます。
 *  PotLite.js は、
 *   Pot.js で実装されている Deferred などの
 *   非同期処理の部分だけを抽出したライトバージョンです。
 *  </p>
 *
 *
 * @fileoverview   Pot.js library
 * @author         polygon planet
 * @version        1.21
 * @date           2012-09-21
 * @link           https://github.com/polygonplanet/Pot.js
 * @link           http://polygonplanet.github.com/Pot.js/
 * @copyright      Copyright (c) 2012 polygon planet <polygon.planet.aqua@gmail.com>
 * @license        Dual licensed under the MIT or GPL v2 licenses.
 *
 * Based:
 *   - JSDeferred
 *       http://github.com/cho45/jsdeferred
 *   - MochiKit.Async
 *       http://mochikit.com/
 *   - jQuery.Deferred
 *       http://jquery.com/
 *   - Tombloo library (Firefox Add-On)
 *       https://github.com/to/tombloo/wiki
 */
/*
 * JSDoc Comment
 * http://code.google.com/intl/ja/closure/compiler/docs/js-for-compiler.html
 */
//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
/**
 * @namespace Pot.js
 */
(function PotScriptImplementation(globals) {
'use strict';

/**
 * Define the object Pot.
 *
 * @name    Pot
 * @type    Object
 * @class
 * @static
 * @public
 */
var Pot = {VERSION : '1.21', TYPE : 'full'},

// Refer the Pot properties/functions.
PotSystem,
PotPlugin,
PotToString,
PotBrowser,
PotLang,
PotOS,
PotGlobal,
PotNoop,
PotTmp,
PotInternal,

// Asynchronous/Iteration methods/properties.
PotInternalCallInBackground,
PotInternalSetTimeout,
PotInternalClearTimeout,
PotStopIteration,

// is* : object typing.
typeOf,
typeLikeOf,
isBoolean,
isNumber,
isString,
isFunction,
isArray,
isDate,
isRegExp,
isObject,
isError,
isTypedArray,
isArrayBuffer,
isArrayLike,
isNumeric,
isStopIter,
isDeferred,
isHash,
isIter,
isWorkeroid,
isArrayBufferoid,
isWindow,
isDocument,
isElement,
isNodeList,
isNodeLike,

// Constructors.
Deferred,
Hash,
Iter,
PotInternalLightIterator,
Signal,
DropFile,
Workeroid,
ArrayBufferoid,

// A shortcut of prototype methods/functions.
ArrayProto     = Array.prototype,
ObjectProto    = Object.prototype,
StringProto    = String.prototype,
FunctionProto  = Function.prototype,
push           = ArrayProto.push,
slice          = ArrayProto.slice,
splice         = ArrayProto.splice,
concat         = ArrayProto.concat,
unshift        = ArrayProto.unshift,
indexOf        = ArrayProto.indexOf,
lastIndexOf    = ArrayProto.lastIndexOf,
toString       = ObjectProto.toString,
hasOwnProperty = ObjectProto.hasOwnProperty,
toFuncString   = FunctionProto.toString,
fromCharCode   = String.fromCharCode,

/**
 * faster way of String.fromCharCode(c).
 * @ignore
 */
fromUnicode = (function() {
  var i, maps = [];
  for (i = 0; i <= 0xFFFF; i++) {
    maps[i] = fromCharCode(i);
  }
  return function(c) {
    return maps[c & 0xFFFF];
  };
}()),

// Namespace URIs.
XML_NS_URI   = 'http://www.w3.org/XML/1998/namespace',
HTML_NS_URI  = 'http://www.w3.org/1999/xhtml',
XHTML_NS_URI = 'http://www.w3.org/1999/xhtml',
XLINK_NS_URI = 'http://www.w3.org/1999/xlink',
XSL_NS_URI   = 'http://www.w3.org/1999/XSL/Transform',
SVG_NS_URI   = 'http://www.w3.org/2000/svg',
XUL_NS_URI   = 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul',
JS_VOID_URI  = ['javascript'] + [':void(0);'],

// Constant strings.
UPPER_ALPHAS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
LOWER_ALPHAS = 'abcdefghijklmnopqrstuvwxyz',
DIGITS       = '0123456789',

// Regular expression patterns.
RE_RESCAPE         = /([-.*+?^${}()|[\]\/\\])/g,
RE_PERCENT_ENCODED = /^(?:[a-zA-Z0-9_~.-]|%[0-9a-fA-F]{2})*$/,
RE_ARRAYLIKE       = /List|Collection/i,
RE_TRIM            = /^[\s\u00A0\u3000]+|[\s\u00A0\u3000]+$/g,
RE_LTRIM           = /^[\s\u00A0\u3000]+/g,
RE_RTRIM           = /[\s\u00A0\u3000]+$/g,
RE_STRIP           = /[\s\u00A0\u3000]+/g,
RE_NL              = /\r\n|\r|\n/,
RE_NL_GROUP        = /(\r\n|\r|\n)/,
RE_EMPTYFN         = /^[(]?[^{]*?[{][\s\u00A0]*[}]\s*[)]?\s*$/,
RE_JS_ESCAPED      = /^(?:[\w!#$()*+,.:;=?@[\]^`|~-]|\\[ux][0-9a-f]+)*$/i,
RE_HTML_ESCAPED    =
  /^(?:[^<>"'&]|&(?:[a-z]\w{0,24}|#(?:x[0-9a-f]{1,8}|[0-9]{1,10}));)*$/i,

// Mozilla XPCOM Components.
Ci, Cc, Cr, Cu;

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
(function(nv) {

// Define environment properties.
update(Pot, {
  /**
   * @lends Pot
   */
  /**
   * Name of the Pot.
   *
   * @const
   * @ignore
   */
  NAME : 'Pot',
  /**
   * Execution environment.
   *
   *
   * @example
   *   if (Pot.System.isWebBrowser) {
   *     document.write('on Web Browser');
   *   }
   *
   *
   * @type  Object
   * @class
   * @static
   * @const
   * @public
   *
   * @property {Boolean} isWebBrowser
   *           Whether the environment is running on web browser.
   * @property {Boolean} isNonBrowser
   *           Whether the environment is running on non-browser.
   * @property {Boolean} isNodeJS
   *           Whether the environment is running on Node.js.
   * @property {Boolean} isWaitable
   *           Whether the user agent can to wait as synchronously.
   * @property {Boolean} hasComponents
   *           Whether the environment has Components (XPCOM).
   * @property {Boolean} hasActiveXObject
   *           Whether the environment has ActiveXObject.
   * @property {Boolean} isYieldable
   *           Whether the environment can use "yield" operator.
   * @property {Boolean} isFirefoxExtension
   *           Whether the environment is running on Firefox extension.
   * @property {Boolean} isChromeExtension
   *           Whether the environment is running on Chrome extension.
   * @property {Boolean} isSafariExtension
   *           Whether the environment is running on Safari extension.
   * @property {Boolean} isGreasemonkey
   *           Whether the environment is running on Greasemonkey.
   * @property {Boolean} isJetpack
   *           Whether the environment is running on Jetpack.
   * @property {Boolean} isNotExtension
   *           Whether the environment is running on non browser-extension.
   */
  System : {},
  /**
   * Pot plugin object.
   *
   *
   * @example
   *   // Register my plugin function.
   *   Pot.addPlugin('myFunc', function(msg) {
   *     alert('myFunc: ' + msg);
   *   });
   *   // Call function that is able to refer from the Pot object.
   *   Pot.myFunc('Hello!'); // 'myFunc: Hello!'
   *   // Check exists.
   *   debug( Pot.hasPlugin('myFunc') ); // true
   *   // Register other plugin function.
   *   Pot.addPlugin('myFunc2', function(a, b) {
   *     return a + b;
   *   });
   *   // Call other function.
   *   debug( Pot.myFunc2(1, 2) ); // 3
   *   // addPlugin does not overwrite function on default.
   *   debug( Pot.addPlugin('myFunc', function() {}) ); // false
   *   // View list of plugins.
   *   debug( Pot.listPlugin() ); // ['myFunc', 'myFunc2']
   *   // Remove my plugin.
   *   Pot.removePlugin('myFunc');
   *   debug( Pot.hasPlugin('myFunc') ); // false
   *   debug( Pot.listPlugin() ); // ['myFunc2']
   *
   *
   * @example
   *   Pot.addPlugin({
   *     foo : function() { return 'foo!'; },
   *     bar : function() { return 'bar!'; },
   *     baz : function() { return 'baz!'; }
   *   });
   *   debug(Pot.foo() + Pot.bar() + Pot.baz()); // 'foo!bar!baz!'
   *
   *
   * @example
   *   // Register function.
   *   Pot.addPlugin('foo', function() { return 'foo!'; });
   *   // Try change function.
   *   var newFoo = function() { return 'NewFoo!' };
   *   debug( Pot.addPlugin('foo', newFoo) ); // false
   *   // Overwrite plugin function.
   *   debug( Pot.addPlugin('foo', newFoo, true) ); // true
   *   debug( Pot.foo() ); // 'NewFoo!'
   *
   *
   * @example
   *   var toArray = function(string) {
   *     return string.split('');
   *   };
   *   // Plugin function has 'deferred' method.
   *   Pot.addPlugin('toArray', toArray);
   *   // Synchronous
   *   debug( Pot.toArray('abc') ); // ['a', 'b', 'c']
   *   // Asynchronous
   *   Pot.toArray.deferred('abc').then(function(res) {
   *     debug(res); // ['a', 'b', 'c']
   *   });
   *
   *
   * @example
   *   var string = '\t abc\n \t ';
   *   // Original Pot.trim().
   *   debug(Pot.trim(string)); // 'abc'
   *   // Overwrite Pot.trim().
   *   Pot.addPlugin('trim', function(s) {
   *     return s.replace(/^ +| +$/g, '');
   *   });
   *   // New Pot.trim().
   *   debug(Pot.trim(string)); // '\t abc\n \t'
   *   // Removes new Pot.trim().
   *   Pot.removePlugin('trim');
   *   // Back to the original.
   *   debug(Pot.trim(string)); // 'abc'
   *
   *
   * @type  Object
   * @class
   * @static
   * @public
   */
  Plugin : {},
  /**
   * toString.
   *
   * @return  Return formatted string of object.
   * @type Function
   * @function
   * @static
   */
  toString : function() {
    return buildObjectString(this.NAME || this.name || typeof this);
  },
  /**
   * Detect the browser running.
   *
   * @example
   *   if (Pot.Browser.firefox) {
   *     debug('Firefox version:' + Pot.Browser.firefox.version);
   *   }
   *
   * @type  Object
   * @class
   * @static
   * @const
   *
   * @property {Object} webkit     WebKit engine.
   * @property {Object} opera      Opera.
   * @property {Object} msie       MSIE.
   * @property {Object} mozilla    Mozilla engine.
   * @property {Object} firefox    Mozilla Firefox.
   * @property {Object} chrome     Google Chrome.
   * @property {Object} safari     Safari.
   * @property {Object} iphone     iPhone.
   * @property {Object} ipod       iPod.
   * @property {Object} ipad       iPad.
   * @property {Object} android    Android.
   * @property {Object} blackberry BlackBerry.
   */
  Browser : (function(n) {
    var r = {}, m, ua, ver, i, len, re = {
      webkit  : /(webkit)(?:.*version|)[\s\/]+([\w.]+)/,
      opera   : /(opera)(?:.*version|)[\s\/]+([\w.]+)/,
      msie    : /(msie)[\s\/]+([\w.]+)/,
      mozilla : /(?!^.*compatible.*$).*(mozilla)(?:.*?\s+rv[:\s\/]+([\w.]+)|)/
    },
    rs = [
      /webkit.*version[\s\/]+([\w.]+).*(safari)/,
      /webkit.*(chrome|safari)[\s\/]+([\w.]+)/,
      /(iphone|ipod|ipad|android).*version[\s\/]+([\w.]+)/,
      /(blackberry)(?:[\s\d]*|.*version)[\s\/]+([\w.]+)/,
      re.webkit,
      re.opera,
      re.msie,
      /(?!^.*compatible.*$).*mozilla.*?(firefox)(?:[\s\/]+([\w.]+)|)/,
      re.mozilla
    ],
    u = ('' + (n && n.userAgent)).toLowerCase();
    if (u) {
      for (i = 0, len = rs.length; i < len; i++) {
        if ((m = rs[i].exec(u))) {
          break;
        }
      }
      if (m) {
        if (/[^a-z]/.test(m[1])) {
          ua  = m[2];
          ver = m[1];
        } else {
          ua  = m[1];
          ver = m[2];
        }
        if (ua) {
          r[ua] = {version : '' + (ver || 0)};
        }
      }
      m = re.webkit.exec(u) || re.opera.exec(u)   ||
          re.msie.exec(u)   || re.mozilla.exec(u) || [];
      if (m && m[1]) {
        r[m[1]] = {version : '' + (m[2] || 0)};
      }
    }
    return r;
  }(nv)),
  /**
   * Detect the browser/user language.
   *
   * @example
   *   if (Pot.LANG == 'ja') {
   *     debug('ハローワールド');
   *   }
   *
   * @type  String
   * @static
   * @const
   */
  LANG : (function(n) {
    return ((n && (n.language || n.userLanguage     ||
            n.browserLanguage || n.systemLanguage)) ||
            'en').split(/[^a-zA-Z0-9]+/).shift().toLowerCase();
  }(nv)),
  /**
   * Detect the user operating system.
   *
   * @example
   *   if (Pot.OS.win) {
   *     debug('OS : ' + Pot.OS.toString());
   *   }
   *
   * @type Object
   * @class
   * @static
   * @const
   *
   * @property {Boolean}  iphone     iPhone.
   * @property {Boolean}  ipod       iPod.
   * @property {Boolean}  ipad       iPad.
   * @property {Boolean}  blackberry BlackBerry.
   * @property {Boolean}  android    Android.
   * @property {Boolean}  mac        Mac.
   * @property {Boolean}  win        Windows.
   * @property {Boolean}  linux      Linux.
   * @property {Boolean}  x11        X11.
   * @property {Function} toString   Represents OS as a string.
   */
  OS : (function(nv) {
    var r = {}, n = nv || {}, i, len, o,
        pf = ('' + (n.platform)).toLowerCase(),
        ua = ('' + (n.userAgent)).toLowerCase(),
        av = ('' + (n.appVersion)).toLowerCase(),
        maps = [
          {s : 'iphone',     p : pf},
          {s : 'ipod',       p : pf},
          {s : 'ipad',       p : ua},
          {s : 'blackberry', p : ua},
          {s : 'android',    p : ua},
          {s : 'mac',        p : pf},
          {s : 'win',        p : pf},
          {s : 'linux',      p : pf},
          {s : 'x11',        p : av}
        ];
    for (i = 0, len = maps.length; i < len; i++) {
      o = maps[i];
      if (~o.p.indexOf(o.s)) {
        r[o.s] = true;
      }
    }
    if (r.android && !~ua.indexOf('mobile')) {
      r.androidtablet = true;
    }
    if (r.ipad || r.androidtablet) {
      r.tablet = true;
    }
    /**
     * @return {String}  Return the platform as a string.
     * @ignore
     */
    r.toString = function() {
      var s = [], p;
      for (p in r) {
        if (r[p] === true) {
          s.push(p);
        }
      }
      return s.join('/');
    };
    return r;
  }(nv)),
  /**
   * Global object. (e.g. window)
   *
   * @type Object
   * @static
   * @public
   */
  Global : (function() {
    var g = (new Function('return this;'))();
    if (!globals ||
        typeof globals !== 'object' || !('setTimeout' in globals)) {
      globals = this || g || {};
    }
    return this || g || {};
  }()),
  /**
   * Noop function.
   *
   * @type  Function
   * @function
   * @const
   */
  noop : function() {},
  /**
   * Temporary storage place.
   *
   * @type  Object
   * @private
   * @ignore
   */
  tmp : {},
  /**
   * Treats the internal properties/methods.
   *
   * @internal
   * @type Object
   * @class
   * @private
   * @ignore
   */
  Internal : {
    /**
     * @lends Pot.Internal
     */
    /**
     * Numbering the magic numbers for the constructor.
     *
     * @private
     * @ignore
     */
    getMagicNumber : (function(sn) {
      var c = 0, n = +sn;
      return function() {
        var i = n + (c++);
        if (!isFinite(i) || isNaN(i)) {
          c = n = i = 0;
        }
        return i;
      };
    }('0xC26BEB642C0A')),
    /**
     * Get the export object.
     *
     * @private
     * @ignore
     */
    getExportObject : function(forGlobalScope) {
      var outputs, id, valid;
      if (forGlobalScope) {
        if (PotSystem.isNonBrowser) {
          outputs = PotGlobal || globals;
        } else {
          outputs = (isWindow(globals) && globals) ||
                    (isWindow(PotGlobal) && PotGlobal) ||
                     Pot.currentWindow();
        }
        if (!outputs &&
            typeof window !== 'undefined' && isWindow(window)) {
          outputs = window;
        }
        if (outputs) {
          do {
            id = buildSerial(Pot, '');
          } while (id in outputs);
          outputs[id] = 1;
          valid = (new Function('try{return ' + id + '===1;}catch(e){}'))();
          try {
            delete outputs[id];
          } catch (e) {
            try {
              outputs[id] = void 0;
            } catch (e) {}
          }
          if (!valid) {
            outputs = PotGlobal;
          }
        }
      }
      if (!outputs) {
        if (PotSystem.isNodeJS) {
          if (typeof module === 'object' &&
              typeof module.exports === 'object') {
            outputs = module.exports;
          } else if (typeof exports === 'object') {
            outputs = exports;
          } else {
            outputs = globals;
          }
        } else {
          outputs = globals;
        }
        if (!outputs) {
          outputs = globals || PotGlobal || Pot.currentWindow();
        }
      }
      return outputs;
    },
    /**
     * Pot.js Script Implementation.
     *
     * @private
     * @ignore
     */
    ScriptImplementation : PotScriptImplementation
  },
  /**
   * @lends Pot
   */
  /**
   * Extend target object from arguments.
   *
   *
   * @example
   *   var obj = {foo: 'v1', bar: 'v2'};
   *   var src = {baz: 'v3'};
   *   update(obj, src);
   *   debug(obj);
   *   // @results  obj = {foo: 'v1', bar: 'v2', baz: 'v3'}
   *
   *
   * @param  {Object}     target   Target object.
   * @param  {...Object}  (...)    Subject objects.
   * @return {Object}              Updated object. (first argument).
   * @static
   * @function
   * @public
   */
  update : update,
  /**
   * Refer Pot object.
   *
   * @ignore
   */
  Pot : Pot
});
}(typeof navigator !== 'undefined' && navigator || {}));

// Refer the Pot properties.
PotSystem   = Pot.System;
PotPlugin   = Pot.Plugin;
PotToString = Pot.toString;
PotBrowser  = Pot.Browser;
PotLang     = Pot.LANG;
PotOS       = Pot.OS;
PotGlobal   = Pot.Global;
PotNoop     = Pot.noop;
PotTmp      = Pot.tmp;
PotInternal = Pot.Internal;


// Path/Directory Delimiter
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Delimiter for path.
   *
   * @type  String
   * @static
   * @const
   */
  PATH_DELIMITER : PotOS.win ? ';'  : ':',
  /**
   * Delimiter for directory.
   *
   * @type  String
   * @static
   * @const
   */
  DIR_DELIMITER : PotOS.win ? '\\' : '/',
  /**
   * XML/HTML namespace URI.
   *
   * @type  String
   * @static
   * @const
   */
  XML_NS_URI : XML_NS_URI,
  /**
   * XML/HTML namespace URI.
   *
   * @type  String
   * @static
   * @const
   */
  HTML_NS_URI : HTML_NS_URI,
  /**
   * XML/HTML namespace URI.
   *
   * @type  String
   * @static
   * @const
   */
  XHTML_NS_URI : XHTML_NS_URI,
  /**
   * XML/HTML namespace URI.
   *
   * @type  String
   * @static
   * @const
   */
  XLINK_NS_URI : XLINK_NS_URI,
  /**
   * XML/HTML namespace URI.
   *
   * @type  String
   * @static
   * @const
   */
  XSL_NS_URI : XSL_NS_URI,
  /**
   * XML/HTML namespace URI.
   *
   * @type  String
   * @static
   * @const
   */
  SVG_NS_URI : SVG_NS_URI,
  /**
   * XML/HTML namespace URI.
   *
   * @type  String
   * @static
   * @const
   */
  XUL_NS_URI : XUL_NS_URI,
  /**
   * JavaScript void URI.
   *
   * @type  String
   * @static
   * @const
   */
  JS_VOID_URI : JS_VOID_URI
});

// Definition of System.
update(PotSystem, (function() {
  var o = {}, g, ws, b, u, ua, ca, oe, ce, ov, cv, f;
  o.isWaitable = false;
  if (typeof window === 'object' && 'setTimeout' in window &&
      window.window == window &&
      typeof document === 'object' && document.nodeType > 0 &&
      typeof document.documentElement === 'object'
  ) {
    o.isWebBrowser = true;
    if (window.location &&
        /^(?:chrome|resource):?$/.test(window.location.protocol)) {
      try {
        if (typeof Components !== 'object') {
          throw false;
        }
        Cc = Components.classes;
        Ci = Components.interfaces;
        Cr = Components.results;
        Cu = Components.utils;
        o.isWaitable = true;
        o.hasComponents = true;
        if (PotBrowser.firefox || PotBrowser.mozilla) {
          o.isFirefoxExtension = true;
        }
      } catch (e) {
        // If you need XPCOM, try following privilege.
        // e.g.
        //   netscape.security.PrivilegeManager
        //           .enablePrivilege('UniversalXPConnect');
        //   or
        //   about:config :
        //   signed.applets.codebase_principal_support : true (default=false)
        //
        Ci = Cc = Cr = Cu = null;
      }
    }
    try {
      oe = document.documentElement;
      if (oe) {
        /**@ignore*/
        f = function() {};
        f.prototype = oe;
        ce = new f();
        if (oe.nodeName === ce.nodeName && oe.nodeType === ce.nodeType) {
          o.canCloneDOM = true;
        }
      }
    } catch (e) {}
  } else {
    o.isNonBrowser = true;
    if (typeof process !== 'undefined' && process && process.version &&
        typeof require === 'function' &&
        (typeof exports === 'object' ||
        (typeof module === 'object' && typeof module.exports === 'object'))
    ) {
      o.isNodeJS = true;
    }
  }
  if (PotGlobal && PotGlobal.ActiveXObject ||
      typeof ActiveXObject !== 'undefined' && ActiveXObject) {
    o.hasActiveXObject = true;
  }
  if (!o.isFirefoxExtension) {
    if (PotBrowser.chrome || PotBrowser.webkit || PotBrowser.safari) {
      if (typeof chrome === 'object' &&
          typeof chrome.extension === 'object') {
        o.isChromeExtension = true;
      } else if (typeof safari === 'object' &&
                 typeof safari.extension === 'object') {
        o.isSafariExtension = true;
      }
    }
  }
  if (!o.isChromeExtension && !o.isSafariExtension) {
    if (typeof GM_log === 'function' &&
        typeof GM_xmlhttpRequest === 'function') {
      o.isGreasemonkey = true;
    } else if (typeof require === 'function') {
      try {
        if ('title' in require('windows').browserWindows.activeWindow) {
          o.isJetpack = true;
        }
      } catch (e) {}
    }
    if (o.isWebBrowser && !o.isGreasemonkey && !o.isFirefoxExtension) {
      o.isNotExtension = true;
    }
  }
  try {
    ov = {a: 1, b: 2};
    /**@ignore*/
    f = function() {};
    f.prototype = ov;
    cv = new f();
    cv.a = 0;
    if (ov !== cv && ov.a === 1 && cv.a === 0 && ov.b === cv.b) {
      o.canProtoClone = true;
    }
  } catch (e) {}
  try {
    /**@ignore*/
    g = (new Function('yield(0);'))();
    if (g && typeof g.next === 'function') {
      o.isYieldable = true;
    }
  } catch (e) {}
  try {
    if (typeof FileReader !== 'undefined' &&
        typeof FileReader.LOADING !== 'undefined' &&
        typeof (new FileReader()).readAsText === 'function') {
      o.hasFileReader = true;
    }
  } catch (e) {}
  try {
    if (typeof Blob === 'function' &&
        toString.call(new Blob()) === '[object Blob]' &&
        typeof Blob.prototype.slice === 'function') {
      o.hasBlob = true;
    }
  } catch (e) {}
  try {
    b = (typeof BlobBuilder       !== 'undefined') ? BlobBuilder       :
        (typeof MozBlobBuilder    !== 'undefined') ? MozBlobBuilder    :
        (typeof WebKitBlobBuilder !== 'undefined') ? WebKitBlobBuilder :
        (typeof MSBlobBuilder     !== 'undefined') ? MSBlobBuilder     : null;
    if (!b ||
        typeof b !== 'function' ||
        typeof b.prototype.append !== 'function' ||
        typeof b.prototype.getBlob !== 'function'
    ) {
      b = null;
    } else {
      o.BlobBuilder = b;
      if (b &&
          typeof MozBlobBuilder !== 'undefined' && b === MozBlobBuilder) {
        o.isMozillaBlobBuilder = true;
      }
    }
  } catch (e) {}
  /**@ignore*/
  o.createBlob = function() {
    if (o.hasBlob) {
      return function(value, type) {
        var arr = concat.call([], value);
        if (type) {
          return new Blob(arr, {type : type});
        } else {
          return new Blob(arr);
        }
      };
    } else if (o.BlobBuilder) {
      return function(value, type) {
        var blb = new o.BlobBuilder();
        blb.append(value);
        if (type) {
          return blb.getBlob(type);
        } else {
          return blb.getBlob();
        }
      };
    }
  }();
  try {
    u = (typeof URL       !== 'undefined') ? URL       :
        (typeof webkitURL !== 'undefined') ? webkitURL : null;
    if (!u || typeof u.createObjectURL !== 'function') {
      u = null;
    } else {
      o.BlobURI = u;
    }
  } catch (e) {}
  ws = [];
  if (typeof Worker === 'function') {
    ws.push([Worker, 'Worker']);
  }
  if (typeof ChromeWorker === 'function') {
    ws.push([ChromeWorker, 'ChromeWorker']);
  }
  while (ws.length) {
    (function() {
      var item = ws.shift(),
          worker = item[0],
          key    = item[1],
          hasWorker           = 'has' + key,
          canWorkerDataURI    = 'can' + key + 'DataURI',
          canWorkerBlobURI    = 'can' + key + 'BlobURI',
          canWorkerPostObject = 'can' + key + 'PostObject',
          ref, msg, w, wb;
      /**@ignore*/
      ref = function() {
        return 1;
      };
      msg = {
        /**@ignore*/
        a : function() {
          return ref();
        }
      };
      try {
        if (typeof worker.prototype.postMessage === 'function') {
          // hasWorker: 'hasWorker' or 'hasChromeWorker'
          o[hasWorker] = true;
          w = new worker(
            'data:application/javascript;base64,' +
            // base64:
            // onmessage = function(e) {
            //   postMessage(
            //     (e && e.data &&
            //       ((typeof e.data.a === 'function' && e.data.a()) ||
            //         e.data
            //       )
            //     ) + 1
            //   )
            // }
            'b25tZXNzYWdlPWZ1bmN0aW9uKGUpe3Bvc3RNZXNzYWdlKChlJiZlLmRhdGEmJ' +
            'igodHlwZW9mIGUuZGF0YS5hPT09J2Z1bmN0aW9uJyYmZS5kYXRhLmEoKSl8fG' +
            'UuZGF0YSkpKzEpfQ=='
          );
          /**@ignore*/
          w.onmessage = function(ev) {
            if (ev) {
              switch (ev.data) {
                case (msg.a() + 1):
                    // canWorkerPostObject:
                    //   'canWorkerPostObject' or 'canChromeWorkerPostObject'
                    PotSystem[canWorkerPostObject] = true;
                    // FALL THROUGH
                case (msg + 1):
                case 'x1':
                    // canWorkerDataURI:
                    //   'canWorkerDataURI' or 'canChromeWorkerDataURI'
                    PotSystem[canWorkerDataURI] = true;
              }
            }
            try {
              w.terminate();
            } catch (ex) {}
          };
          try {
            w.postMessage(msg);
          } catch (ex) {
            w.postMessage('x');
          }
        }
      } catch (e) {}
      if (o[hasWorker] && o.createBlob && o.BlobURI) {
        try {
          wb = new worker(o.BlobURI.createObjectURL(o.createBlob(
            'onmessage=function(e){' +
              'postMessage(' +
                '(e&&e.data&&' +
                  '((typeof e.data.a==="function"&&e.data.a())||e.data)' +
                ')+1' +
              ')' +
            '}'
          )));
          /**@ignore*/
          wb.onmessage = function(ev) {
            if (ev) {
              switch (ev.data) {
                case (msg.a() + 1):
                    PotSystem[canWorkerPostObject] = true;
                    // FALL THROUGH
                case (msg + 1):
                case 'x1':
                    // canWorkerBlobURI:
                    //   'canWorkerBlobURI' or 'canChromeWorkerBlobURI'
                    PotSystem[canWorkerBlobURI] = true;
              }
            }
            try {
              wb.terminate();
            } catch (ex) {}
          };
          try {
            wb.postMessage(msg);
          } catch (ex) {
            wb.postMessage('x');
          }
        } catch (e) {}
      }
    }());
  }
  try {
    if (typeof ArrayBuffer !== 'undefined' &&
        (new ArrayBuffer(10)).byteLength === 10 &&
        typeof Uint8Array !== 'undefined' &&
        (new Uint8Array([0, 312])).subarray(1)[0] === 56
    ) {
      o.hasTypedArray = true;
      try {
        ua = new Uint8Array([1, 2]);
        ca = new Uint8Array(ua.subarray(0));
        ca[0] = 5;
        if (ua[0] === 1 && ca[0] === 5) {
          o.canCopyTypedArray = true;
        }
        ua = ca = null;
      } catch (ex) {}
      try {
        if (typeof Uint8ClampedArray !== 'undefined' &&
            (new Uint8ClampedArray([0, 312])).subarray(1)[0] === 255) {
          o.hasUint8ClampedArray = true;
        }
      } catch (ex) {}
      if (typeof DataView !== 'undefined' &&
          (new DataView(new Uint8Array([
            0x10, 0x20, 0x40, 0x80
          ]).buffer)).getUint32(0) === 0x10204080) {
        o.hasDataView = true;
      }
    }
  } catch (e) {}
  return o;
}()));

/**
 * Creates methods to detect the type definition.
 *
 * <pre>
 * Pot.is*
 *
 *   * ::= Boolean | Number | String | Function |
 *         Array | Date | RegExp | Object | Error
 * </pre>
 *
 *
 * @example
 *   Pot.isString(100);      // false
 *   Pot.isObject('hoge');   // false
 *   Pot.isArray([1, 2, 3]); // true
 *
 *
 * @param  {*}         A target object
 * @return {Boolean}   Returns whether the proper object
 * @lends  Pot
 * @static
 * @public
 *
 * @property {Function} isBoolean  Detect the Boolean type. (static)
 * @property {Function} isNumber   Detect the Number type. (static)
 * @property {Function} isString   Detect the String type. (static)
 * @property {Function} isFunction Detect the Function type. (static)
 * @property {Function} isArray    Detect the Array type. (static)
 * @property {Function} isDate     Detect the Date type. (static)
 * @property {Function} isRegExp   Detect the RegExp type. (static)
 * @property {Function} isObject   Detect the Object type. (static)
 * @property {Function} isError    Detect the Error type. (static)
 */
(function(types) {
  var i = 0, len = types.length, typeMaps = {};
  for (; i < len; i++) {
    (function() {
      var type = types[i], low = type.toLowerCase();
      typeMaps[buildObjectString(type)] = low;
      Pot['is' + type] = (function() {
        switch (low) {
          case 'error':
              return function(o) {
                return (o != null &&
                        (o instanceof Error || typeOf(o) === low)
                       ) || false;
              };
          case 'date':
              return function(o) {
                return (o != null &&
                        (o instanceof Date || typeOf(o) === low)
                       ) || false;
              };
          default:
              return function(o) {
                return typeOf(o) === low;
              };
        }
      }());
    }());
  }
  Pot.update({
    /**
     * @lends Pot
     */
    /**
     * Get the object type as string.
     *
     * <pre>
     * The return types:
     *   'boolean', 'number', 'string',   'function',
     *   'array',   'date',   'regexp',   'object',
     *   'error',   'null',   'undefined'
     * </pre>
     *
     *
     * @example
     *   debug( Pot.typeOf([1, 2, 3]) );
     *   // @results 'array'
     *
     *
     * @param  {*}       o  A target object.
     * @return {String}     Return the type of object.
     * @static
     * @function
     * @public
     */
    typeOf : function(o) {
      return (o == null) ? String(o)
                         : (typeMaps[toString.call(o)] || 'object');
    },
    /**
     * Get the object type like of array or any types.
     *
     * <pre>
     * The return types:
     *   'boolean', 'number', 'string',   'function',
     *   'array',   'date',   'regexp',   'object',
     *   'error',   'null',   'undefined'
     * </pre>
     *
     *
     * @example
     *   (function() {
     *     debug( Pot.typeLikeOf(arguments) );
     *     // @results 'array'
     *   })();
     *
     *
     * @param  {*}       o  A target object.
     * @return {String}     Return the type of object.
     * @static
     * @function
     * @public
     */
    typeLikeOf : function(o) {
      var type = typeOf(o);
      if (type !== 'array' && isArrayLike(o)) {
        type = 'array';
      }
      return type;
    }
  });
}('Boolean Number String Function Array Date RegExp Object Error'.split(' ')));

// Refer variables.
isBoolean   = Pot.isBoolean;
isNumber    = Pot.isNumber;
isString    = Pot.isString;
isFunction  = Pot.isFunction;
isArray     = Pot.isArray;
isDate      = Pot.isDate;
isRegExp    = Pot.isRegExp;
isObject    = Pot.isObject;
isError     = Pot.isError;
isArrayLike = Pot.isArrayLike;
typeOf      = Pot.typeOf;
typeLikeOf  = Pot.typeLikeOf;
//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
(function(SI) {
// Aggregate in this obejct for global functions. (HTML5 Task)
update(PotInternal, {
  /**
   * @lends Pot.Internal
   */
  /**
   * Call the function in the background (i.e. in non-blocking).
   *
   * @param  {Function}  callback  The callback function.
   *
   * @type  Object
   * @class
   * @static
   * @private
   * @ignore
   * @based JSDeferred.next
   */
  callInBackground : {
    /**
     * @lends Pot.Internal.callInBackground
     */
    /**
     * Call the function in the background (i.e. in non-blocking).
     *
     * @param  {Function}  callback  The callback function.
     *
     * @type  Function
     * @function
     * @static
     * @private
     * @ignore
     * @based JSDeferred.next
     */
    flush : function(callback) {
      var handler = this.byEvent || this.byTick || this.byTimer;
      handler(callback);
    },
    /**
     * @private
     * @ignore
     * @based JSDeferred.next
     */
    byEvent : (function() {
      var IMAGE;
      if (PotSystem.isNonBrowser || PotSystem.isNodeJS ||
          typeof window !== 'object'  || typeof document !== 'object' ||
          typeof Image !== 'function' || window.opera || PotBrowser.opera ||
          typeof document.addEventListener !== 'function'
      ) {
        return false;
      }
      try {
        if (typeof (new Image()).addEventListener !== 'function') {
          return false;
        }
      } catch (e) {
        return false;
      }
      // Dummy 1x1 gif image.
      IMAGE = 'data:image/gif;base64,' +
              'R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';
      /**@ignore*/
      return function(callback) {
        var done, handler, img = new Image();
        /**@ignore*/
        handler = function() {
          try {
            img.removeEventListener('load', handler, false);
            img.removeEventListener('error', handler, false);
          } catch (e) {}
          if (!done) {
            done = true;
            callback();
          }
        };
        img.addEventListener('load', handler, false);
        img.addEventListener('error', handler, false);
        try {
          img.src = IMAGE;
        } catch (e) {
          this.byEvent = this.byTimer;
        }
      };
    }()),
    /**
     * @private
     * @ignore
     */
    byTick : (function() {
      if (!PotSystem.isNodeJS || typeof process !== 'object' ||
          typeof process.nextTick !== 'function') {
        return false;
      }
      /**@ignore*/
      return function(callback) {
        process.nextTick(callback);
      };
    }()),
    /**
     * @private
     * @ignore
     */
    byTimer : function(callback, msec) {
      return setTimeout(callback, msec || 0);
    }
  },
  /**
   * @lends Pot.Internal
   */
  /**
   * Alias for window.setTimeout function. (for non-window-environment)
   *
   * @type  Function
   * @function
   * @static
   * @private
   * @ignore
   */
  setTimeout : function(func, msec) {
    try {
      return PotInternalCallInBackground.byTimer(func, msec || 0);
    } catch (e) {}
  },
  /**
   * Alias for window.clearTimeout function. (for non-window-environment)
   *
   * @type  Function
   * @function
   * @static
   * @private
   * @ignore
   */
  clearTimeout : function(id) {
    try {
      return clearTimeout(id);
    } catch (e) {}
  },
  /**
   * Alias for window.setInterval function. (for non-window-environment)
   *
   * @type  Function
   * @function
   * @static
   * @private
   * @ignore
   */
  setInterval : function(func, msec) {
    try {
      return setInterval(func, msec || 0);
    } catch (e) {}
  },
  /**
   * Alias for window.clearInterval function. (for non-window-environment)
   *
   * @type  Function
   * @function
   * @static
   * @private
   * @ignore
   */
  clearInterval : function(id) {
    try {
      return clearInterval(id);
    } catch (e) {}
  }
});

// Refer objects.
PotInternalCallInBackground = PotInternal.callInBackground;
PotInternalSetTimeout       = PotInternal.setTimeout;
PotInternalClearTimeout     = PotInternal.clearTimeout;

// Define distinction of types.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * A shortcut of "Components.classes".
   *
   * @type  Object
   * @static
   * @const
   * @public
   */
  Cc : Cc,
  /**
   * A shortcut of "Components.interfaces".
   *
   * @type  Object
   * @static
   * @const
   * @public
   */
  Ci : Ci,
  /**
   * A shortcut of "Components.results".
   *
   * @type  Object
   * @static
   * @const
   * @public
   */
  Cr : Cr,
  /**
   * A shortcut of "Components.utils".
   *
   * @type  Object
   * @static
   * @const
   * @public
   */
  Cu : Cu,
  /**
   * Emulate StopIteration.
   *
   *
   * @example
   *   Pot.forEach([1, 2, 3, 4, 5], function(v) {
   *     if (v > 2) {
   *       throw Pot.StopIteration;
   *     }
   *     debug(v);
   *   });
   *
   *
   * @type  Object
   * @static
   * @const
   * @public
   */
  StopIteration : (function() {
    /**@ignore*/
    var f = update(function() {
      return f;
    }, {
      NAME     : SI,
      toString : PotToString
    });
    f.prototype = {
      constructor : f,
      NAME        : f.NAME,
      toString    : f.toString
    };
    f.prototype.constructor.prototype = f.constructor.prototype;
    return new f();
  }()),
  /**
   * Return whether the argument is StopIteration or not.
   *
   *
   * @example
   *   try {
   *     for (var i = 0; i < 10; i++) {
   *       if (i > 5) {
   *         throw Pot.StopIteration;
   *       }
   *       debug(i);
   *     }
   *   } catch (e) {
   *     if (Pot.isStopIter(e)) {
   *       debug('StopIteration was thrown!');
   *     } else {
   *       throw e;
   *     }
   *   }
   *
   *
   * @param  {*}         o   Target object.
   * @return {Boolean}       Return true if argument is StopIteration.
   * @type Function
   * @function
   * @static
   * @public
   */
  isStopIter : function(o) {
    if (o &&
        (
          (PotStopIteration !== void 0 &&
            (o == PotStopIteration || o instanceof PotStopIteration)
          ) ||
          (typeof StopIteration === 'object' &&
            (o == StopIteration || o instanceof StopIteration)
          ) ||
          (this && this.StopIteration !== void 0 &&
            (o == this.StopIteration || o instanceof this.StopIteration)
          ) ||
          (~toString.call(o).indexOf(SI) ||
            ~String(o && o.toString && o.toString() || o).indexOf(SI)
          ) ||
          (isError(o) && o[SI] && !(SI in o[SI]) &&
            !isError(o[SI]) && isStopIter(o[SI])
          )
        )
    ) {
      return true;
    } else {
      return false;
    }
  },
  /**
   * Return whether the argument is Iterator or not.
   *
   *
   * @example
   *   var iter = new Pot.Iter();
   *   var i = 0;
   *   iter.next = function() {
   *     if (i > 5) {
   *       throw StopIteration;
   *     }
   *     return i++;
   *   };
   *   debug( isIterable(iter) ); // @results  true
   *   var func = function() {};
   *   debug( isIterable(func) ); // @results  false
   *
   *
   * @example
   *   var iter = (function() {
   *     for (var i = 0; i < 10; i++) {
   *       yield;
   *       debug(i);
   *     }
   *   })();
   *   debug( isIterable(iter) ); // @results  true
   *
   *
   * @param  {*}         x   Target object.
   * @return {Boolean}       Return true if argument is iterable.
   * @type Function
   * @function
   * @static
   * @public
   */
  isIterable : function(x) {
    return !!(x && isFunction(x.next) &&
         (~Pot.getFunctionCode(x.next).indexOf(SI) ||
           Pot.isNativeCode(x.next)));
  },
  /**
   * Return whether the argument is scalar type.
   * This function treats as scalar type for
   *   String or Number and Boolean types.
   *
   *
   * @example
   *   debug(isScalar(null));              // false
   *   debug(isScalar((void 0)));          // false
   *   debug(isScalar(''));                // true
   *   debug(isScalar('abc'));             // true
   *   debug(isScalar(0));                 // true
   *   debug(isScalar(123));               // true
   *   debug(isScalar(false));             // true
   *   debug(isScalar(true));              // true
   *   debug(isScalar(new Boolean(true))); // true
   *   debug(isScalar([]));                // false
   *   debug(isScalar([1, 2, 3]));         // false
   *   debug(isScalar(/hoge/));            // false
   *   debug(isScalar(new Error()));       // false
   *   debug(isScalar({}));                // false
   *   debug(isScalar({a: 1, b: 2}));      // false
   *
   *
   * @param   {*}         x     A target object.
   * @return  {Boolean}         ture or false (scalar type or not).
   * @type Function
   * @function
   * @static
   * @public
   */
  isScalar : function(x) {
    return x != null && (isString(x) || isNumber(x) || isBoolean(x));
  },
  /**
   * Check whether the argument is Blob or not.
   *
   *
   * @example
   *   var bb = new Pot.System.BlobBuilder();
   *   bb.append('hoge');
   *   var blob = bb.getBlob();
   *   Pot.debug(Pot.isBlob(blob));   // true
   *   Pot.debug(Pot.isBlob({}));     // false
   *   Pot.debug(Pot.isBlob('hoge')); // false
   *
   *
   * @param  {*}         x   Target object.
   * @return {Boolean}       Return true if argument is Blob.
   * @type Function
   * @function
   * @static
   * @public
   */
  isBlob : function(x) {
    return !!(x && toString.call(x) === '[object Blob]');
  },
  /**
   * Check whether the argument is a instance of FileReader or not.
   *
   *
   * @example
   *   var object = {hoge : 1};
   *   var reader = new FileReader();
   *   Pot.debug(Pot.isFileReader(object)); // false
   *   Pot.debug(Pot.isFileReader(reader)); // true
   *
   *
   * @param  {*}         x   Target object.
   * @return {Boolean}       Return true if argument is FileReader.
   * @type Function
   * @function
   * @static
   * @public
   */
  isFileReader : function(x) {
    return !!(PotSystem.hasFileReader && x && x.constructor === FileReader);
  },
  /**
   * Check whether the argument is a instance of Image or not.
   *
   *
   * @example
   *   var object = {hoge : 1};
   *   var image = new Image();
   *   Pot.debug(Pot.isImage(object)); // false
   *   Pot.debug(Pot.isImage(image));  // true
   *
   *
   * @param  {*}         x   Target object.
   * @return {Boolean}       Return true if argument is Image.
   * @type Function
   * @function
   * @static
   * @public
   */
  isImage : function() {
    var hasImage = (typeof Image === 'function') ||
                   (PotBrowser.msie && typeof Image === 'object');
    return function(x) {
      return !!(hasImage && x &&
                (x.constructor === Image ||
                 toString.call(x) === '[object HTMLImageElement]' ||
                 stringify(x.tagName).toLowerCase() === 'img'
                )
               );
    };
  }(),
  /**
   * Check whether the argument is Arguments object or not.
   *
   *
   * @example
   *   (function(a, b, c) {
   *     var obj = {foo : 1};
   *     var arr = [1, 2, 3];
   *     debug(isArguments(obj));       // false
   *     debug(isArguments(arr));       // false
   *     debug(isArguments(arguments)); // true
   *   }(1, 2, 3));
   *
   *
   * @param  {*}         x   Target object.
   * @return {Boolean}       Return true if argument is Arguments object.
   * @type Function
   * @function
   * @static
   * @public
   */
  isArguments : function(x) {
    var result = false;
    if (x) {
      if (toString.call(x) === '[object Arguments]') {
        result = true;
      } else {
        try {
          if ('callee' in x && typeof x.length === 'number') {
            result = true;
          }
        } catch (e) {}
      }
    }
    return result;
  },
  /**
   * Check whether the argument is TypedArray object or not.
   *
   *
   * @example
   *   var obj = {foo : 1};
   *   var arr = [1, 2, 3];
   *   var buf = new ArrayBuffer(10);
   *   var uar = new Uint8Array(10);
   *   debug(isTypedArray(obj)); // false
   *   debug(isTypedArray(arr)); // false
   *   debug(isTypedArray(buf)); // true
   *   debug(isTypedArray(uar)); // true
   *
   *
   * @param  {*}         x   Target object.
   * @return {Boolean}       Return true if argument is TypedArray object.
   * @type Function
   * @function
   * @static
   * @public
   */
  isTypedArray : function(x) {
    var result = false;
    if (x && PotSystem.hasTypedArray && 
        (x.constructor === ArrayBuffer ||
          (x.buffer && x.buffer.constructor === ArrayBuffer)
        )
    ) {
      result = true;
    }
    return result;
  },
  /**
   * Check whether the argument is ArrayBuffer object or not.
   *
   *
   * @example
   *   var obj = {foo : 1};
   *   var arr = [1, 2, 3];
   *   var buf = new ArrayBuffer(10);
   *   var uar = new Uint8Array(10);
   *   debug(isArrayBuffer(obj)); // false
   *   debug(isArrayBuffer(arr)); // false
   *   debug(isArrayBuffer(buf)); // true
   *   debug(isArrayBuffer(uar)); // false
   *
   *
   * @param  {*}         x   Target object.
   * @return {Boolean}       Return true if argument is ArrayBuffer object.
   * @type Function
   * @function
   * @static
   * @public
   */
  isArrayBuffer : function(x) {
    return !!(PotSystem.hasTypedArray && x && x.constructor === ArrayBuffer);
  },
  /**
   * Return whether the argument object like Array (i.e. iterable)
   *
   *
   * @example
   *   (function() {
   *     debug(Pot.isArray(arguments));
   *     // @results false
   *     debug(Pot.isArrayLike(arguments));
   *     // @results true
   *   })();
   *
   *
   * @param   {*}         o     A target object
   * @return  {Boolean}         ture or false (iterable or false)
   * @type Function
   * @function
   * @static
   * @public
   */
  isArrayLike : function(o) {
    var len;
    if (!o) {
      return false;
    }
    if (isArray(o) || o instanceof Array || o.constructor === Array ||
        isTypedArray(o) || isArrayBufferoid(o)) {
      return true;
    }
    len = o.length;
    if (!isNumber(len) || (!isObject(o) && !isArray(o)) ||
         o === Pot  || o === PotGlobal || o === globals ||
        isWindow(o) ||  isDocument(o)  || isElement(o)
    ) {
      return false;
    }
    if (o.isArray || Pot.isArguments(o) || isNodeList(o) ||
        ((typeof o.item === 'function' ||
          typeof o.nextNode === 'function') &&
           o.nodeType != 3 && o.nodeType != 4) ||
        (0 in o && ((len - 1) in o)) ||
        RE_ARRAYLIKE.test(toString.call(o))
    ) {
      return true;
    } else {
      return false;
    }
  },
  /**
   * Detect whether the object is plain object.
   *
   *
   * @example
   *   debug(isPlainObject(String));         // false
   *   debug(isPlainObject(new String(''))); // false
   *   debug(isPlainObject(Date));           // false
   *   debug(isPlainObject(new Date()));     // false
   *   debug(isPlainObject(Number));         // false
   *   debug(isPlainObject(new Number(1)));  // false
   *   debug(isPlainObject(Array));          // false
   *   debug(isPlainObject(new Array()));    // false
   *   debug(isPlainObject([]));             // false
   *   debug(isPlainObject(Object));         // false
   *   debug(isPlainObject(new Object()));   // true
   *   debug(isPlainObject({}));             // true
   *   debug(isPlainObject({foo: 'bar'}));   // true
   *
   *
   * @param  {*}        o   A target object to detect.
   * @return {Boolean}      Return true if `o` is a plain object.
   * @type Function
   * @function
   * @static
   * @public
   */
  isPlainObject : function(o) {
    var result = false, p;
    try {
      if (!o || !isObject(o) ||
          isElement(o) || isWindow(o) || isDocument(o)) {
        throw o;
      }
      if (o.constructor &&
          !hasOwnProperty.call(o, 'constructor') &&
          !hasOwnProperty.call(o.constructor.prototype, 'isPrototypeOf')
      ) {
        throw o;
      }
      for (p in o) {}
      result = (p === void 0 || hasOwnProperty.call(o, p));
    } catch (e) {
      result = false;
    }
    return result;
  },
  /**
   * Check whether the argument object is empty.
   *
   *
   * @example
   *   debug(isEmpty(null));                // true
   *   debug(isEmpty(true));                // false
   *   debug(isEmpty(false));               // true
   *   debug(isEmpty(0));                   // true
   *   debug(isEmpty(-524560620));          // false
   *   debug(isEmpty(0.1205562));           // false
   *   debug(isEmpty(''));                  // true
   *   debug(isEmpty('abc'));               // false
   *   debug(isEmpty(new String()));        // true
   *   debug(isEmpty([]));                  // true
   *   debug(isEmpty([1, 2, 3]));           // false
   *   debug(isEmpty([[]]));                // false
   *   debug(isEmpty(new Array()));         // true
   *   debug(isEmpty(new Array('a', 'b'))); // false
   *   debug(isEmpty({a:1, b:2, c:3}));     // false
   *   debug(isEmpty({}));                  // true
   *   debug(isEmpty(new Object()));        // true
   *   debug(isEmpty((void 0)));            // true
   *   debug(isEmpty((function() {})));     // true
   *   var f = function(a, b) {
   *     return a + b;
   *   };
   *   debug(isEmpty(f)); // false
   *
   *
   * @param  {*}        o   The target object to test.
   * @return {Boolean}      Return true if the argument object is empty,
   *                          otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isEmpty : function(o) {
    var empty, p, f, toCode = Pot.getFunctionCode;
    switch (typeLikeOf(o)) {
      case 'object':
          empty = true;
          for (p in o) {
            empty = false;
            break;
          }
          break;
      case 'array':
      case 'string':
          empty = (!o || !o.length);
          break;
      case 'function':
          /**@ignore*/
          f = function() {};
          empty = true;
          for (p in o) {
            if (p in f) {
              continue;
            }
            empty = false;
            break;
          }
          if (empty) {
            if (toCode(o) === toCode(f) ||
                RE_EMPTYFN.test(toCode(o))
            ) {
              if (o.prototype) {
                for (p in o.prototype) {
                  if (p in f.prototype) {
                    continue;
                  }
                  empty = false;
                  break;
                }
              }
            } else {
              empty = false;
            }
          }
          break;
      default:
          empty = (o == false || !o || o == null || o == 0);
    }
    return empty;
  },
  /**
   * Check whether the argument object is an instance of Pot.Deferred.
   *
   *
   * @example
   *   var o = {hoge: 1};
   *   var d = new Pot.Deferred();
   *   debug(isDeferred(o)); // false
   *   debug(isDeferred(d)); // true
   *
   *
   * @param  {Object|*}  x  The target object to test.
   * @return {Boolean}      Return true if the argument object is an
   *                          instance of Pot.Deferred,
   *                          otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isDeferred : function(x) {
    return x != null && ((x instanceof Deferred) ||
     (x.id   != null && x.id   === Deferred.fn.id &&
      x.NAME != null && x.NAME === Deferred.fn.NAME));
  },
  /**
   * Check whether the argument object is an instance of Pot.Iter.
   *
   *
   * @example
   *   var obj = {hoge: 1};
   *   var iter = new Pot.Iter();
   *   debug(isIter(obj));  // false
   *   debug(isIter(iter)); // true
   *
   *
   * @param  {Object|*}  x  The target object to test.
   * @return {Boolean}      Return true if the argument object is an
   *                          instance of Pot.Iter, otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isIter : function(x) {
    return x != null && ((x instanceof Iter) ||
     (x.id   != null && x.id   === Iter.fn.id &&
      x.NAME != null && x.NAME === Iter.fn.NAME &&
                typeof x.next  === 'function'));
  },
  /**
   * Check whether the argument object is an instance of Pot.Workeroid.
   *
   *
   * @example
   *   var o = {hoge: 1};
   *   var w = new Pot.Workeroid();
   *   debug(isWorkeroid(o)); // false
   *   debug(isWorkeroid(w)); // true
   *
   *
   * @param  {Object|*}  x  The target object to test.
   * @return {Boolean}      Return true if the argument object is an
   *                          instance of Pot.Workeroid,
   *                          otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isWorkeroid : function(x) {
    return x != null && ((x instanceof Workeroid) ||
     (x.id   != null && x.id   === Workeroid.fn.id &&
      x.NAME != null && x.NAME === Workeroid.fn.NAME));
  },
  /**
   * Check whether the argument object is an instance of Pot.ArrayBufferoid.
   *
   *
   * @example
   *   var o = {hoge: 1};
   *   var a = new Pot.ArrayBufferoid();
   *   debug(isArrayBufferoid(o)); // false
   *   debug(isArrayBufferoid(a)); // true
   *
   *
   * @param  {Object|*}  x  The target object to test.
   * @return {Boolean}      Return true if the argument object is an
   *                          instance of Pot.ArrayBufferoid,
   *                          otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isArrayBufferoid : function(x) {
    return ArrayBufferoid && x != null &&
     ((x instanceof ArrayBufferoid) ||
      (x.id   != null && x.id   === ArrayBufferoid.fn.id &&
       x.NAME != null && x.NAME === ArrayBufferoid.fn.NAME));
  },
  /**
   * Check whether the argument object is an instance of Pot.Hash.
   *
   *
   * @example
   *   var obj = {hoge: 1};
   *   var hash = new Pot.Hash();
   *   debug(isHash(obj));  // false
   *   debug(isHash(hash)); // true
   *
   *
   * @param  {Object|*}  x  The target object to test.
   * @return {Boolean}      Return true if the argument object is an
   *                          instance of Pot.Hash, otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isHash : function(x) {
    return x != null && ((x instanceof Hash) ||
     (x.id   != null && x.id   === Hash.fn.id &&
      x.NAME != null && x.NAME === Hash.fn.NAME));
  },
  /**
   * Check whether the value is escaped as JavaScript String.
   *
   *
   * @example
   *   debug(isJSEscaped('abc'));                          // true
   *   debug(isJSEscaped('abc\\hoge".'));                  // false
   *   debug(isJSEscaped('\\u007b\\x20hoge\\x20\\u007d')); // true
   *
   *
   * @param  {String|*}   s   The target string to test.
   * @return {Boolean}        Return true if the value is escaped,
   *                            otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isJSEscaped : function(s) {
    return RE_JS_ESCAPED.test(s);
  },
  /**
   * Check whether the value is percent encoded.
   *
   *
   * @example
   *   debug(isPercentEncoded('abc'));              // true
   *   debug(isPercentEncoded('abc["hoge"]'));      // false
   *   debug(isPercentEncoded('%7B%20hoge%20%7D')); // true
   *
   *
   * @param  {String|*}   s   The target string to test.
   * @return {Boolean}        Return true if the value is encoded,
   *                            otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isPercentEncoded : function(s) {
    return RE_PERCENT_ENCODED.test(s);
  },
  /**
   * Check whether the value is escaped as HTML/XML String.
   *
   *
   * @example
   *   debug(isHTMLEscaped('abc'));                     // true
   *   debug(isHTMLEscaped('1 < 2'));                   // false
   *   debug(isHTMLEscaped('&quot;(&gt;_&lt;)&quot;')); // true
   *
   *
   * @param  {String|*}   s   The target string to test.
   * @return {Boolean}        Return true if the value is escaped,
   *                            otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isHTMLEscaped : function(s) {
    return RE_HTML_ESCAPED.test(s);
  },
  /**
   * Check whether the value can be numeric value.
   *
   *
   * @example
   *   debug(isNumeric(0));               // true
   *   debug(isNumeric(1234567890));      // true
   *   debug(isNumeric(new Number(25)));  // true
   *   debug(isNumeric(null));            // false
   *   debug(isNumeric((void 0)));        // false
   *   debug(isNumeric('abc'));           // false
   *   debug(isNumeric('0xFF'));          // true
   *   debug(isNumeric('1e8'));           // true
   *   debug(isNumeric('10px'));          // false
   *   debug(isNumeric('-512 +1'));       // false
   *   debug(isNumeric([]));              // false
   *   debug(isNumeric([100]));           // false
   *   debug(isNumeric(new Date()));      // false
   *   debug(isNumeric({}));              // false
   *   debug(isNumeric((function() {}))); // false
   *
   *
   * @param  {Number|*}   n   The target value to test.
   * @return {Boolean}        Return true if the value is numeric,
   *                            otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isNumeric : function(n) {
    return (n == null ||
           (n === ''  ||
           (n ==  ''  && n && n.constructor === String)) ||
           (typeof n === 'object' && n.constructor !== Number)) ?
            false : !isNaN(n - 0);
  },
  /**
   * Returns whether the supplied number represents an integer,
   *   i.e. that is has no fractional component.
   *
   *
   * @example
   *   debug(isInt(0));                       // true
   *   debug(isInt(-524560620));              // true
   *   debug(isInt(0.1205562));               // false
   *   debug(isInt(1.5));                     // false
   *   debug(isInt(12345));                   // true
   *   debug(isInt(Number.MAX_VALUE));        // true
   *   debug(isInt(Number.MAX_VALUE * 1000)); // false
   *   debug(isInt(null));                    // false
   *   debug(isInt((void 0)));                // false
   *   debug(isInt('hoge'));                  // false
   *   debug(isInt(''));                      // false
   *   debug(isInt([100]));                   // false
   *
   *
   * @param  {Number}   n  The number to test.
   * @return {Boolean}     Whether `n` is an integer.
   * @type Function
   * @function
   * @static
   * @public
   */
  isInt : function(n) {
    return isNumber(n) && isFinite(n) && n % 1 == 0;
  },
  /**
   * Check whether the argument is the native code.
   *
   *
   * @example
   *   debug(isNativeCode(null));                     // false
   *   debug(isNativeCode((void 0)));                 // false
   *   debug(isNativeCode({foo: 1, bar: 2, baz: 3})); // false
   *   debug(isNativeCode('hoge'));                   // false
   *   debug(isNativeCode(window));                   // false
   *   debug(isNativeCode(document));                 // false
   *   debug(isNativeCode(document.body));            // false
   *   debug(isNativeCode(document.getElementById));  // true
   *   debug(isNativeCode(encodeURIComponent));       // true
   *   debug(isNativeCode(Array.prototype.slice));    // true
   *   debug(isNativeCode((function() {})));          // false
   *   debug(isNativeCode(Math.max.toString()));      // true
   *
   *
   * @param  {String|Function}  method   The target method.
   * @return {Boolean}                   Return true if the `method` is
   *                                       native code,
   *                                       otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isNativeCode : function(method) {
    var code;
    if (!method) {
      return false;
    }
    if (Pot.getFunctionCode) {
      code = Pot.getFunctionCode(method);
    } else if (isFunction(method)) {
      code = toFuncString.call(method);
    } else if (method.toString) {
      code = method.toString();
    } else {
      code = '' + method;
    }
    return !!(~code.indexOf('[native code]') && code.length <= 92);
  },
  /**
   * Check whether the argument function is the built-in method.
   *
   *
   * @example
   *   debug(isBuiltinMethod(null));                     // false
   *   debug(isBuiltinMethod((void 0)));                 // false
   *   debug(isBuiltinMethod({foo: 1, bar: 2, baz: 3})); // false
   *   debug(isBuiltinMethod('hoge'));                   // false
   *   debug(isBuiltinMethod(window));                   // false
   *   debug(isBuiltinMethod(document));                 // false
   *   debug(isBuiltinMethod(document.body));            // false
   *   debug(isBuiltinMethod(document.getElementById));  // true
   *   debug(isBuiltinMethod(encodeURIComponent));       // true
   *   debug(isBuiltinMethod(Array.prototype.slice));    // true
   *   debug(isBuiltinMethod((function() {})));          // false
   *
   *
   * @param  {Function}  method   The target method.
   * @return {Boolean}            Return true if the argument function
   *                                is built-in, otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isBuiltinMethod : function(method) {
    return method != null && (typeof method === 'function' ||
           method.constructor === Function) && Pot.isNativeCode(method);
  },
  /**
   * Check whether the argument object is Window.
   *
   *
   * @example
   *   debug(isWindow(null));                                 // false
   *   debug(isWindow((void 0)));                             // false
   *   debug(isWindow({foo: 1, bar: 2, baz: 3}));             // false
   *   debug(isWindow('hoge'));                               // false
   *   debug(isWindow(window));                               // true
   *   debug(isWindow(document));                             // false
   *   debug(isWindow(document.body));                        // false
   *   debug(isWindow(document.getElementById('container'))); // false
   *   debug(isWindow(document.getElementsByTagName('div'))); // false
   *
   *
   * @param  {Document|Element|Node|*}  x  The target object.
   * @return {Boolean}                     Return true if the argument object
   *                                         is Window, otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isWindow : function(x) {
    return x != null && typeof x === 'object' && 'setInterval' in x &&
           x.window == x && !!(x.location || x.screen || x.navigator ||
           x.document);
  },
  /**
   * Check whether the argument object is Document.
   *
   *
   * @example
   *   debug(isDocument(null));                                 // false
   *   debug(isDocument((void 0)));                             // false
   *   debug(isDocument({foo: 1, bar: 2, baz: 3}));             // false
   *   debug(isDocument('hoge'));                               // false
   *   debug(isDocument(window));                               // false
   *   debug(isDocument(document));                             // true
   *   debug(isDocument(document.body));                        // false
   *   debug(isDocument(document.getElementById('container'))); // false
   *   debug(isDocument(document.getElementsByTagName('div'))); // false
   *
   *
   * @param  {Window|Element|Node|*}  x  The target object.
   * @return {Boolean}                   Return true if the argument object
   *                                       is Document, otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isDocument : function(x) {
    return x != null && typeof x === 'object' && 'getElementById' in x &&
      x.nodeType > 0 && typeof x.documentElement === 'object';
  },
  /**
   * Check whether the argument object is Element.
   *
   *
   * @example
   *   debug(isElement(null));                                 // false
   *   debug(isElement((void 0)));                             // false
   *   debug(isElement({foo: 1, bar: 2, baz: 3}));             // false
   *   debug(isElement('hoge'));                               // false
   *   debug(isElement(window));                               // false
   *   debug(isElement(document));                             // false
   *   debug(isElement(document.body));                        // true
   *   debug(isElement(document.getElementById('container'))); // true
   *   debug(isElement(document.getElementsByTagName('div'))); // false
   *
   *
   * @param  {Element|Node|*}  x  The target object.
   * @return {Boolean}            Return true if the argument object
   *                                is Element, otherwise return false.
   * @type Function
   * @function
   * @static
   * @public
   */
  isElement : function(x) {
    return x != null && typeof x === 'object' && x.nodeType == 1;
  },
  /**
   * Check whether the object looks like a DOM node.
   *
   *
   * @example
   *   debug(isNodeLike({foo: 1, bar: 2, baz: 3}));             // false
   *   debug(isNodeLike('hoge'));                               // false
   *   debug(isNodeLike(window));                               // false
   *   debug(isNodeLike(document));                             // true
   *   debug(isNodeLike(document.body));                        // true
   *   debug(isNodeLike(document.getElementById('container'))); // true
   *   debug(isNodeLike(document.getElementsByTagName('div'))); // false
   *
   *
   * @param  {*}        x   The target object.
   * @return {Boolean}      Whether the object looks like a DOM node.
   * @type Function
   * @function
   * @static
   * @public
   */
  isNodeLike : function(x) {
    return x != null && typeof x === 'object' && x.nodeType > 0;
  },
  /**
   * Returns true if the object is a NodeList.
   *
   *
   * @example
   *   var obj = new Array({foo: 1, bar: 2, baz: 3});
   *   var nodes = document.getElementsByTagName('div');
   *   debug(isNodeList(obj));
   *   // @results  false
   *   debug(isNodeList(nodes));
   *   // @results  true
   *   //
   *   // Make dummy method for test.
   *   obj.item = function() {};
   *   debug(isNodeList(obj));
   *   // @results  false
   *
   *
   * @param  {*}        x   The target object to test.
   * @return {Boolean}      Whether the object is a NodeList.
   * @type Function
   * @function
   * @static
   * @public
   */
  isNodeList : function(x) {
    var type;
    if (x && isNumber(x.length)) {
      type = typeof x.item;
      if (isObject(x)) {
        return type === 'function' || type === 'string';
      } else if (isFunction(x)) {
        return type === 'function';
      }
    }
    return false;
  },
  /**
   * Check whether the object looks like a DOM Object.
   *
   *
   * @example
   *   debug(isDOMLike({foo: 1, bar: 2, baz: 3}));             // false
   *   debug(isDOMLike('hoge'));                               // false
   *   debug(isDOMLike(window));                               // true
   *   debug(isDOMLike(document));                             // true
   *   debug(isDOMLike(document.body));                        // true
   *   debug(isDOMLike(document.getElementById('container'))); // true
   *   debug(isDOMLike(document.getElementsByTagName('div'))); // true
   *   debug(isDOMLike(document.createTextNode('hoge')));      // true
   *
   *
   * @param  {*}        x   The target object.
   * @return {Boolean}      Whether the object looks like a DOM Object.
   * @type Function
   * @function
   * @static
   * @public
   */
  isDOMLike : (function() {
    var re = new RegExp(
      'X?HTML|XUL|XML|DOM|Element|Node|Entity|Plugin|Worker|' +
      'Character|Data|Comment|Document|Window|Fragment|Range|Event|' +
      'CDATA|Section|Process|Shared|List|Collection|Audio|Video|' +
      'Canvas|Image|Notify|Text|Option|Socket|File|Session|Local',
      'i'
    );
    return function(x) {
      return (isNodeLike(x) || isNodeList(x)  ||
              isWindow(x)   || isDocument(x)) ||
        x != null && typeof x === 'object' && (
        // Event
        ((x.preventDefault || 'returnValue' in x) &&
          (x.target || x.currentTarget || x.originalTarget || x.pageX)) ||
        // Range
        ((x.selectNode || x.selectNodeContents || x.surroundContents) &&
          (x.cloneRange || x.commonAncestorContainer ||
           x.insertNode || x.compareBoundaryPoints)) ||
        // Selection
        ((x.getRangeAt || x.addRange || x.deleteFromDocument) &&
          (x.anchorNode  || x.anchorOffset || x.focusNode ||
           x.isCollapsed || x.rangeCount)) ||
        // Element.style
        ('cssText' in x &&
          'color' in x && 'margin' in x && 'padding' in x && 'border' in x) ||
        // Attr
        ('ownerElement' in x && 'isId' in x && 'name' in x && 'value' in x) ||
        // Worker
        (x.postMessage && 'terminate' in x) ||
        re.test(toString.call(x))
      );
    };
  }())
});
}('StopIteration'));

// Refer the Pot properties/functions.
PotStopIteration = Pot.StopIteration;
isTypedArray     = Pot.isTypedArray;
isArrayBuffer    = Pot.isArrayBuffer;
isArrayLike      = Pot.isArrayLike;
isNumeric        = Pot.isNumeric;
isStopIter       = Pot.isStopIter;
isDeferred       = Pot.isDeferred;
isHash           = Pot.isHash;
isIter           = Pot.isIter;
isWorkeroid      = Pot.isWorkeroid;
isArrayBufferoid = Pot.isArrayBufferoid;
isWindow         = Pot.isWindow;
isDocument       = Pot.isDocument;
isElement        = Pot.isElement;
isNodeList       = Pot.isNodeList;
isNodeLike       = Pot.isNodeLike;

// Definition of current Document and URI.
(function() {
  var win, doc, uri, wp, dp, a;
  wp = 'window contentWindow defaultView parentWindow content top'.split(' ');
  dp = 'ownerDocument document'.split(' ');
  /**@ignore*/
  function detectWindow(x) {
    var w;
    if (x) {
      if (isWindow(x)) {
        w = x;
      } else {
        each(wp, function(p) {
          try {
            if (isWindow(x[p])) {
              w = x[p];
            }
            if (x[p].content && isWindow(x[p].content)) {
              w = x[p].content;
            }
          } catch (e) {}
          if (w) {
            throw PotStopIteration;
          }
        });
      }
    }
    return w;
  }
  /**@ignore*/
  function detectDocument(x) {
    var d;
    if (x) {
      if (isDocument(x)) {
        d = x;
      } else {
        each(dp, function(p) {
          try {
            if (isDocument(x[p])) {
              d = x[p];
            }
            if (x[p].content && isDocument(x[p].content.document)) {
              d = x[p].content.document;
            }
          } catch (e) {}
          if (d) {
            throw PotStopIteration;
          }
        });
      }
    }
    return d;
  }
  each([
    globals,
    PotGlobal,
    typeof window   === 'undefined' ? this : window,
    typeof document === 'undefined' ? this : document
  ], function(x) {
    if (x) {
      if (!win) {
        win = detectWindow(x);
      }
      if (!doc) {
        doc = detectDocument(x);
      }
      if (win && doc) {
        throw PotStopIteration;
      }
    }
  });
  if (PotSystem.isNodeJS) {
    uri = (typeof process === 'object' &&
            process.mainModule && process.mainModule.filename) ||
          (typeof __filename === 'string' && __filename);
  } else {
    if (doc) {
      try {
        uri = doc.documentURI || doc.baseURI || doc.URL;
      } catch (e) {}
    }
    if (!uri && win) {
      try {
        uri = win.location && win.location.href || win.location;
      } catch (e) {
        try {
          a = doc.createElement('a');
          a.href = '';
          uri = a.href;
        } catch (ex) {}
      }
    }
  }
  update(PotSystem, {
    /**
     * @lends Pot.System
     */
    /**
     * Current DOM Window object if exists (i.e., on web-browser).
     *
     * @type Object
     * @static
     * @public
     */
    currentWindow : win || {},
    /**
     * Current DOM Document object if exists (i.e., on web-browser).
     *
     * @type Object
     * @static
     * @public
     */
    currentDocument : doc || {},
    /**
     * The current document URI (on web-browser) or filename (on non-browser).
     *
     * @type String
     * @static
     * @public
     */
    currentURI : stringify(uri, true)
  });
  Pot.update({
    /**
     * @lends Pot
     */
    /**
     * Get the current DOM Window object if exists (i.e., on web-browser).
     *
     * @return {Object} The current DOM window object.
     * @type Function
     * @function
     * @static
     * @public
     */
    currentWindow : function() {
      return PotSystem.currentWindow;
    },
    /**
     * Get the current DOM Document object if exists (i.e., on web-browser).
     *
     * @return {Object} The current DOM Document object.
     * @type Function
     * @function
     * @static
     * @public
     */
    currentDocument : function() {
      return PotSystem.currentDocument;
    },
    /**
     * Get the current document URI (on web-browser)
     *   or filename (on non-browser).
     *
     * @return {String} The current URI.
     * @type Function
     * @static
     * @public
     */
    currentURI : function() {
      return PotSystem.currentURI;
    }
  });
}());

// Definition of builtin method states.
update(PotSystem, {
  /**
   * @lends Pot.System
   */
  /**
   * Whether the environment supports the built-in "Object.keys".
   *
   * @type  Boolean
   * @const
   */
  isBuiltinObjectKeys : Pot.isBuiltinMethod(Object.keys),
  /**
   * Whether the environment supports the built-in "Array.prototype.forEach".
   *
   * @type  Boolean
   * @const
   */
  isBuiltinArrayForEach : Pot.isBuiltinMethod(ArrayProto.forEach),
  /**
   * Whether the environment supports the built-in "Array.prototype.indexOf".
   *
   * @type  Boolean
   * @const
   */
  isBuiltinArrayIndexOf : Pot.isBuiltinMethod(ArrayProto.indexOf),
  /**
   * Whether the environment supports
   *   the built-in "Array.prototype.lastIndexOf".
   *
   * @type  Boolean
   * @const
   */
  isBuiltinArrayLastIndexOf : Pot.isBuiltinMethod(ArrayProto.lastIndexOf)
});

// Update Pot object methods.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Collect the object key names like ES5's Object.keys().
   *
   *
   * @example
   *   var obj = {foo: 1, bar: 2, baz: 3};
   *   debug(keys(obj));
   *   // @results ['foo', 'bar', 'baz']
   *   var array = [10, 20, 30, 40, 50];
   *   debug(keys(array));
   *   // @results [0, 1, 2, 3, 4]
   *   delete array[2];
   *   debug(keys(array));
   *   // @results [0, 1, 3, 4]
   *
   *
   * {@link https://developer.mozilla.org/en/JavaScript/
   *                Reference/Global_Objects/Object/keys }
   *
   * @param  {Object|Function|*}  o  The target object.
   * @return {Array}                 The collected key names as an array.
   * @type  Function
   * @function
   * @static
   * @public
   */
  keys : (function() {
    var hasDontEnumBug = !({toString : null})
                            .propertyIsEnumerable('toString'),
        dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ],
        dontEnumsLength = dontEnums.length;
    return function(object) {
      var results = [], type = typeof object, len, p, i;
      if (type !== 'object' && type !== 'function' || object === null) {
        return results;
      }
      if (isArrayLike(object)) {
        len = object.length;
        for (i = 0; i < len; i++) {
          if (i in object) {
            results[results.length] = i;
          }
        }
      } else {
        if (PotSystem.isBuiltinObjectKeys) {
          try {
            results = Object.keys(object);
            return results;
          } catch (e) {}
        }
        for (p in object) {
          try {
            if (hasOwnProperty.call(object, p)) {
              results[results.length] = p;
            }
          } catch (ex) {}
        }
        if (hasDontEnumBug) {
          for (i = 0; i < dontEnumsLength; i++) {
            try {
              if (hasOwnProperty.call(object, dontEnums[i])) {
                results[results.length] = dontEnums[i];
              }
            } catch (er) {}
          }
        }
      }
      return results;
    };
  }()),
  /**
   * Evaluates a script in a global context.
   *
   *
   * @example
   *   globalEval('function hoge() { return "hoge"; }');
   *   debug(hoge());
   *   // @results 'hoge'
   *
   *
   * @param  {String}  code  The code to evaluate.
   * @return {*}             The value of evaluated result.
   * @type  Function
   * @function
   * @static
   * @public
   */
  globalEval : update(function(code) {
    var me = Pot.globalEval, id, scope, func, doc, script, head;
    if (code && me.patterns.valid.test(code)) {
      if (PotSystem.hasActiveXObject) {
        if (typeof execScript !== 'undefined' && execScript &&
            me.test(execScript)) {
          return execScript(code, me.language);
        } else {
          func = 'execScript';
          if (func in globals && me.test(func, globals)) {
            return globals[func](code, me.language);
          } else if (func in PotGlobal && me.test(func, PotGlobal)) {
            return PotGlobal[func](code, me.language);
          }
        }
      }
      func = 'eval';
      if (func in globals && me.test(func, globals)) {
        scope = globals;
      } else if (func in PotGlobal && me.test(func, PotGlobal)) {
        scope = PotGlobal;
      }
      if (PotSystem.isGreasemonkey) {
        // eval does not work to global scope in greasemonkey
        //   even if using the unsafeWindow.
        return Pot.localEval(code, scope || PotGlobal);
      }
      if (scope) {
        if (scope[func].call && scope[func].apply &&
            me.test(func, scope, true)) {
          return scope[func].call(scope, code);
        }
        if (me.worksForGlobal == null) {
          me.worksForGlobal = false;
          do {
            id = buildSerial(Pot, '');
          } while (id in scope);
          scope[id] = 1;
          scope[func]('try{delete ' + id + ';}catch(e){}');
          if (!(id in scope)) {
            me.worksForGlobal = true;
          }
          try {
            delete scope[id];
          } catch (e) {
            try {
              scope[id] = void 0;
            } catch (e) {}
          }
        }
        if (me.worksForGlobal) {
          return scope[func](code);
        }
      }
      if (PotSystem.isNodeJS) {
        return me.doEvalInGlobalNodeJS(func, code);
      }
      if (PotSystem.isWebBrowser &&
          typeof document === 'object') {
        doc = document;
        head = doc.getElementsByTagName('head');
        if (head && head[0]) {
          head = head[0];
        } else {
          head = doc.head || doc.body || doc.documentElement;
        }
        if (head) {
          script = doc.createElement('script');
          script.type = 'text/javascript';
          script.defer = script.async = false;
          if (PotSystem.hasActiveXObject && 'text' in script) {
            script.text = code;
          } else {
            script.appendChild(doc.createTextNode(code));
          }
          head.appendChild(script);
          head.removeChild(script);
        }
      } else {
        return Pot.localEval(code, scope || PotGlobal);
      }
    }
  }, {
    /**
     * @private
     * @ignore
     * @const
     */
    language : 'JavaScript',
    /**
     * @private
     * @ignore
     */
    patterns : {
      valid  : /\S/
    },
    /**
     * @ignore
     */
    test : function(func, obj, useCall) {
      var result = false, nop = '(void 0);';
      try {
        if (obj) {
          if (useCall) {
            obj.func.call(null, nop);
          } else {
            obj.func(nop);
          }
        } else {
          if (useCall) {
            func.call(null, nop);
          } else {
            func(nop);
          }
        }
        result = true;
      } catch (e) {
        result = false;
      }
      return result;
    },
    /**
     * @ignore
     */
    doEvalInGlobalNodeJS : function(func, code) {
      var result, me = Pot.globalEval.doEvalInGlobalNodeJS,
          vm, script, scope = PotGlobal, id;
      if (me.worksForGlobal == null) {
        try {
          me.worksForGlobal = false;
          do {
            id = buildSerial(Pot, '');
          } while (id in scope);
          scope[id] = 1;
          scope[func].call(scope, 'try{delete ' + id + ';}catch(e){}');
          if (!(id in scope)) {
            me.worksForGlobal = true;
          } else {
            try {
              delete scope[id];
            } catch (e) {}
          }
        } catch (e) {
          me.worksForGlobal = false;
        }
      }
      if (me.worksForGlobal) {
        result = scope[func].call(scope, code);
      } else if (typeof require !== 'undefined' && require) {
        vm = require('vm');
        if (vm && vm.createScript) {
          script = vm.createScript(code);
          if (script && script.runInThisContext) {
            result = script.runInThisContext();
          }
        }
      }
      return result;
    }
  }),
  /**
   * Evaluates a script in a anonymous context.
   *
   *
   * @example
   *   localEval('function hoge() { return "hoge"; }');
   *   debug(hoge());
   *   // @results (Error: hoge is undefined)
   *
   *
   * @param  {String}     code    The code to evaluate.
   * @param  {Object|*}  (scope)  (Optional) The evaluation scope.
   * @return {*}                  The value of evaluated result.
   * @type  Function
   * @function
   * @static
   * @public
   */
  localEval : update(function(code, scope) {
    var that = Pot.globalEval, me = Pot.localEval, func, context;
    if (code && that.patterns.valid.test(code)) {
      func = 'eval';
      if (func in globals && that.test(func, globals)) {
        context = globals;
      } else if (func in PotGlobal && that.test(func, PotGlobal)) {
        context = PotGlobal;
      }
      if (context && context[func]) {
        if (context[func].call && context[func].apply &&
            that.test(func, context, true)) {
          return me.doEval(code, context, scope);
        } else if (scope == null) {
          return me.doEval(code, context, scope, true);
        }
      }
      return me.doEvalByFunc(code, scope);
    }
  }, {
    /**
     * @private
     * @ignore
     * @const
     */
    isLiteral :
      /^\s*(?!(?:return|var|if|do|for|try|while)\b\s*)[\w$.!"'~(){}[\]]/,
    /**
     * @ignore
     */
    isFunc : /^\s*function\b[^{]*[{][\s\S]*[}][^}]*$/,
    /**
     * @ignore
     */
    clean : /^(?:[{[(']{0}[')\]}]+|)[;\s\u00A0]*|[;\s\u00A0]*$/g,
    /**
     * @ignore
     */
    doEval : function(/*code[, context[, scope[, isSimple]]]*/) {
      try {
        return arguments[1]['eval'].call(
          arguments[2] || arguments[1],
          arguments[0]
        );
      } catch (e) {}
      if (arguments[3]) {
        return arguments[1]['eval'](arguments[0]);
      } else {
        return Pot.localEval.doEvalByFunc(
          arguments[0],
          arguments[2] || arguments[1]
        );
      }
    },
    /**
     * @ignore
     */
    doEvalByFunc : function(code, scope) {
      var that = Pot.localEval, src;
      if (that.isFunc.test(code) ||
          (that.isLiteral.test(code) && !Pot.hasReturn(code))) {
        src = 'return(' + String(code).replace(that.clean, '') + ');';
      } else {
        src = code;
      }
      return (new Function(
        'return(function(){' + src + '}).call(this);'
      )).call(scope);
    }
  }),
  /**
   * Get the function code.
   *
   *
   * @example
   *   debug(getFunctionCode(function() { return 'hoge'; }));
   *   // @results e.g.
   *   //   'function () {' +
   *   //   '    return "hoge";' +
   *   //   '}'
   *
   *
   * @example
   *   debug(getFunctionCode('function() { return 1; }'));
   *   // @results 'function() { return 1; }'
   *
   *
   * @example
   *   debug(getFunctionCode(1));      // ''
   *   debug(getFunctionCode(false));  // ''
   *   debug(getFunctionCode(true));   // ''
   *   debug(getFunctionCode(null));   // ''
   *   debug(getFunctionCode(void 0)); // ''
   *   debug(getFunctionCode({}));     // ''
   *
   *
   * @example
   *   debug(getFunctionCode(new Function('return 1')));
   *   // @results e.g.
   *   //   'function anonymous() {' +
   *   //   '    return 1;' +
   *   //   '}'
   *
   *
   * @param  {Function|String}   func  Target function or string code.
   * @return {String}                  Returns function code
   *                                     or empty string ''.
   * @type  Function
   * @function
   * @static
   * @public
   */
  getFunctionCode : function(func) {
    if (isFunction(func)) {
      return toFuncString.call(func);
    }
    if (isString(func)) {
      if (func.toString) {
        return func.toString();
      }
      return '' + func;
    }
    return '';
  },
  /**
   * Checks whether a token is words.
   *
   *
   * @example
   *   debug(isWords(' '));     // false
   *   debug(isWords('abc'));   // true
   *   debug(isWords('ほげ'));  // true
   *   debug(isWords('\r\n'));  // false
   *   debug(isWords(' \n'));   // false
   *   debug(isWords(' abc'));  // false
   *   debug(isWords('abc '));  // false
   *   debug(isWords('_'));     // true
   *   debug(isWords(false));   // false
   *   debug(isWords(true));    // false
   *   debug(isWords(void 0));  // false
   *   debug(isWords({}));      // false
   *   debug(isWords(['ABC'])); // false
   *   debug(isWords('$hoge')); // true
   *   debug(isWords('$_'));    // true
   *
   *
   * @param  {String}   c  A string token.
   * @return {Boolean}     Returns whether a token is words.
   * @type  Function
   * @function
   * @static
   * @public
   */
  isWords : (function() {
    var isSpace = /\s/,
        notWord = /[^$\w\u0100-\uFFFF]/;
    return function(c) {
      return isString(c) && !isSpace.test(c) && !notWord.test(c);
    };
  }()),
  /**
   * Checks whether a token is line-break.
   *
   *
   * @example
   *   debug(isNL('abc'));            // false
   *   debug(isNL(' '));              // false
   *   debug(isNL('\n'));             // true
   *   debug(isNL('\r'));             // true
   *   debug(isNL('\r\n'));           // true
   *   debug(isNL('\nhoge'));         // false
   *   debug(isNL('\r \n'));          // false
   *   debug(isNL('\r\n\r\n'));       // true
   *   // Note: includes U+2028 - U+2029
   *   debug(isNL('\u2028\u2029'));   // true
   *   debug(isNL(null));             // false
   *   debug(isNL(void 0));           // false
   *   debug(isNL(false));            // false
   *   debug(isNL(true));             // false
   *   debug(isNL(new String('\n'))); // true
   *   debug(isNL({}));               // false
   *   debug(isNL(['\n']));           // false
   *
   *
   * @param  {String}   c  A string token.
   * @return {Boolean}     Returns whether a token is NL.
   * @type  Function
   * @function
   * @static
   * @public
   */
  isNL : (function() {
    var notNL = /[^\r\n\u2028\u2029]/;
    return function(c) {
      return isString(c) && !notNL.test(c);
    };
  }()),
  /**
   * Formats to a string by arguments.
   *
   *
   * @example
   *   var result = format('#1 + #2 + #3', 10, 20, 30);
   *   debug(result);
   *   // @results '10 + 20 + 30'
   *
   *
   * @example
   *   var result = format('J#1v#1#2 ECMA#2', 'a', 'Script');
   *   debug(result);
   *   // @results 'JavaScript ECMAScript'
   *
   *
   * @param  {String}   fmt   A string format.
   * @param  {...*}    (...)  Format arguments.
   * @return {String}         Returns a formatted string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  format : (function() {
    var args,
        re = /#(\d+)/g,
        /**@ignore*/
        rep = function(a, i) {
          return args && args[+i];
        };
    return function(fmt/*[, ...args]*/) {
      var f = stringify(fmt, true);
      args = arrayize(arguments);
      if (!args || !args.length) {
        return f;
      }
      re.lastIndex = 0;
      return f.replace(re, rep);
    };
  }()),
  /**
   * Tokenize a function code simply.
   *
   *
   * @example
   *   var hoge = function() {
   *     var a = 1, b = 0.5, c = '"hoge"', $d = /'\/'/g;
   *     return $d.test(c) ? a : b;
   *   };
   *   debug( Pot.tokenize(hoge) );
   *   // @results
   *   // [
   *   //   'function', '(', ')', '{', '\n',
   *   //     'var', 'a', '=', '1', ',', 'b', '=', '0.5', ',',
   *   //            'c', '=', '\'"hoge"\'', ',',
   *   //            '$d', '=', '/\'\\/\'/g', ';', '\n',
   *   //     'return', '$d', '.', 'test', '(', 'c', ')', '?',
   *   //               'a', ':', 'b', ';', '\n',
   *   //   '}'
   *   // ]
   *
   *
   * @param  {Function|String}   func   The code or function to tokenize.
   * @return {Array}                    Tokens as an array.
   * @type  Function
   * @function
   * @static
   * @public
   */
  tokenize : (function() {
    var RE = {
      TOKEN : new RegExp(
        '(' + '/[*][\\s\\S]*?[*]/' +                  // multiline comment
        '|' + '/{2,}[^\\r\\n]*(?:\\r\\n|\\r|\\n|)' +  // single line comment
        '|' + '"(?:\\\\[\\s\\S]|[^"\\r\\n\\\\])*"' +  // string literal
        '|' + "'(?:\\\\[\\s\\S]|[^'\\r\\n\\\\])*'" +  // string literal
        '|' + '(' + '^' +                         // (2) regexp literal prefix
              '|' + '[-!%&*+,/:;<=>?[{(^|~]' +
              ')' +
              '(?:' +
                  '(' +    // (3) line break
                    '(?!' + '[\\r\\n])\\s+' +
                      '|' + '(?:\\r\\n|\\r|\\n)' +
                   ')' +
                '|' + '\\s*' +
              ')' +
              '(?:' +
                '(' +      // (4) regular expression literal
                    '(?:/(?![*])(?:\\\\.|[^/\\r\\n\\\\])+/)' +
                    '(?:[gimy]{0,4}|\\b)' +
                ')' +
                '(?=\\s*' +
                  '(?:' + '(?!\\s*[/\\\\<>*+%`^"\'\\w$-])' +
                          '[^/\\\\<>*+%`^\'"@({[\\w$-]' +
                    '|' + '===?' +
                    '|' + '!==?' +
                    '|' + '[|][|]' +
                    '|' + '[&][&]' +
                    '|' + '/(?:[*]|/)' +
                    '|' + '[,.;:!?)}\\]\\r\\n]' +
                    '|' + '$' +
                  ')' +
                ')' +
              ')' +
        '|' + '<(\\w+(?::\\w+|))\\b[^>]*>' +          // (5) e4x
              '(?:(?!</\\5>(?!\\s*[\'"]))[\\s\\S])*' +
              '</\\5>' +
        '|' + '<>[\\s\\S]*?</>' +                     // e4x
        '|' + '>>>=?|<<=|===|!==|>>=' +               // operators
        '|' + '[+][+](?=[+])|[-][-](?=[-])' +
        '|' + '[=!<>*+/&|^-]=' +
        '|' + '[&][&]|[|][|]|[+][+]|[-][-]|<<|>>' +
        '|' + '0(?:[xX][0-9a-fA-F]+|[0-7]+)' +        // number literal
        '|' + '\\d+(?:[.]\\d+)?(?:[eE][+-]?\\d+)?' +
        '|' + '[1-9]\\d*' +
        '|' + '[-+/%*=&|^~<>!?:,;@()\\\\[\\].{}]' +   // operator
        '|' + '(?:(?![\\r\\n])\\s)+' +                // white space
        '|' + '(?:\\r\\n|\\r|\\n)' +                  // nl
        '|' + '[^\\s+/%*=&|^~<>!?:,;@()\\\\[\\].{}\'"-]+' + // token
        ')',
        'g'
      ),
      LINEBREAK : /^(?:\r\n|\r|\n)/,
      NOTSPACE  : /[\S\r\n]/,
      COMMENTS  : /^\/{2,}[\s\S]*$|^\/[*][\s\S]*?[*]\/$/
    },
    LIMIT  = 0x2000,
    COUNT  = 0,
    PREFIX = '.',
    CACHES = {};
    return function(func) {
      var r = [], m, token, prev, s = Pot.getFunctionCode(func);
      if (s) {
        if ((PREFIX + s) in CACHES) {
          return CACHES[PREFIX + s];
        }
        RE.TOKEN.lastIndex = 0;
        while ((m = RE.TOKEN.exec(s)) != null) {
          token = m[1];
          if (!RE.NOTSPACE.test(token) || RE.COMMENTS.test(token)) {
            continue;
          }
          if (m[4]) {
            if (m[2]) {
              r[r.length] = m[2];
            }
            if (m[3] && RE.NOTSPACE.test(m[3])) {
              r[r.length] = m[3];
            }
            r[r.length] = m[4];
          } else {
            prev = r[r.length - 1];
            if (!prev ||
                !RE.LINEBREAK.test(prev) || !RE.LINEBREAK.test(token)) {
              r[r.length] = token;
            }
          }
        }
        if (COUNT < LIMIT) {
          CACHES[PREFIX + s] = r;
          COUNT++;
        }
      }
      return r;
    };
  }()),
  /**
   * Joins the tokenized array.
   *
   *
   * @example
   *   var hoge = function() {
   *     var a = 1, b = 0.5, c = '"hoge"', $d = /'\/'/g;
   *     return $d.test(c) ? a : b;
   *   };
   *   var tokens = Pot.tokenize(hoge);
   *   var result = Pot.joinTokens(tokens);
   *   // @results
   *   //   'function(){\n' +
   *   //     'var a=1,b=0.5,c=\'"hoge"\',$d=/\'\\/\'/g;\n' +
   *   //     'return $d.test(c)?a:b;\n' +
   *   //   '}'
   *
   *
   * @param  {Array}   tokens   The tokenized array.
   * @return {String}           Returns a string that joined from tokens.
   * @type  Function
   * @function
   * @static
   * @public
   */
  joinTokens : (function() {
    var isWord = /^[^\s+\/%*=&|^~<>!?:,;@()\\[\].{}'"-]+$/,
        isSign = /^[-+]+$/;
    return function(tokens) {
      var result = [], len, prev, prevSuf, pre, suf, i, token;
      if (isArray(tokens)) {
        len = tokens.length;
        for (i = 0; i < len; i++) {
          token = tokens[i];
          if (!prev) {
            result[result.length] = token;
          } else {
            pre = '';
            suf = '';
            if (token === 'in') {
              if (!prevSuf) {
                pre = ' ';
              }
              suf = ' ';
            } else if (isSign.test(token)) {
              if (!prevSuf && isSign.test(prev)) {
                pre = ' ';
              }
            } else if (isWord.test(prev.slice(-1)) &&
                       isWord.test(token.charAt(0))) {
              pre = ' ';
            }
            if (prevSuf === ' ') {
              pre = '';
            }
            result[result.length] = pre + token + suf;
          }
          prev = token;
          prevSuf = suf;
        }
      }
      return result.join('');
    };
  }()),
  /**
   * Check whether the function has "return" statement.
   *
   *
   * @example
   *   var func = function() {
   *     return 'hoge';
   *   };
   *   debug(hasReturn(func));
   *   // @results  true
   *
   *
   * @example
   *   var func = function() {
   *     var hoge = 1;
   *   };
   *   debug(hasReturn(func));
   *   // @results  false
   *
   *
   * @example
   *   var func = function return_test(return1, return$2) {
   *     // dummy comment: return 'hoge';
   *     var $return = 'return(1)' ? (function(a) {
   *       if (a) {
   *         return true;
   *       }
   *       return false;
   *     })(/return true/) : "return false";
   *   };
   *   debug(hasReturn(func));
   *   // @results  false
   *
   *
   * @example
   *   var func = function() {
   *     if (1) {
   *       return (function() {
   *         return 'hoge';
   *       })();
   *     }
   *   };
   *   debug(hasReturn(func));
   *   // @results  true
   *
   *
   * @example
   *   // See source code directly.
   *   // Using E4X Syntax for test.
   *   var func = function() {
   *     // return 'hoge';
   *     var e1 = <>return</>;
   *     var e2 = <><![CDATA[
   *       return 1;
   *     ]]></>;
   *     var e3 = <> <div data={(function() {
   *       return 'hoge';
   *     })()}>
   *       return 1;
   *     </div></>;
   *     var e4 = <><!--</>-->return 1;</>;
   *     var re = /<><!--[\/]--><\/>/gim;
   *     var e5 = <root><hoge fuga={(function() {
   *       return 1;
   *     })()} piyo="<root>">
   *     <root>return</root>return;<!--</root>"<root>"-->return;
   *     <!--return-->
   *     </hoge></root>;
   *     var root = "</root>";
   *     var r = 'return(1)' ? (function(a) {
   *       if (a) {
   *         return true;
   *       }
   *       return false;
   *     })(/return true/) : "return false";
   *   };
   *   debug(hasReturn(func));
   *   // @results  false
   *
   *
   * @param  {Function|String}   func   The code or function to check.
   * @return {Boolean}                  Whether the function has
   *                                      "return" statement.
   * @type  Function
   * @function
   * @static
   * @public
   */
  hasReturn : (function() {
    var PATTERNS = {
      STRIP    : new RegExp(
              '^\\s*function\\b[^{]*[{]' +            // function prefix
        '|' + '[}][^}]*$' +                           // function suffix
        '|' + '/[*][\\s\\S]*?[*]/' +                  // multiline comment
        '|' + '/{2,}[^\\r\\n]*(?:\\r\\n|\\r|\\n|)' +  // single line comment
        '|' + '"(?:\\\\.|[^"\\\\])*"' +               // string literal
        '|' + "'(?:\\\\.|[^'\\\\])*'",                // string literal
        'g'
      ),
      RETURN   : /(?:^|\s|[^\w$.]\b)return(?:[^\w$.]\b|\s|$)/,
      FUNC     : /(?:^|\s|[^\w$.]\b)function(?:[^\w$.]\b|\s|)[^{}]*$/,
      PREREGEX : /(?:^|[,;:!?=&|!([]|[^\w$.<>%'"@){}\]])\s*\/$/,
      REGEXP   : /(\/(?![*])(?:\\.|[^\/\r\n\\])+\/)$/,
      E4X      : /(?:^|[(){}<>&|%*~^!?:;,\/[\]=+-])\s*<([^\s>]*)[^>]*>$/,
      TAG      : /<([^\s>]*)[^>]*>$/
    },
    limit = 0x2000,
    count = 0,
    cache = {};
    return function(func) {
      var result = false, code, open, close, org,
          s, i, len, c, n, x, z, r, m, cdata, tag, skip;
      code = Pot.getFunctionCode(func);
      if (code in cache) {
        return cache[code];
      }
      org = code;
      code = code.replace(PATTERNS.STRIP, '');
      if (code && PATTERNS.RETURN.test(code)) {
        n = 0;
        x = 0;
        r = '';
        z = '';
        s = '';
        tag = '';
        skip = false;
        cdata = false;
        len = code.length;
        for (i = 0; i < len; i++) {
          c = code.charAt(i);
          if (r && c !== '/') {
            r += c;
            continue;
          }
          switch (c) {
            case '{':
                if (x === 0 && PATTERNS.FUNC.test(s)) {
                  n++;
                }
                break;
            case '}':
                if (x === 0 && n > 0) {
                  n--;
                }
                break;
            case '/':
                if (!skip && n === 0) {
                  if (x > 0) {
                    z += c;
                  } else if (!r) {
                    s += c;
                    if (PATTERNS.PREREGEX.test(s)) {
                      r = c;
                      s = s.slice(0, -1) + ' ';
                    }
                  } else if (r) {
                    r += c;
                    if (PATTERNS.REGEXP.test(r)) {
                      r = '';
                    }
                  }
                }
                break;
            case '-':
                if (n === 0) {
                  if (x > 0) {
                    z += c;
                    if (z.slice(-4) === '<!--') {
                      skip = true;
                      z = z.slice(0, -4) + ' ';
                    }
                  } else {
                    s += c;
                  }
                }
                break;
            case '[':
                if ((cdata || !skip) && n === 0) {
                  if (x > 0) {
                    z += c;
                    if (z.slice(-9).toUpperCase() === '<![CDATA[') {
                      skip = true;
                      cdata = true;
                      z = z.slice(0, -9) + ' ';
                    }
                  } else {
                    s += c;
                  }
                }
                break;
            case ']':
            case '<':
                if ((cdata || !skip) && n === 0) {
                  if (x > 0) {
                    z += c;
                  } else {
                    s += c;
                  }
                }
                break;
            case '>':
                if (n === 0) {
                  if (x === 0) {
                    s += c;
                    if (PATTERNS.E4X.test(s)) {
                      m = s.match(PATTERNS.TAG);
                      x++;
                      s = s.slice(0, -m[0].length) + ' ';
                      tag = m[1];
                      close = new RegExp('</' + rescape(tag) + '>$');
                      open  = new RegExp('<' + rescape(tag) + '\\b[^>]*>$');
                    }
                  } else if (x > 0) {
                    if (skip) {
                      if ((!cdata && z.slice(-2) === '--') ||
                           (cdata && z.slice(-2) === ']]')) {
                        skip = cdata = false;
                        z = z.slice(0, -2);
                      }
                      z += ' ';
                      break;
                    }
                    z += c;
                    if (close && close.test(z)) {
                      x--;
                      if (x === 0) {
                        tag = z = '';
                      }
                    } else if (open && open.test(z)) {
                      x++;
                    }
                  }
                }
                break;
            default:
                if (!skip && n === 0) {
                  if (x > 0) {
                    z += c;
                  } else {
                    s += c;
                  }
                }
          }
        }
        if (PATTERNS.RETURN.test(s)) {
          result = true;
        }
      }
      if (count < limit) {
        cache[org] = result;
        count++;
      }
      return result;
    };
  }()),
  /**
   * Override the method of the object.
   * That enable replace the return value and the arguments variables.
   *
   *
   * @example
   *   var Hoge = {
   *     addHoge : function(value) {
   *       return value + 'hoge';
   *     }
   *   };
   *   debug(Hoge.addHoge('fugafuga'));
   *   // @results 'fugafugahoge'
   *   override(Hoge, 'addHoge', function(inherits, args, self, prop) {
   *     var value = args[0];
   *     var modify = '{{Modified:' + value + '}}';
   *     args[0] = '';
   *     return modify + inherits(args);
   *   });
   *   var result = Hoge.addHoge('fugafuga');
   *   debug(result);
   *   // @results '{{Modified:fugafuga}}hoge'
   *
   *
   * @example
   *   var Numbers = {
   *     NAME   : 'Numbers',
   *     logAdd : function(a, b) {
   *       return this.NAME + ':' + (a + b);
   *     }
   *   };
   *   debug(Numbers.logAdd(1, 2));
   *   // @results  'Numbers:3'
   *   //
   *   override(Numbers, 'logAdd', [[
   *     /\bthis\.NAME\b/,
   *     '"Result"'
   *   ], [
   *     /(["']):(['"])/,
   *     '$1 = $2'
   *   ], [
   *     /\ba\s*[+]\s*b\b/,
   *     '(a * b * 100)'
   *   ]]);
   *   debug(Numbers.logAdd(1, 2));
   *   // @results  'Result = 200'
   *
   *
   * @example
   *   var Numbers = {
   *     NAME   : 'Numbers',
   *     logAdd : function(a, b) {
   *       return this.NAME + ':' + (a + b);
   *     }
   *   };
   *   debug(Numbers.logAdd(1, 2));
   *   // @results  'Numbers:3'
   *   //
   *   override(Numbers, 'logAdd', [
   *     /this\.NAME\s*[+]\s*([()])?\s*["']:['"]\s*[+]/,
   *     '"(*l_l)/"+$1'
   *   ], function(inherits, args, self, prop) {
   *     var a = args[0], b = args[1];
   *     return '{{' + inherits(a + 100, b + 100) + '}}';
   *   });
   *   debug(Numbers.logAdd(1, 2));
   *   // @results  '{{(*l_l)/203}}'
   *
   *
   * @param  {Object}  object
   *         The target object.
   *
   * @param  {String|RegExp|Array}  properties
   *         The method name. (can be multiple).
   *         That can also be specified by regular expressions, and arrays.
   *
   * @param  {Array|RegExp|String}  converters/overrider
   *         (Optional) The converters to replace the function source code
   *           by RegExp patterns.
   *         e.g.
   *           [/\breturn\b\s*([^;]+);/, 'throw $1;']
   *
   * @param  {Function}  overrider/converters
   *         (Optional) The processing function.
   *         The 4 arguments are passed.
   *         <pre>
   *           function(inherits, args, self, prop)
   *             - inherits : {Function}
   *                          Inherits function for the original method.
   *             - args     : {Arguments}
   *                          The original arguments.
   *             - self     : {Object}
   *                          The original object self.
   *             - prop     : {String}
   *                          The target method name.
   *         </pre>
   *
   * @return {Object}    Return the first argument `object`.
   * @type  Function
   * @function
   * @static
   * @public
   * @based Tombloo.addAround
   */
  override : function(object, properties, converters, overrider) {
    var props = [], t;
    if (object && properties && (converters || overrider)) {
      if (overrider) {
        if (isFunction(converters)) {
          t = converters;
          converters = overrider;
          overrider = t;
        }
      } else {
        if (isFunction(converters)) {
          overrider = converters;
        }
      }
      if (isRegExp(converters)) {
        converters = [converters, ''];
      } else if (isString(converters)) {
        converters = [new RegExp(rescape(converters), 'g'), ''];
      }
      each(arrayize(properties), function(name) {
        if (name) {
          each(object, function(val, prop) {
            if (isFunction(val) &&
                ((isRegExp(name) && name.test(prop)) || name == prop)) {
              props[props.length] = prop;
            }
          });
        }
      });
      each(props, function(prop) {
        var method, code, org, patterns, canApply;
        if (hasOwnProperty.call(object, prop)) {
          method = object[prop];
          canApply = !!(object[prop] && object[prop].apply &&
            typeof object[prop].apply === typeof object[prop].call);
          if (converters) {
            code = org = Pot.getFunctionCode(method);
            patterns = arrayize(converters);
            if (!isArray(patterns[0])) {
              patterns = [patterns];
            }
            each(patterns, function(pattern) {
              var from, to;
              try {
                from = pattern[0];
                to   = pattern[1];
                if (isString(from)) {
                  from = new RegExp(rescape(from), 'g');
                }
                if (!isString(to)) {
                  to = '';
                }
                code = code.replace(from, to);
              } catch (e) {}
            });
            if (org !== code) {
              method = Pot.localEval(code, object);
            }
          }
          object[prop] = update(function() {
            var that = this, args = arguments;
            if (isFunction(overrider)) {
              return overrider.call(that, function() {
                var a = arguments;
                if (a.length === 1 && a[0] &&
                     Pot.isArguments(a[0]) && a[0] === args) {
                  if (canApply) {
                    return method.apply(that, arrayize(a[0]));
                  } else {
                    return invoke(object, prop, arrayize(a[0]));
                  }
                } else {
                  if (canApply) {
                    return method.apply(that, arrayize(a));
                  } else {
                    return invoke(object, prop, arrayize(a));
                  }
                }
              }, args, that, prop);
            } else {
              return method.apply(that, args);
            }
          }, object[prop]);
          if (!object[prop].overridden ||
              isNumber(object[prop].overridden)) {
            update(object[prop], {
              overridden : ((object[prop].overridden || 0) - 0) + 1
            });
          }
        }
      });
    }
    return object;
  },
  /**
   * Get the error message from Error object.
   *
   *
   * @example
   *   var error = new Error('MyError!');
   *   debug(getErrorMessage(error));
   *   // @results 'MyError!'
   *
   *
   * @param  {Error|*}    error      Error object.
   * @param  {String|*}  (defaults)  Optional message.
   * @return {String}                Return the error message, or 'error'.
   * @type  Function
   * @function
   * @static
   * @public
   */
  getErrorMessage : function(error, defaults) {
    var msg;
    if (isError(error)) {
      msg = String(error.message  || error.description ||
                  (error.toString && error.toString()) || error);
    } else {
      msg = (error && error.toString && error.toString()) || error;
    }
    return stringify(msg) || stringify(defaults) || 'error';
  },
  /**
   * Create new instance of Blob.
   *
   *
   * @example
   *   Pot.begin(function() {
   *     var blob = Pot.createBlob('hoge');
   *     var reader = new FileReader();
   *     reader.readAsText(blob);
   *     return reader;
   *   }).then(function(res) {
   *     Pot.debug(res); // 'hoge'
   *   });
   *
   *
   * @param  {*}         value   value.
   * @param  {(String)}  (type)  Optional MIME type.
   * @return {Blob}              Return new instance of Blob.
   * @type  Function
   * @function
   * @static
   * @public
   */
  createBlob : function(value, type) {
    if (PotSystem.createBlob) {
      try {
        return PotSystem.createBlob(value, type);
      } catch (e) {}
    }
    return null;
  },
  /**
   * Create a constructor with prototype.
   *
   * That will set the toString method to constructor
   *   if argument `name` specified.
   * If argument `init` has been specified in the string,
   *   then that method will be used to initialize.
   * If argument `init` has been specified in a function,
   *   then initialization will be execute by `init`.
   * If omitted argument `init`, and `proto` has 'init' function
   *   then initialization will be execute by 'init' function.
   *
   *
   * @example
   *   var Hoge = Pot.createConstructor('Hoge', {
   *     init : function(a, b, c) {
   *       this.value = a + b + c;
   *     },
   *     getHoge : function() {
   *       return 'hogehoge';
   *     }
   *   });
   *   Pot.debug(new Hoge(1, 2, 3).value); // 6
   *   Pot.debug(new Hoge().getHoge());    // 'hogehoge'
   *
   *
   * @example
   *   var Fuga = Pot.createConstructor({
   *     value : 1,
   *     addValue : function(v) {
   *       this.value += v;
   *       return this;
   *     },
   *     getValue : function() {
   *       return this.value;
   *     }
   *   }, function(a, b, c) {
   *     this.value += a + b + c;
   *   });
   *   Pot.debug(new Fuga(1, 2, 3).value); // 7
   *   Pot.debug(new Fuga(1, 2, 3).addValue(10).getValue()); // 17
   *
   *
   * @example
   *   var Piyo = Pot.createConstructor('Piyo', {
   *     initialize : function(a, b, c) {
   *       this.value = a + b + c;
   *     },
   *     getValue : function() {
   *       return this.value;
   *     }
   *   }, 'initialize');
   *   Pot.debug(new Piyo(10, 20, 30).getValue()); // 60
   *
   *
   * @param  {(String)} (name)  (Optional) A name of constructor.
   * @param  {Object}  (proto)  prototype.
   * @param  {(Function|String)} (init) (Optional) initialization method name
   *                                    or initialization function.
   * @return {Function} Return new constructor.
   * @type  Function
   * @function
   * @static
   * @public
   */
  createConstructor : function(name, proto, init) {
    var c, p, n, def = 'init';
    if (isString(name)) {
      n = name;
    } else {
      init = proto;
      proto = name;
    }
    p = proto || {};
    if (!init && def in p) {
      init = def;
    }
    if (isString(init) && init in p) {
      /**@ignore*/
      c = function() {
        this[init].apply(this, arguments);
      };
    } else if (isFunction(init)) {
      proto.init = init;
      /**@ignore*/
      c = function() {
        this.init.apply(this, arguments);
      };
    }
    if (!c) {
      /**@ignore*/
      c = function() {};
    }
    c.prototype = p;
    c.prototype.constructor = c;
    if (n) {
      /**@ignore*/
      c.prototype.toString = function() {
        return buildObjectString(n);
      };
    }
    return c;
  }
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Shortcut functions.

/**
 * @ignore
 */
function update() {
  var args = arguments, len = args.length, i = 1, o, p, x;
  if (len === i) {
    o = this || {};
    i--;
  } else {
    o = args[i - 1];
  }
  if (o) {
    do {
      x = args[i];
      if (x) {
        // Includes prototype properties.
        for (p in x) {
          try {
            o[p] = x[p];
          } catch (e) {}
        }
      }
    } while (++i < len);
  }
  return o;
}

/**
 * @ignore
 */
function arrayize(object, index) {
  var array, i, len, me = arrayize, t;
  if (me.canNodeList == null) {
    // NodeList cannot convert to the Array in the Blackberry, IE browsers.
    if (PotSystem.currentDocument) {
      try {
        t = slice.call(
          PotSystem.currentDocument.documentElement.childNodes
        )[0].nodeType;
        t = null;
        me.canNodeList = true;
      } catch (e) {
        me.canNodeList = false;
      }
    }
  }
  if (object == null) {
    array = [object];
  } else {
    switch (typeOf(object)) {
      case 'array':
          array = object.slice();
          break;
      case 'object':
          if (isArrayLike(object)) {
            if (!me.canNodeList && isNodeList(object)) {
              array = [];
              i = 0;
              len = object.length;
              do {
                array[i] = object[i];
              } while (++i < len);
            } else {
              array = slice.call(object);
            }
            break;
          }
          // FALL THROUGH
      default:
          array = slice.call(concat.call([], object));
    }
  }
  if (index > 0) {
    array = array.slice(index);
  }
  return array;
}

/**
 * @ignore
 */
function numeric(value, defaults) {
  var result = 0, def = 0, args = arguments, me = numeric, s, m;
  if (!me.PATTERNS) {
    me.PATTERNS = {
      BASE36GZ  : /[g-z]/,
      BASE36G   : /[^a-z0-9]/g,
      BASE36    : /[^a-z0-9]/,
      BASE16    : /[a-f]/,
      MB_DIGITS : /[\uFF10-\uFF19]/,
      COMMAS    : /[,\uFF0C]+/g,
      STRIP     : /[^\w$]/g,
      NUMBERS   :
        /([+-]?(?:0[0-7]+|0x[\da-f]+|(?:\d+[.]?\d*|[.]\d+)(?:e[-+]?\d+)?))/i,
      LEFT_SYMBOLS :
        /^[\s\xA0\u3000\x00-\x20!-\/:-@[-\]^-`{|}~\x7F-\xFF]*/,
      LEFT_NUMBERS :
        /^[^\d]{0,5}((?:0x?|)(?:\d+[.]?\d*|[.]\d+)(?:e[-+]?\d+|))/i
    };
  }
  if (isNumeric(value)) {
    result = value - 0;
  } else {
    if (args.length >= 2 && isNumeric(defaults)) {
      result = defaults - 0;
    } else if (value == null) {
      result = 0;
    } else {
      def = 0;
      switch (typeLikeOf(value)) {
        case 'boolean':
            result = (value == true) ? 1 : 0;
            break;
        case 'string':
            if (!value) {
              result = def;
            } else {
              s = value.replace(RE_STRIP, '')
                       .replace(me.PATTERNS.COMMAS, '');
              if (Pot.Text && me.PATTERNS.MB_DIGITS.test(s)) {
                s = Pot.Text.toHankakuCase(s);
              }
              if ((m = s.match(me.PATTERNS.NUMBERS)) &&
                  s.indexOf(m[1]) === 0) {
                result = m[1] - 0;
              } else {
                if (Pot.Sanitizer && Pot.isJSEscaped(s)) {
                  s = Pot.Sanitizer.unescapeSequence(s);
                }
                if (Pot.Sanitizer && Pot.isHTMLEscaped(s)) {
                  s = Pot.Sanitizer.unescapeHTML(s);
                }
                if (Pot.URI && Pot.isPercentEncoded(s)) {
                  s = Pot.URI.urlDecode(s);
                }
                if ((m = s.match(me.PATTERNS.NUMBERS)) &&
                    s.indexOf(m[1]) === 0) {
                  result = m[1] - 0;
                } else {
                  if (!me.PATTERNS.BASE36.test(s)) {
                    if (me.PATTERNS.BASE36GZ.test(s)) {
                      result = parseInt(s, 36);
                    } else if (me.PATTERNS.BASE16.test(s)) {
                      result = parseInt(s, 16);
                    } else {
                      result = parseInt(s, 10);
                    }
                  } else {
                    s = s.replace(me.PATTERNS.LEFT_SYMBOLS, '');
                    if ((m = s.match(me.PATTERNS.LEFT_NUMBERS))) {
                      result = m[1] - 0;
                    } else if ((m = s.match(me.PATTERNS.NUMBERS))) {
                      result = m[1] - 0;
                    } else {
                      result = parseInt(
                        s.replace(me.PATTERNS.BASE36G, ''),
                        36
                      );
                    }
                  }
                }
              }
            }
            break;
        case 'function':
            result = 0xCAAE163D + (+value.length || 0);
            break;
        case 'regexp':
            s = value.toString();
            if (Pot.Crypt) {
              result = Pot.Crypt.hashCode(s);
            } else {
              result = me(s);
            }
            break;
        case 'array':
            result = value.length;
            break;
        case 'date':
            result = value.getTime();
            break;
        case 'number':
            result = value - 0;
            break;
        case 'object':
            result = 0xA8ADABEC;
            break;
        case 'error':
            result = me(String(
              value.message || value.description || value
            ));
            break;
        default:
            try {
              result = me(Pot.JSON.stringify(value));
            } catch (e) {
              result = me(
                (value == null) ? String(value) : value.toString()
              );
            }
      }
    }
  }
  return (isNumeric(result) ? result : def) - 0;
}

/**
 * @ignore
 */
function now() {
  return +new Date;
}

/**
 * @ignore
 */
function stringify(x, ignoreBoolean) {
  var result = '', c, len = arguments.length;
  if (x !== null) {
    switch (typeof x) {
      case 'string':
      case 'number':
      case 'xml':
          result = x;
          break;
      case 'boolean':
          if (len >= 2 && !ignoreBoolean) {
            result = x;
          } else if (!ignoreBoolean) {
            result = x ? 1 : '';
          }
          break;
      case 'object':
          if (x) {
            //XXX: TypedArray String convertion.
            c = x.constructor;
            if (c === String || c === Number ||
                (typeof XML !== 'undefined' && c === XML) ||
                (typeof Buffer !== 'undefined' && c === Buffer)) {
              result = x;
            } else if (c === Boolean) {
              if (len >= 2 && !ignoreBoolean) {
                result = x;
              } else if (!ignoreBoolean) {
                result = (x == true) ? 1 : '';
              }
            }
          }
    }
  }
  return result.toString();
}

/**
 * @ignore
 */
function trim(s, chars, ignoreCase) {
  var re;
  if (chars) {
    re = new RegExp(
      ['^[', ']+|[', ']+$'].join(rescape(chars)),
      'g' + (ignoreCase ? 'i' : '')
    );
  } else {
    re = RE_TRIM;
  }
  return stringify(s, true).replace(re, '');
}

/**
 * @ignore
 */
function rescape(s) {
  return stringify(s, true).replace(RE_RESCAPE, '\\$1');
}

/**
 * @ignore
 */
function invoke(/*object[, method[, ...args]]*/) {
  var args = arrayize(arguments), argn = args.length,
      object, method, params, emit, p, t, i, len, err;
  try {
    switch (argn) {
      case 0:
          throw false;
      case 1:
          method = args[0];
          break;
      case 2:
          object = args[0];
          method = args[1];
          break;
      case 3:
          object = args[0];
          method = args[1];
          params = arrayize(args[2]);
          break;
      default:
          object = args[0];
          method = args[1];
          params = arrayize(args, 2);
    }
    if (!method) {
      throw method;
    }
    if (!object && isString(method)) {
      object = (object && object[method] && object)  ||
             (globals && globals[method] && globals) ||
          (PotGlobal && PotGlobal[method] && PotGlobal);
    }
    if (isString(method)) {
      emit = true;
      if (!object) {
        object = (globals || PotGlobal);
      }
    }
  } catch (e) {
    err = e;
    throw isError(err) ? err : new Error(err);
  }
  if (isFunction(method.apply) && isFunction(method.call)) {
    if (params == null || !params.length) {
      return method.call(object);
    } else {
      return method.apply(object, params);
    }
  } else {
    p = params || [];
    len = p.length || 0;
    if (emit) {
      // faster way.
      switch (len) {
        case 0: return object[method]();
        case 1: return object[method](p[0]);
        case 2: return object[method](p[0], p[1]);
        case 3: return object[method](p[0], p[1], p[2]);
      }
    } else {
      switch (len) {
        case 0: return method();
        case 1: return method(p[0]);
        case 2: return method(p[0], p[1]);
        case 3: return method(p[0], p[1], p[2]);
      }
    }
    t = [];
    for (i = 0; i < len; i++) {
      t[t.length] = 'p[' + i + ']';
    }
    return (new Function(
      'e,o,m,p',
      ['return e?o[m](', '):m(', ');'].join(t.join(','))
    ))(emit, object, method, p);
  }
}

/**
 * @ignore
 */
function debug(msg) {
  var args = arguments, me = debug, func, consoleService;
  try {
    if (!me.firebug('log', args)) {
      if (!PotSystem.hasComponents) {
        throw false;
      }
      consoleService = Cc['@mozilla.org/consoleservice;1']
                      .getService(Ci.nsIConsoleService);
      consoleService.logStringMessage(String(msg));
    }
  } catch (e) {
    if (typeof console !== 'undefined' && console) {
      func = console.debug || console.dir || console.log;
    } else if (typeof opera !== 'undefined' && opera && opera.postError) {
      func = opera.postError;
    } else if (typeof GM_log === 'function') {
      func = GM_log;
    } else {
      /**@ignore*/
      func = function(x) { throw x; };
    }
    try {
      if (func.apply) {
        func.apply(func, args);
      } else {
        throw func;
      }
    } catch (e) {
      try {
        func(msg);
      } catch (e) {
        try {
          console.log(msg);
        } catch (e) {
          try {
            me.divConsole(msg);
          } catch (e) {}
        }
      }
    }
  }
  return msg;
}

/**
 * @ignore
 */
function error(msg) {
  var args = arguments, func;
  try {
    if (!debug.firebug('error', args)) {
      if (!PotSystem.hasComponents) {
        throw false;
      }
      Cu.reportError(msg);
    }
  } catch (e) {
    if (typeof console !== 'undefined' && console) {
      func = console.error || console.debug || console.dir || console.log;
    } else if (typeof opera !== 'undefined' && opera && opera.postError) {
      func = opera.postError;
    } else if (typeof GM_log === 'function') {
      func = GM_log;
    } else {
      /**@ignore*/
      func = function(x) { throw x; };
    }
    try {
      if (func.apply) {
        func.apply(func, args);
      } else {
        func(msg);
      }
    } catch (e) {
      throw msg;
    }
  }
  return msg;
}

// Update debug function.
update(debug, {
  /**
   * @ignore
   */
  firebug : function(method, args) {
    var result = false, win, fbConsole;
    try {
      if (!PotSystem.hasComponents) {
        throw false;
      }
      win = Pot.XPCOM.getMostRecentWindow();
      if (!win) {
        throw win;
      }
      if (win.FirebugConsole && win.FirebugContext) {
        fbConsole = new win.FirebugConsole(win.FirebugContext, win.content);
        fbConsole[method].apply(fbConsole, args);
        result = true;
      } else if (win.Firebug && win.Firebug.Console) {
        try {
          win.Firebug.Console.logFormatted.call(
            win.Firebug.Console,
            arrayize(args),
            win.FirebugContext,
            method
          );
          result = true;
        } catch (er) {}
      }
    } catch (e) {}
    return result;
  },
  /**
   * @ignore
   */
  dump : function(o) {
    var r, me = debug.dump, repr;
    /**@ignore*/
    repr = function(x) {
      return (x == null) ? String(x)    :
              x.toString ? x.toString() : String(x);
    };
    if (o == null) {
      return String(o);
    }
    if (typeof uneval === 'function') {
      return uneval(o);
    } else if (typeof o.toSource === 'function') {
      return o.toSource();
    }
    r = [];
    switch (typeLikeOf(o)) {
      case 'array':
          each(o, function(v) {
            r[r.length] = me(v);
          });
          return '[' + r.join(', ') + ']';
      case 'object':
          if (isNodeLike(o) || isWindow(o) || isDocument(o)) {
            r[r.length] = toString.call(o);
          } else {
            each(o, function(v, k) {
              r[r.length] = k + ': ' + me(v);
            });
          }
          return '{' + r.join(', ') + '}';
      case 'string':
          return '"' + repr(o) + '"';
      case 'function':
          return '(' + repr(o) + ')';
      default:
          return repr(o);
    }
  },
  /**
   * @ignore
   */
  divConsole : update(function(msg) {
    var me = debug.divConsole, ie6, doc, de, onResize, onScroll, onClick;
    if (PotSystem.hasActiveXObject && typeof document !== 'undefined') {
      doc = document;
      de = doc.documentElement || {};
      try {
        ie6 = (typeof de.style.maxHeight === 'undefined');
      } catch (e) {}
      if (me.done && me.ieConsole) {
        me.append(msg);
      } else {
        if (!me.msgStack) {
          me.msgStack = [];
        }
        me.msgStack.push(msg);
        if (!me.done) {
          me.done = true;
          Deferred.till(function() {
            return !!(doc && doc.body);
          }).then(function() {
            var defStyle, style, close, wrapper;
            defStyle = {
              border     : '1px solid #999',
              background : '#fff',
              color      : '#333',
              fontSize   : '13px',
              fontFamily : 'monospace',
              position   : 'absolute',
              padding    : '10px',
              margin     : '0px',
              zoom       : 1
            };
            wrapper = doc.createElement('div');
            style = wrapper.style;
            each(defStyle, function(v, k) {
              style[k] = v;
            });
            style.borderWidth  = '3px';
            style.width        = '95%';
            style.zIndex       = 9996;
            style.left         = '0px';
            style.bottom       = '0px';
            style.zoom         = 1;
            if (ie6) {
              style.height = Math.floor(de.clientHeight / 3.2) + 'px';
            } else {
              style.position = 'fixed';
              style.height   = '25%';
            }
            me.titlebar = doc.createElement('div');
            style = me.titlebar.style;
            style.zIndex      = 9999;
            style.border      = '0';
            style.width       = '95%';
            style.position    = 'relative';
            style.margin      = '2px';
            style.fontWeight  = 'bold';
            style.color       = '#333';
            style.background  = '#fff';
            style.fontFamily  = 'verdana';
            style.zoom        = 1;
            me.titlebar.appendChild(doc.createTextNode('Pot.js Console'));
            me.ieConsole = wrapper.cloneNode(false);
            me.ieConsole.id = me.ieConsoleId = buildSerial(Pot, '');
            style = me.ieConsole.style;
            style.borderWidth = '1px';
            style.width       = '95%';
            style.height      = '68%';
            style.position    = 'relative';
            style.zIndex      = 9997;
            style.marginTop   = '3px';
            style.padding     = '5px';
            style.whiteSpace  = 'pre';
            style.wordWrap    = 'break-word';
            style.overflowX   = 'hidden';
            style.overflowY   = 'auto';
            style.zoom        = 1;
            me.hr = doc.createElement('hr');
            style = me.hr.style;
            style.position    = 'relative';
            style.width       = '100%';
            style.border      = '1px solid #aaa';
            style.zIndex      = 9998;
            style.zoom        = 1;
            close = doc.createElement('div');
            style = close.style;
            each(defStyle, function(v, k) {
              style[k] = v;
            });
            style.zIndex      = 9999;
            style.fontFamily  = 'sans-serif';
            style.fontWeight  = 'bold';
            style.borderWidth = '1px';
            style.padding     = '1px 4px';
            style.lineHeight  = 1;
            style.right       = '2px';
            style.top         = '2px';
            style.cursor      = 'pointer';
            style.zoom        = 1;
            close.title       = 'close';
            close.appendChild(doc.createTextNode('x'));
            me.histories = [];
            me.historyIndex = 0;
            me.historyLimit = 50;
            me.executer = doc.createElement('input');
            me.executer.type  = 'text';
            style = me.executer.style;
            style.zIndex      = 9999;
            style.position    = 'relative';
            style.display     = 'block';
            style.fontFamily  = 'monospace';
            style.fontSize    = '13px';
            style.padding     = '2px';
            style.marginTop   = '5px';
            style.width       = '95.5%';
            style.border      = '2px solid #999';
            style.zoom        = 1;
            /**@ignore*/
            onResize = function() {
              var width, height, def = '95%';
              width = doc.body.clientWidth - 7;
              wrapper.style.width = (width <= 0) ? def : width + 'px';
              width = wrapper.offsetWidth - 55;
              me.ieConsole.style.width = (width <= 0) ? def : width + 'px';
              height = Math.floor(de.clientHeight / 3.2) + 'px';
              wrapper.style.height = height;
              onScroll();
            };
            /**@ignore*/
            onScroll = function() {
              var pos = de.scrollTop +
                       (de.clientHeight - wrapper.clientHeight) - 7;
              if (pos > 0) {
                wrapper.style.top = pos + 'px';
              }
            };
            /**@ignore*/
            onClick = function() {
              try {
                wrapper.parentNode.removeChild(wrapper);
                window.dettachEvent('onscroll', onScroll);
                window.dettachEvent('onresize', onResize);
                wrapper = me.ieConsole = null;
              } catch (e) {}
            };
            /**@ignore*/
            onKeydown = function(ev) {
              var result, prevCode, nextCode, code = trim(me.executer.value);
              ev = window.event || ev;
              if (ev) {
                if (code && ev.keyCode == 13) { // enter
                  try {
                    result = Pot.localEval(code);
                  } catch (e) {
                    result = Pot.getErrorMessage(e);
                  }
                  Pot.debug(result);
                  if (me.histories.length > me.historyLimit) {
                    me.histories.pop();
                  }
                  me.histories.unshift(code);
                  me.executer.value = '';
                  me.historyIndex = 0;
                } else if (ev.keyCode == 38) { // up
                  prevCode = me.histories[me.historyIndex];
                  me.historyIndex = Math.max(
                    0,
                    Math.min(me.histories.length - 1, me.historyIndex + 1)
                  );
                  if (prevCode) {
                    me.executer.value = prevCode;
                  }
                } else if (ev.keyCode == 40) { // down
                  if (me.historyIndex - 1 < 0) {
                    me.executer.value = '';
                    me.historyIndex = 0;
                  } else {
                    me.historyIndex = Math.max(
                      0,
                      Math.min(me.histories.length - 1, me.historyIndex - 1)
                    );
                    nextCode = me.histories[me.historyIndex];
                    if (nextCode) {
                      me.executer.value = nextCode;
                    }
                  }
                } else {
                  me.historyIndex = 0;
                }
              }
            };
            if (typeof window !== 'undefined' &&
                window && window.attachEvent) {
              if (ie6) {
                each({
                  onscroll : onScroll,
                  onresize : onResize
                }, function(f, k) {
                  window.attachEvent(k, f);
                });
              }
              if (close.attachEvent) {
                close.attachEvent('onclick', onClick);
              }
              if (me.executer.attachEvent) {
                me.executer.attachEvent('onkeydown', onKeydown);
              }
            }
            if (ie6) {
              Deferred.wait(0.25).then(function() {
                wrapper.style.bottom = '1px';
              }).wait(0.5).then(function() {
                wrapper.style.bottom = '0px';
              });
            }
            each([close, me.titlebar,
                  me.ieConsole, me.executer], function(el) {
              wrapper.appendChild(el);
            });
            doc.body.appendChild(wrapper);
            me.append();
          });
        }
      }
    }
  }, {
    /**
     * @ignore
     */
    append : function(msg) {
      var me = this, v, s, stack;
      if (me.ieConsole) {
        try {
          stack = arrayize(me.msgStack || []);
          while (me.msgStack && me.msgStack.length) {
            me.msgStack.pop();
          }
          if (arguments.length) {
            stack.push(msg);
          }
          while (stack.length) {
            v = stack.shift();
            s = debug.dump(v);
            if (isString(v) &&
                s.charAt(0) === '"' && s.slice(-1) === '"') {
              s = s.slice(1, -1);
            }
            each([
              document.createTextNode(s),
              me.hr.cloneNode(false)
            ], function(node) {
              me.ieConsole.appendChild(node);
            });
          }
          PotInternalSetTimeout(function() {
            me.ieConsole.scrollTop = me.ieConsole.scrollHeight;
          }, 10);
        } catch (e) {}
      }
    }
  })
});

// Update Pot object.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Treated as an array of arguments given then
   *  return it as an array.
   *
   *
   * @example
   *   debug(arrayize(null));               // [null]
   *   debug(arrayize((void 0)));           // [undefined]
   *   debug(arrayize(true));               // [true]
   *   debug(arrayize(false));              // [false]
   *   debug(arrayize(new Boolean(true)));  // [Boolean(false)]
   *   debug(arrayize(Boolean));            // [Boolean]
   *   debug(arrayize(''));                 // ['']
   *   debug(arrayize('hoge'));             // ['hoge']
   *   debug(arrayize(new String('hoge'))); // [String {'hoge'}]
   *   debug(arrayize(String));             // [String]
   *   debug(arrayize(100));                // [100]
   *   debug(arrayize(-100));               // [-100]
   *   debug(arrayize(NaN));                // [NaN]
   *   debug(arrayize(12410.505932095032)); // [12410.505932095032]
   *   debug(arrayize(new Number(100)));    // [Number {100}]
   *   debug(arrayize(Number));             // [Number]
   *   debug(arrayize(Error('error')));     // [Error {'error'}]
   *   debug(arrayize(new Error('error'))); // [Error {'error'}]
   *   debug(arrayize(Error));              // [Error]
   *   debug(arrayize(/(foo|bar)/i));       // [/(foo|bar)/i]
   *   debug(arrayize(new RegExp('hoge'))); // [/hoge/]
   *   debug(arrayize(new RegExp()));       // [/(?:)/]
   *   debug(arrayize(RegExp));             // [RegExp]
   *   debug(arrayize(TypeError));          // [TypeError]
   *   debug(arrayize(encodeURI));          // [encodeURI]
   *   debug(arrayize(window));             // [window]
   *   debug(arrayize(document));           // [document]
   *   debug(arrayize(document.body));      // [body]
   *   debug(arrayize([]));                 // []
   *   debug(arrayize(new Array(1, 2, 3))); // [1, 2, 3]
   *   debug(arrayize([1, 2, 3]));          // [1, 2, 3]
   *   debug(arrayize(Array));              // [Array]
   *   debug(arrayize(Array.prototype));    // [Array.prototype]
   *   debug(arrayize([[]]));               // [[]]
   *   debug(arrayize([[100]]));            // [[100]]
   *   debug(arrayize({}));                 // [{}]
   *   debug(arrayize({foo: 'bar'}));       // [{foo: 'bar'}]
   *   debug(arrayize(new Object()));       // [Object {}]
   *   debug(arrayize(new Object('foo')));  // [Object {'foo'}]
   *   debug(arrayize(Object));             // [Object]
   *   debug(arrayize(document.getElementsByTagName('div')));
   *   // @results  [<div/>, <div/>, <div/> ...]
   *   (function(a, b, c) {
   *     debug(arrayize(arguments));
   *     // @results  [1, 2, 3]
   *   })(1, 2, 3);
   *   (function(a, b, c) {
   *     debug(arrayize(arguments, 2));
   *     // @results  [3]
   *   })(1, 2, 3);
   *
   *
   * @param  {*}       object   A target object.
   * @param  {Number}  (index)  Optional, The first index to
   *                              slice the array.
   * @return {Array}            Return an array of result.
   * @type Function
   * @function
   * @public
   * @static
   */
  arrayize : arrayize,
  /**
   * Cast the value to numerical value.
   * All type of object can be convert.
   *
   *
   * @example
   *   debug(numeric(0));               // 0
   *   debug(numeric(1234567890));      // 1234567890
   *   debug(numeric(new Number(25)));  // 25
   *   debug(numeric(null));            // 0
   *   debug(numeric((void 0)));        // 0
   *   debug(numeric(true));            // 1
   *   debug(numeric(false));           // 0
   *   debug(numeric('abc'));           // 2748
   *   debug(numeric('0xFF'));          // 255
   *   debug(numeric('1e8'));           // 100000000
   *   debug(numeric('10px'));          // 10
   *   debug(numeric('1,000,000ms.'));  // 1000000
   *   debug(numeric('-512 +1'));       // -512
   *   debug(numeric([]));              // 0
   *   debug(numeric(['hoge']));        // 1
   *   debug(numeric(new Date()));      // 1323446177282
   *
   *
   * @param  {String|*}   value    The target value to convert numeric value.
   * @param  {Number}   (defaults) The default value if `value` is not numeric.
   * @return {Number}              Return the numeric value.
   * @type Function
   * @function
   * @static
   * @public
   */
  numeric : numeric,
  /**
   * Evaluate a string can be a scalar value only.
   * Return "1" when argument was passed as true.
   * This function can treat XML object that
   *  will be string by toString method.
   *
   *
   * @example
   *   debug(stringify({}));
   *   // @results ''
   *   debug(stringify([]));
   *   // @results ''
   *   debug(stringify(0));
   *   // @results '0'
   *   debug(stringify(-100.02));
   *   // @results '-100.02'
   *   debug(stringify(new Date()));
   *   // @results ''
   *   debug(stringify(null));
   *   // @results ''
   *   debug(stringify(void 0));
   *   // @results ''
   *   debug(stringify(false));
   *   // @results ''
   *   debug(stringify(true));
   *   // @results '1'
   *   debug(stringify(''));
   *   // @results ''
   *   debug(stringify('hoge'));
   *   // @results 'hoge'
   *   debug(stringify(new String('hoge')));
   *   // @results 'hoge'
   *   debug(stringify(new Boolean(false)));
   *   // @results ''
   *   debug(stringify(new Boolean(true)));
   *   // @results '1'
   *   debug(stringify([100]));
   *   // @results ''
   *
   *
   * @param  {*}        x              Any value.
   * @param  {Boolean} (ignoreBoolean) Optional, Ignores Boolean value.
   * @return {String}                  Value as a string.
   * @type Function
   * @function
   * @public
   * @static
   */
  stringify : stringify,
  /**
   * Trim the white spaces including em (U+3000).
   *
   * White spaces will not removed when specified the second argument.
   *
   * @example
   *   debug( trim(' hoge  ') );
   *   // @results 'hoge'
   *
   *
   * @example
   *   //
   *   // White spaces will not removed when 
   *   //  specified the second argument.
   *   //
   *   debug( trim('abbbcc cc ', 'ab') );
   *   // @results 'cc cc '
   *
   *
   * @param  {String}   s            A target string.
   * @param  {String}  (chars)       (Optional) Removing characters.
   * @param  {Boolean} (ignoreCase)  (Optional) Whether ignore case on RegExp.
   * @return {String}                A result string.
   * @type Function
   * @function
   * @public
   * @static
   */
  trim : trim,
  /**
   * Escape RegExp patterns.
   *
   *
   * @example
   *   var pattern = '*[hoge]*';
   *   var regex = new RegExp('^(' + rescape(pattern) + ')$', 'g');
   *   debug(regex.toString());
   *   // @results /^(\*\[hoge\]\*)$/g
   *
   *
   * @param  {String}  s  A target string.
   * @return {String}     The escaped string.
   * @type Function
   * @function
   * @public
   * @static
   */
  rescape : rescape,
  /**
   * Call the function with unknown number arguments.
   * That is for cases where JavaScript sucks
   *   built-in function like alert() on IE or other-browser when
   *   calls the Function.apply.
   *
   *
   * @example
   *   debug(invoke(window, 'alert', 100));
   *   debug(invoke(document, 'getElementById', 'container'));
   *   debug(invoke(window, 'setTimeout', function() { debug(1); }, 2000));
   *
   *
   * @param  {Object}      object  The context object (e.g. window)
   * @param  {String}      method  The callable function name.
   * @param  {Array|...*}  (args)  The function arguments.
   * @return {*}                   The result of the called function.
   * @type Function
   * @function
   * @public
   * @static
   */
  invoke : invoke,
  /**
   * Get the current time as milliseconds.
   *
   *
   * @example
   *   var time = now(); // equals (new Date()).getTime();
   *   debug(time); // e.g. 1323446177282
   *
   *
   * @return {Number} Return the current time as milliseconds.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  now : now,
  /**
   * Output to the console using log function for debug.
   *
   *
   * @example
   *   debug('hoge'); // hoge
   *
   *
   * @param  {*}  msg  A log message, or variable
   * @type Function
   * @function
   * @public
   * @static
   */
  debug : debug,
  /**
   * Output to the console using 'error' function for error logging.
   *
   *
   * @example
   *   Pot.error('Error!'); // Error!
   *
   *
   * @param  {*}  msg  An error message, or variable.
   * @type Function
   * @function
   * @public
   * @static
   */
  error : error
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Private functions.

/**
 * Iterate "forEach".
 *
 * @private
 * @ignore
 * @internal
 */
function each(object, callback, context) {
  var i, len, val, err, p, keys;
  if (object) {
    len = object.length;
    try {
      if (isArrayLike(object)) {
        for (i = 0; i < len; i++) {
          if (i in object) {
            try {
              val = object[i];
            } catch (e) {
              continue;
            }
            callback.call(context, val, i, object);
          }
        }
      } else {
        keys = Pot.keys(object);
        len = keys.length;
        for (i = 0; i < len; i++) {
          p = keys[i];
          try {
            val = object[p];
          } catch (e) {
            continue;
          }
          callback.call(context, val, p, object);
        }
      }
    } catch (ex) {
      err = ex;
      if (!isStopIter(err)) {
        throw err;
      }
    }
  }
  return object;
}

/**
 * Build the serial number.
 *
 * @private
 * @ignore
 */
function buildSerial(o, sep) {
  return [
    String((o && (o.NAME || o.name)) || (void 0)),
    Math.random().toString(36).substring(2),
    now()
  ].join(arguments.length >= 2 ? sep : '-');
}

/**
 * @private
 * @ignore
 */
function buildObjectString(name) {
  return '[object ' + name + ']';
}

/**
 * Method for Deferred.
 *
 * @private
 * @ignore
 */
function extendDeferredOptions(o, x) {
  var a, b;
  if (o && x) {
    if (isObject(o.options)) {
      a = o.options;
    } else if (isObject(o)) {
      a = o;
    }
    if (isObject(x.options)) {
      b = x.options;
    } else if (isObject(x)) {
      b = x;
    }
    if ('async' in b) {
      a.async = !!b.async;
    }
    if ('speed' in b && isNumeric(b.speed)) {
      a.speed = b.speed;
    }
    if ('cancellers' in b) {
      if (!b.cancellers || !b.cancellers.length) {
        b.cancellers = [];
      } else {
        if (a.cancellers && a.cancellers.length) {
          a.cancellers = concat.call([],
            arrayize(a.cancellers), arrayize(b.cancellers));
        } else {
          a.cancellers = arrayize(b.cancellers);
        }
      }
    }
    if ('stoppers' in b) {
      if (!b.stoppers || !b.stoppers.length) {
        b.stoppers = [];
      } else {
        if (a.stoppers && a.stoppers.length) {
          a.stoppers = concat.call([],
            arrayize(a.stoppers), arrayize(b.stoppers));
        } else {
          a.stoppers = arrayize(b.stoppers);
        }
      }
    }
    if ('storage' in b) {
      a.storage = b.storage || {};
    }
    if (!a.storage) {
      a.storage = {};
    }
  }
}

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Deferred.
(function() {

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Deferred.
   *
   * Ability to establish a chain method asynchronously.
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     return 100;
   *   }).then(function(res) {
   *     debug(res);
   *     // @results  res = 100
   *   }).begin();
   *
   *
   * @example
   *   var n = 1;
   *   var d = new Pot.Deferred({
   *     async : true,
   *     speed : 'slow'
   *   });
   *   d.then(function() {
   *     debug('Begin');
   *     debug(n);
   *     return n + 1;
   *   }).then(function(res) {
   *     debug(res);
   *     return res + 1;
   *   }).then(function(res) {
   *     debug(res);
   *     // raise an error
   *     undefinedFunction.call();
   *   }).rescue(function(err) {
   *     // catch the error
   *     debug('my error : ' + err);
   *   }).then(function() {
   *     debug('End.');
   *   }).begin();
   *
   *
   * @param  {Object|*}  Options.
   * @return {Deferred}  Returns an instance of Deferred.
   *
   * @name  Pot.Deferred
   * @class
   * @constructor
   * @public
   */
  Deferred : function() {
    return isDeferred(this) ? this.init(arguments)
                            : new Deferred.fn.init(arguments);
  }
});

// Refer the Pot properties/functions.
Deferred = Pot.Deferred;

// Definition of the prototype and static properties.
update(Deferred, {
  /**
   * @lends Pot.Deferred
   */
  /**
   * StopIteration.
   *
   * @type Object
   * @static
   * @const
   * @public
   */
  StopIteration : PotStopIteration,
  /**
   * Speeds.
   *
   * @type Object
   * @static
   * @const
   * @private
   * @ignore
   */
  speeds : {
    limp   : 2400,
    doze   : 1000,
    slow   :  100,
    normal :   36,
    fast   :   20,
    rapid  :   12,
    ninja  :    0
  },
  /**
   * States.
   *
   * @type Object
   * @static
   * @const
   * @private
   * @ignore
   */
  states : {
    success : 0x01,
    failure : 0x02,
    fired   : 0x03,
    unfired : 0x04
  }
});

each(Deferred.states, function(n, name) {
  Deferred.states[n] = name;
});

update(Deferred, {
  /**
   * @lends Pot.Deferred
   */
  /**
   * Defaults.
   *
   * @type Object
   * @static
   * @const
   * @private
   * @ignore
   */
  defaults : {
    speed     : Deferred.speeds.ninja,
    canceller : null,
    stopper   : null,
    async     : true
  }
});

// Definition of the prototype.
Deferred.fn = Deferred.prototype = update(Deferred.prototype, {
  /**
   * @lends Pot.Deferred.prototype
   */
  /**
   * @ignore
   */
  constructor : Deferred,
  /**
   * @private
   * @ignore
   */
  id : PotInternal.getMagicNumber(),
  /**
   * A unique strings.
   *
   * @type  String
   * @const
   */
  serial : null,
  /**
   * @private
   * @ignore
   */
  chains : [],
  /**
   * @private
   * @ignore
   */
  chained : false,
  /**
   * @private
   * @ignore
   */
  cancelled : false,
  /**
   * @private
   * @ignore
   */
  freezing : false,
  /**
   * @private
   * @ignore
   */
  tilling : false,
  /**
   * @private
   * @ignore
   */
  waiting : false,
  /**
   * @private
   * @ignore
   */
  nested : 0,
  /**
   * @private
   * @ignore
   */
  state : null,
  /**
   * @private
   * @ignore
   */
  results : null,
  /**
   * @private
   * @ignore
   */
  destAssign : false,
  /**
   * @private
   * @ignore
   */
  chainDebris : null,
  /**
   * @private
   * @ignore
   */
  options : {},
  /**
   * @private
   * @ignore
   */
  plugins : {},
  /**
   * @private
   * @ignore
   * @const
   */
  NAME : 'Deferred',
  /**
   * toString.
   *
   * @return  Return formatted string of object.
   * @type Function
   * @function
   * @static
   * @public
   */
  toString : PotToString,
  /**
   * isDeferred.
   *
   * @type Function
   * @function
   * @static
   * @public
   */
  isDeferred : isDeferred,
  /**
   * Initialize properties
   *
   * @private
   * @ignore
   */
  init : function(args) {
    if (!this.serial) {
      this.serial = buildSerial(this);
    }
    this.options = {};
    this.plugins = {};
    initOptions.call(this, arrayize(args), Deferred.defaults);
    update(this, {
      results     : {
        success   : null,
        failure   : null
      },
      state       : Deferred.states.unfired,
      chains      : [],
      nested      : 0,
      chained     : false,
      cancelled   : false,
      freezing    : false,
      tilling     : false,
      waiting     : false,
      destAssign  : false,
      chainDebris : null
    });
    PotInternal.referSpeeds.call(this, Deferred.speeds);
    return this;
  },
  /**
   * @lends Pot.Deferred.prototype
   */
  /**
   * Set the speed for processing.
   *
   * @desc
   * <pre>
   * The available constant speed names are below.
   * ------------------------------------
   *   speed name    |  speed
   * ------------------------------------
   *      limp       :  slowest
   *      doze       :  slower
   *      slow       :  slow
   *      normal     :  normal
   *      fast       :  fast
   *      rapid      :  faster
   *      ninja      :  fastest
   * ------------------------------------
   * </pre>
   *
   *
   * @example
   *   var n = 0;
   *   var testFunc = function() { debug(++n); };
   *   var d = new Pot.Deferred();
   *   d.then(testFunc).then(testFunc).then(testFunc)
   *    .then(function() { debug('Change to slowest speed. (limp)'); })
   *    .speed('limp')
   *    .then(testFunc).then(testFunc).then(testFunc)
   *    .then(function() { debug('Change to speed for 50 ms.'); })
   *    .speed(50)
   *    .then(testFunc).then(testFunc).then(testFunc)
   *    .then(function() { debug('End'); })
   *    .begin();
   *
   *
   * @param  {Number|String} sp Speed as Number or keyword as String.
   * @return {Deferred}         Returns the Deferred.
   *                            Deferred callback argument value will be
   *                              current speed value if no argument was
   *                              given, otherwise argument will succeed
   *                              the previous value.
   * @type Function
   * @function
   * @public
   */
  speed : function(sp) {
    var that = this, args = arguments, value;
    if (isNumeric(sp)) {
      value = sp - 0;
    } else if (isNumeric(Deferred.speeds[sp])) {
      value = Deferred.speeds[sp] - 0;
    } else {
      value = this.options.speed;
    }
    if (this.state === Deferred.states.unfired && !this.chains.length) {
      if (args.length === 0) {
        return this.options.speed;
      }
      this.options.speed = value;
    } else {
      this.then(function(reply) {
        if (args.length === 0) {
          return that.options.speed;
        }
        that.options.speed = value;
        return reply;
      });
    }
    return this;
  },
  /**
   * Set the asynchronous for processing.
   *
   *
   * @example
   *   // Run the callback chains while switching between
   *   //  asynchronous and synchronous.
   *   var d = new Pot.Deferred({ async : false });
   *   d.then(function(res) {
   *     debug(res);
   *     return res + 1;
   *   }).speed('slow').async(true).then(function(res) {
   *     debug(res);
   *     return res + 1;
   *   }).speed(1500).then(function(res) {
   *     debug(res);
   *     return res + 1;
   *   }).async(false).then(function(res) {
   *     debug(res);
   *     return res + 1;
   *   }).then(function(res) {
   *     debug(res);
   *   }).async().then(function(async) {
   *     // Get the current async value
   *     debug('async = ' + async);
   *     debug('End.');
   *   }).begin(1);
   *
   *
   * @param  {Boolean}    sync  Value to asynchronous if given true.
   * @return {Deferred}         Returns the Deferred.
   *                            Deferred callback argument value will be
   *                              current async value if no argument was
   *                              given, otherwise argument will succeed
   *                              the previous value.
   * @type Function
   * @function
   * @public
   */
  async : function(sync) {
    var that = this, args = arguments;
    if (this.state === Deferred.states.unfired && !this.chains.length) {
      if (args.length === 0) {
        return this.options.async;
      }
      this.options.async = !!sync;
    } else {
      this.then(function(reply) {
        if (args.length === 0) {
          return that.options.async;
        }
        that.options.async = !!sync;
        return reply;
      });
    }
    return this;
  },
  /**
   * Set the canceller that will call on canceled callback sequences.
   *
   *
   * @example
   *   var msg = 'none';
   *   var d = new Pot.Deferred();
   *   d.canceller(function() {
   *     msg = 'cancelled';
   *   }).then(function() {
   *     msg = 'hoge';
   *   }).then(function() {
   *     msg = 'fuga';
   *   });
   *   d.cancel();
   *   d.begin(); // no sense
   *   debug(msg);
   *   // @results  msg = 'cancelled'
   *
   *
   * @param  {Function}   func  A canceller function.
   * @return {Deferred|*}       Returns the Deferred if set canceller value.
   *                            Returns current value if no argument was given.
   * @type Function
   * @function
   * @public
   */
  canceller : function(func) {
    var args = arguments;
    if (this.state === Deferred.states.unfired && !this.chains.length) {
      if (args.length === 0) {
        return this.options.cancellers;
      }
      if (!this.cancelled && isFunction(func)) {
        this.options.cancellers.push(func);
      }
    } else {
      this.stopper.apply(this, args);
    }
    return this;
  },
  /**
   * Set the stopper that will call on canceled callback sequences.
   *
   * @param  {Function}   func  A stopper function.
   * @return {Deferred}         Returns the Deferred.
   *                            Deferred callback argument value will be
   *                              current stoppers if no argument was
   *                              given, otherwise argument will succeed
   *                              the previous value.
   * @type Function
   * @function
   * @public
   */
  stopper : function(func) {
    var that = this, args = arguments;
    if (this.state === Deferred.states.unfired && !this.chains.length) {
      this.canceller.apply(this, args);
    } else {
      this.then(function(reply) {
        if (args.length === 0) {
          return that.options.stoppers;
        }
        if (!that.cancelled && isFunction(func)) {
          that.options.stoppers.push(func);
        }
        return reply;
      });
    }
    return this;
  },
  /**
   * Add a callback to the end of the chains.
   *
   * @desc
   * callback/errback:
   *   If callback returns a Deferred, then it will be chained.
   *   Returned value will be passed to the next callback as argument.
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     debug('Hello World!');
   *   }).begin();
   *
   *
   * @param  {Function}  callback   A callback function.
   * @param  {Function}  (errback)  Optionally, an errorback function.
   * @return {Deferred}             Returns the Deferred.
   * @type Function
   * @function
   * @public
   */
  then : function(callback, errback) {
    if (!this.chained && !this.cancelled) {
      this.chains.push({
        success : callback,
        failure : errback
      });
      if (this.state & Deferred.states.fired) {
        if (!this.freezing && !this.tilling && !this.waiting) {
          fire.call(this);
        }
      }
    }
    PotInternal.referSpeeds.call(this, Deferred.speeds);
    return this;
  },
  /**
   * Add an errorback function to the end of the chains.
   * Errorback will be catch the error which occurs on chains.
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     // Occur an error.
   *     unknownFunc.call();
   *   }).rescue(function(err) {
   *     // catch the error
   *     debug('err = ' + err);
   *     //
   *     // Handling the error.
   *     //
   *   }).then(function() {
   *     debug('next(do something)');
   *   });
   *   d.begin();
   *
   *
   * @param  {Function}  errback  An errorback function.
   * @return {Deferred}           Returns the Deferred.
   * @type Function
   * @function
   * @public
   */
  rescue : function(errback) {
    return this.then(null, errback);
  },
  /**
   * Add the same function as both a callback and an errorback on the chains.
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     // Occur an error, or succeed.
   *     return maybeCallableFunc.call();
   *   }).ensure(function(res) {
   *     if (Pot.isError(res)) {
   *       debug('Error = ' + res);
   *       // Handling the error.
   *     } else {
   *       debug('Result = ' + res);
   *       // something to do
   *     }
   *     return 'anything';
   *   }).then(function(res) {
   *     debug('next(do something) or ' + res);
   *   });
   *   d.begin();
   *
   *
   * @param  {Function}  callback  A callback/errorback function.
   * @return {Deferred}            Returns the Deferred.
   * @type Function
   * @function
   * @public
   */
  ensure : function(callback) {
    return this.then(callback, callback);
  },
  /**
   * Cancels the chains that has not yet received a value.
   *
   *
   * @example
   *   function exampleFunc(checkFunc) {
   *     var d = new Pot.Deferred();
   *     d.canceller(function() {
   *       debug('Cancelled');
   *     });
   *     d.then(function(res) {
   *       debug(res);
   *       return res + 1;
   *     }).then(function(res) {
   *       debug(res);
   *       return res + 1;
   *     }).then(function(res) {
   *       debug(res);
   *       return res + 1;
   *     }).then(function(res) {
   *       debug(res);
   *       return res + 1;
   *     });
   *     return checkFunc().then(function(res) {
   *       debug('res = ' + res);
   *       if (res) {
   *         d.begin(1);
   *       } else {
   *         d.cancel();
   *       }
   *       return d;
   *     }).begin();
   *   }
   *   var checkFunc = function() {
   *     var dd = new Pot.Deferred();
   *     return dd.then(function() {
   *       debug('Begin example');
   *     }).async(true).speed(1000).then(function() {
   *       return Math.random() * 10 <= 5; // true or false
   *     });
   *   };
   *   exampleFunc(checkFunc).then(function(res) {
   *     debug('exampleFunc : res = ' + res);
   *   });
   *
   *
   * @return  {Deferred}        Returns the Deferred.
   * @type Function
   * @function
   * @public
   */
  cancel : function() {
    if (!this.cancelled) {
      this.cancelled = true;
      switch (this.state) {
        case Deferred.states.unfired:
            cancelize.call(this, 'cancellers');
            if (this.state === Deferred.states.unfired) {
              this.raise(new Error(this));
            }
            break;
        case Deferred.states.success:
            cancelize.call(this, 'stoppers');
            if (isDeferred(this.results.success)) {
              this.results.success.cancel();
            }
            break;
        case Deferred.states.failure:
            cancelize.call(this, 'stoppers');
      }
    }
    return this;
  },
  /**
   * Begin the callback chains without Error.
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     debug('Hello Deferred!');
   *   });
   *   d.begin();
   *
   *
   * @param  {...*}      (...)  Some value to pass next callback sequence.
   * @return {Deferred}         Returns the Deferred.
   * @type Function
   * @function
   * @public
   */
  begin : function(/*[ ...args]*/) {
    var that = this, arg, args = arrayize(arguments), value;
    arg = args[0];
    if (args.length > 1) {
      value = args;
    } else {
      value = args[0];
    }
    if (!this.cancelled && this.state === Deferred.states.unfired) {
      if (isDeferred(arg) && !arg.cancelled) {
        arg.ensure(function() {
          that.begin.apply(this, arguments);
        });
      } else {
        this.options.cancellers = [];
        post.call(this, value);
      }
    }
    PotInternal.referSpeeds.call(this, Deferred.speeds);
    return this;
  },
  /**
   * Begin the callback chains with Error.
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     debug('Hello Deferred!?');
   *   }).rescue(function() {
   *     debug('Error Deferred!');
   *   });
   *   d.raise();
   *   // This will be output 'Error Deferred!'
   *
   *
   * @param  {...*}      (...)  Some value to pass next callback sequence.
   * @return {Deferred}         Returns the Deferred.
   * @type Function
   * @function
   * @public
   */
  raise : function(/*[ ...args]*/) {
    var args = arrayize(arguments), arg, value;
    arg = args[0];
    if (!isError(arg)) {
      args[0] = new Error(arg);
    }
    if (args.length > 1) {
      value = args;
    } else {
      value = args[0];
    }
    return this.begin.apply(this, arrayize(value));
  },
  /**
   * Ending the callback chains.
   *
   *
   * @example
   *   var n = 1;
   *   var d = Pot.Deferred.begin(function() {
   *     n += 1;
   *   });
   *   d.then(function() {
   *     n *= 10;
   *   }).then(function() {
   *     n += 5;
   *     debug('n = ' + n);
   *   }).end(); // End the chains.
   *   d.then(function() {
   *     // This chain will not be called.
   *     n += 10000;
   *     debug('n = ' + n);
   *   });
   *   // @results  n = 25
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   var result;
   *   d.then(function() {
   *     return 1;
   *   }).then(function(res) {
   *     return res + 1;
   *   }).then(function(res) {
   *     var dd = new Pot.Deferred();
   *     dd.then(function(res) {
   *       return res + 1;
   *     }).then(function(res) {
   *       return res + 1;
   *     }).begin(res + 1);
   *     return dd;
   *   }).then(function(res) {
   *     result = res;
   *     debug(result);
   *   }).begin().end().then(function() {
   *     result = 100;
   *     debug('This chain will not be called.');
   *   });
   *   // @results  result = 5
   *
   *
   * @return {Deferred}      Returns the Deferred.
   * @type Function
   * @function
   * @public
   */
  end : function() {
    this.chained = true;
    return this;
  },
  /**
   * Wait specified seconds and then the callback sequence will restart.
   *
   *
   * @example
   *   var n = 0;
   *   var f = function() { debug(++n); };
   *   var d = new Pot.Deferred();
   *   d.then(f).then(f).then(f)
   *    .wait(1) // Wait 1 second.
   *    .then(f).wait(1).then(f).wait(1).then(f)
   *    .wait(2) // Wait 2 seconds.
   *    .then(f).wait(2).then(f).wait(2).then(f)
   *    .wait(0.5) // Wait 0.5 second.
   *    .then(function() {
   *      f();
   *      return 'hoge';
   *    }).wait(1).then(function(res) {
   *      f();
   *      // Inherit previous value.
   *      // This will be 'hoge'.
   *      debug('res = ' + res);
   *      return Pot.Deferred.begin(function() {
   *        return '[End]';
   *      });
   *    }).wait(2.5).then(function(res) {
   *      f();
   *      debug(res); // '[End]'
   *    });
   *    d.begin();
   *
   *
   * @param  {Number}  seconds  Number of seconds.
   * @param  {*}       (value)  (optional) The value passed to the next chain.
   * @return {Deferred}         Return the Deferred.
   * @type Function
   * @function
   * @public
   */
  wait : function(seconds, value) {
    var d = new Deferred(), that = this, args = arguments;
    return this.then(function(reply) {
      if (isError(reply)) {
        throw reply;
      }
      that.waiting = true;
      Deferred.wait(seconds).ensure(function(result) {
        that.waiting = false;
        if (isError(result)) {
          d.raise(result);
        } else {
          d.begin(args.length >= 2 ? value : reply);
        }
      });
      return d;
    });
  },
  /**
   * Wait until the condition completed.
   * If true returned, waiting state will end.
   *
   *
   * @example
   *   debug('Begin till');
   *   var d = new Pot.Deferred();
   *   d.till(function() {
   *     // wait until the DOM body element is loaded
   *     if (!document.body) {
   *       return false;
   *     } else {
   *       return true;
   *     }
   *   }).then(function() {
   *     debug('End till');
   *     document.body.innerHTML += 'hoge';
   *   }).begin();
   *
   *
   * @param  {Function|*}  cond  A function or value as condition.
   * @return {Deferred}          Return the Deferred.
   * @type Function
   * @function
   * @public
   */
  till : function(cond) {
    var that = this, d = new Deferred();
    return this.then(function(reply) {
      if (isError(reply)) {
        throw reply;
      }
      that.tilling = true;
      Deferred.till(cond, reply).ensure(function(result) {
        that.tilling = false;
        if (isError(result)) {
          d.raise(result);
        } else {
          d.begin(reply);
        }
      });
      return d;
    });
  },
  /**
   * Set the arguments into the callback chain.
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function(res) {
   *     debug(res); // undefined
   *     // Set the argument into callback chain result.
   *   }).args('hoge').then(function(res) {
   *     debug(res);
   *     // @results  res = 'hoge'
   *   });
   *   d.begin();
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function(res) {
   *     debug(res); // undefined
   *     // Set the argument into callback chain result.
   *   }).args({
   *     foo : 1,
   *     bar : 2,
   *     baz : 3
   *   }).then(function(res) {
   *     debug(res);
   *     // @results  res = {foo: 1, bar: 2, baz: 3}
   *   });
   *   d.begin();
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     return 'hoge';
   *   }).then(function() {
   *     debug( d.args() ); // @results 'hoge'
   *   });
   *   d.begin();
   *
   *
   * @param  {...*}         (args)  The specific arguments.
   * @return {Deferred|*}           Return the Pot.Deferred.
   *                                  Return the last callback chain result
   *                                  if passed no arguments.
   * @type   Function
   * @function
   * @public
   */
  args : function(/*[... args]*/) {
    var a = arrayize(arguments), len = a.length;
    if (len === 0) {
      return Deferred.lastResult(this);
    } else {
      return this.then(function() {
        var reply, reps = arrayize(arguments);
        if (reps.length > 1) {
          reply = reps;
        } else {
          reply = reps[0];
        }
        if (len > 1) {
          return a;
        } else {
          if (isFunction(a[0])) {
            return a[0].apply(this, arrayize(reply));
          } else {
            return a[0];
          }
        }
      });
    }
  },
  /**
   * Handle the data storage in the current callback chain.
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.data({
   *     // Set the data to callback chain.
   *     count : 0,
   *     begin : 'BEGIN',
   *     end   : 'END'
   *   }).then(function() {
   *     debug( this.data('begin') );
   *     return this.data('count') + 1;
   *   }).then(function(res) {
   *     debug(res);
   *     this.data('count', res + 1);
   *     return this.data('count');
   *   }).then(function(res) {
   *     debug(res);
   *     debug( this.data('end') );
   *   });
   *   d.begin();
   *   // output:
   *   //
   *   //   BEGIN
   *   //   1
   *   //   2
   *   //   END
   *   //
   *
   *
   * @param  {String|Object|*}  (key/obj)  The key name to get the data.
   *                                         Or, an key-value object for
   *                                         set the data.
   * @param  {*}                (value)    The value to set.
   * @return {Deferred|*}                  Return the current instance of
   *                                         Pot.Deferred if set the data.
   *                                       Return the value if specify key
   *                                         to get.
   * @type   Function
   * @function
   * @public
   */
  data : function(/*[key/obj [, value [, ...args]]]*/) {
    var that = this, result = this, args = arrayize(arguments),
        i, len = args.length, prefix = '.';
    if (this.options) {
      if (!this.options.storage) {
        this.options.storage = {};
      }
      switch (len) {
        case 0:
            result = {};
            each(this.options.storage, function(val, key) {
              try {
                if (key && key.charAt(0) === prefix) {
                  result[key.substring(1)] = val;
                }
              } catch (e) {}
            });
            break;
        case 1:
            if (args[0] == null) {
              this.options.storage = {};
            } else if (isObject(args[0])) {
              each(args[0], function(val, key) {
                that.options.storage[prefix + stringify(key)] = val;
              });
            } else {
              result = this.options.storage[prefix + stringify(args[0])];
            }
            break;
        case 2:
            this.options.storage[prefix + stringify(args[0])] = args[1];
            break;
        default:
            i = 0;
            do {
              this.options.storage[prefix + stringify(args[i++])] = args[i++];
            } while (i < len);
      }
    }
    return result;
  },
  /**
   * Update the Pot.Deferred.prototype.
   *
   *
   * @example
   *   // Update Pot.Deferred.prototype.
   *   Pot.Deferred.fn.update({
   *     addHoge : function() {
   *       return this.then(function(res) {
   *         return res + 'hoge';
   *       });
   *     }
   *   });
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     return 'fuga';
   *   }).addHoge().then(function(res) {
   *     debug(res);
   *     // @results  res = 'fugahoge';
   *   });
   *   d.begin();
   *
   *
   * @param  {Object}    (...)  The object to update.
   * @return {Deferred}         Return the current instance.
   * @type   Function
   * @function
   * @public
   * @static
   */
  update : function() {
    var that = Deferred.fn, args = arrayize(arguments);
    args.unshift(that);
    update.apply(that, args);
    return this;
  }
});

Deferred.fn.init.prototype = Deferred.fn;
//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Private methods for Deferred
/**
 * @lends Pot.Deferred
 */
/**
 * Set the current state.
 *
 * @private
 * @ignore
 */
function setState(value) {
  if (isError(value)) {
    this.state = Deferred.states.failure;
  } else {
    this.state = Deferred.states.success;
  }
  return this.state;
}

/**
 * Post the state and fire the chains.
 *
 * @private
 * @ignore
 */
function post(value) {
  setState.call(this, value);
  this.results[Deferred.states[this.state]] = value;
  if (!this.freezing && !this.tilling && !this.waiting) {
    fire.call(this);
  }
}

/**
 * Fire the callback sequence chains.
 *
 * @private
 * @ignore
 */
function fire(force) {
  if (force || (!this.freezing && !this.tilling && !this.waiting)) {
    if (this.options && this.options.async) {
      fireAsync.call(this);
    } else {
      fireSync.call(this);
    }
  }
}

/**
 * Fire the callback sequence chains by asynchronous.
 *
 * @private
 * @ignore
 */
function fireAsync() {
  var that = this, speed, callback;
  if (this.options && isNumeric(this.options.speed)) {
    speed = this.options.speed;
  } else {
    speed = Deferred.defaults.speed;
  }
  this.freezing = true;
  /**@ignore*/
  callback = function() {
    try {
      fireProcedure.call(that);
    } catch (e) {
      that.freezing = false;
      throw e;
    }
    if (chainsEnabled.call(that)) {
      fire.call(that, true);
    } else {
      that.freezing = false;
    }
  };
  if (!speed && this.state === Deferred.states.unfired) {
    PotInternalCallInBackground.flush(callback);
  } else {
    PotInternalSetTimeout(callback, speed);
  }
}

/**
 * Fire the callback sequence chains by synchronous.
 *
 * @private
 * @ignore
 */
function fireSync() {
  fireProcedure.call(this);
  if (this.options && this.options.async) {
    fire.call(this);
  }
}

/**
 * Fire the callback sequence chains.
 *
 * @private
 * @ignore
 */
function fireProcedure() {
  var that = this, result, reply, callbacks, callback, nesting = null, isStop;
  clearChainDebris.call(this);
  result = this.results[Deferred.states[this.state]];
  while (chainsEnabled.call(this)) {
    callbacks = this.chains.shift();
    callback = callbacks && callbacks[Deferred.states[this.state]];
    if (!isFunction(callback)) {
      continue;
    }
    isStop = false;
    try {
      if (this.destAssign ||
          (isNumber(callback.length) && callback.length > 1 &&
           isArray(result) && result.length === callback.length)) {
        reply = callback.apply(this, result);
      } else {
        reply = callback.call(this, result);
      }
      // We ignore undefined result when "return" statement is not exists.
      if (reply === void 0 &&
          this.state !== Deferred.states.failure &&
          !isError(result) && !Pot.hasReturn(callback)) {
        reply = result;
      }
      result = reply;
      if (isWorkeroid(result)) {
        result = workerMessaging.call(this, result);
      } else if (Pot.isFileReader(result)) {
        result = readerPolling.call(this, result);
      } else if (Pot.isImage(result)) {
        result = imagePolling.call(this, result);
      }
      this.destAssign = false;
      this.state = setState.call({}, result);
      if (isDeferred(result)) {
        /**@ignore*/
        nesting = function(result) {
          return bush.call(that, result);
        };
        this.nested++;
      }
    } catch (e) {
      result = e;
      if (isStopIter(result)) {
        isStop = true;
      } else {
        setChainDebris.call(this, result);
      }
      this.destAssign = false;
      this.state = Deferred.states.failure;
      if (!isError(result)) {
        result = new Error(result);
        if (isStop) {
          update(result, {
            StopIteration : PotStopIteration
          });
        }
      }
    }
    if (this.options && this.options.async) {
      break;
    }
  }
  this.results[Deferred.states[this.state]] = result;
  if (nesting && this.nested) {
    result.ensure(nesting).end();
  }
  reserveChainDebris.call(this);
}

/**
 * Valid chains.
 *
 * @private
 * @ignore
 */
function chainsEnabled() {
  return this.chains  && this.chains.length &&
    this.nested === 0 && !this.cancelled;
}

/**
 * Check whether the errback is exists.
 *
 * @private
 * @ignore
 */
function hasErrback() {
  var exists, i, len, key, chains, errback;
  key = Deferred.states[Deferred.states.failure];
  chains = this.chains;
  len = chains && chains.length;
  if (len) {
    for (i = 0; i < len; i++) {
      if (chains[i]) {
        errback = chains[i][key];
        if (errback && isFunction(errback)) {
          exists = true;
          break;
        }
      }
    }
  }
  return exists;
}

/**
 * Set the chains debris (i.e., unhandled exception).
 *
 * @private
 * @ignore
 */
function setChainDebris(result) {
  if (!hasErrback.call(this)) {
    this.chainDebris = {
      error : result
    };
  }
}

/**
 * Reserved to handle the chains debris.
 *
 * @private
 * @ignore
 */
function reserveChainDebris() {
  var that = this, speed;
  if (this.chainDebris && 'error' in this.chainDebris &&
      (this.cancelled || this.chained ||
        (!this.chains || !this.chains.length))
  ) {
    if (this.options && isNumeric(this.options.speed)) {
      speed = this.options.speed;
    } else {
      speed = Deferred.defaults.speed;
    }
    this.chainDebris.timerId = PotInternalSetTimeout(function() {
      throw that.chainDebris.error;
    }, speed);
  }
}

/**
 * Clear the chains debris handler.
 *
 * @private
 * @ignore
 */
function clearChainDebris() {
  if (this.chainDebris && this.chainDebris.timerId != null &&
      (this.state & Deferred.states.fired) && hasErrback.call(this)) {
    PotInternalClearTimeout(this.chainDebris.timerId);
    delete this.chainDebris.error;
    delete this.chainDebris.timerId;
    this.chainDebris = null;
  }
}

/**
 * Processing the child Deferred objects.
 *
 * @private
 * @ignore
 */
function bush(result) {
  post.call(this, result);
  this.nested--;
  if (this.nested === 0 && !this.cancelled &&
      (this.state & Deferred.states.fired)) {
    fire.call(this);
  }
}

/**
 * Messaging for Pot.Workeroid.
 *
 * @private
 * @ignore
 */
function workerMessaging(worker) {
  var result, async = false;
  if (this.options && this.options.async) {
    async = true;
  }
  result = new Deferred({async : async});
  return result.then(function() {
    var defer = new Deferred({async : async}), count = 0;
    if (worker && worker.workers) {
      each(worker.workers, function(w, k) {
        if (w && k && k.charAt && k.charAt(0) === '.') {
          /**@ignore*/
          w.callback = function(data) {
            count--;
            if (count === 0) {
              defer.begin(data);
            }
          };
          count++;
        }
      });
      if (count === 0) {
        defer.begin();
      }
    } else {
      defer.begin();
    }
    return defer;
  }).begin();
}

/**
 * Observe FileReader state.
 *
 * @private
 * @ignore
 */
function readerPolling(reader) {
  var d, done, async = false,
      orgLoad = reader.onload,
      orgLoadEnd = reader.onloadend,
      orgError = reader.onerror;
  if (this.options && this.options.async) {
    async = true;
  }
  d = new Deferred({async : async});
  if (reader.readyState === FileReader.LOADING) {
    /**@ignore*/
    reader.onload = function(ev) {
      if (!done) {
        done = true;
        d.begin(ev && ev.target && ev.target.result);
      }
      if (isFunction(orgLoad)) {
        if (orgLoad.apply) {
          orgLoad.apply(this, arguments);
        } else {
          orgLoad(ev);
        }
      }
    };
    /**@ignore*/
    reader.onloadend = function(ev) {
      if (!done) {
        done = true;
        d.begin(ev && ev.target && ev.target.result);
      }
      if (isFunction(orgLoadEnd)) {
        if (orgLoadEnd.apply) {
          orgLoadEnd.apply(this, arguments);
        } else {
          orgLoadEnd(ev);
        }
      }
    };
    /**@ignore*/
    reader.onerror = function(e) {
      if (!done) {
        done = true;
        d.raise(e);
      }
      if (isFunction(orgError)) {
        if (orgError.apply) {
          orgError.apply(this, arguments);
        } else {
          orgError(e);
        }
      }
    };
  } else {
    d.begin(reader.result);
  }
  return d;
}

/**
 * Observe Image state.
 *
 * @private
 * @ignore
 */
function imagePolling(image) {
  var d, done,
      async = false,
      orgLoad = image.onload,
      orgError = image.onerror,
      /**@ignore*/
      isZero = function(img) {
        return (('naturalWidth' in img &&
                !(img.naturalWidth + img.naturalHeight)) ||
                !(img.width + img.height));
      };
  if (this.options && this.options.async) {
    async = true;
  }
  d = new Deferred({async : async});
  if (!isZero(image)) {
    d.begin(image);
  } else {
    /**@ignore*/
    image.onload = function(ev) {
      if (!done) {
        done = true;
        if (isZero(this)) {
          return this.onerror(new Error(this.src));
        }
        d.begin(this);
      }
      if (isFunction(orgLoad)) {
        if (orgLoad.apply) {
          orgLoad.apply(this, arguments);
        } else {
          orgLoad(ev);
        }
      }
    };
    /**@ignore*/
    image.onerror = function(e) {
      if (!done) {
        done = true;
        d.raise(e);
      }
      if (isFunction(orgError)) {
        if (orgError.apply) {
          orgError.apply(this, arguments);
        } else {
          orgError(e);
        }
      }
    };
  }
  return d;
}

/**
 * Parse the arguments of initialization method.
 *
 * @private
 * @ignore
 */
function initOptions(args, defaults) {
  var opts, speed, canceller, stopper, async, nop;
  if (args) {
    if (args.length === 1 && args[0] && isObject(args[0])) {
      opts = args[0];
      if (opts.speed !== nop || opts.canceller !== nop ||
          opts.async !== nop || opts.stopper   !== nop
      ) {
        speed     = opts.speed;
        canceller = opts.canceller;
        stopper   = opts.stopper;
        async     = opts.async;
      } else {
        speed     = opts.options && opts.options.speed;
        canceller = opts.options && opts.options.canceller;
        stopper   = opts.options && opts.options.stopper;
        async     = opts.options && opts.options.async;
      }
    } else {
      if (args.length === 1 && args[0] && isArray(args[0])) {
        opts = args[0];
      } else {
        opts = args;
      }
      each(opts || [], function(opt) {
        if (speed === nop && isNumeric(opt)) {
          speed = opt;
        } else if (speed === nop &&
                   isNumeric(Deferred.speeds[opt])) {
          speed = Deferred.speeds[opt];
        } else if (canceller === nop && isFunction(opt)) {
          canceller = opt;
        } else if (async === nop && isBoolean(opt)) {
          async = opt;
        } else if (stopper === nop &&
                 canceller === nop && isFunction(opt)) {
          stopper = opt;
        }
      });
    }
  }
  this.options = this.options || {};
  this.options.storage = this.options.storage || {};
  if (!isArray(this.options.cancellers)) {
    this.options.cancellers = [];
  }
  if (!isArray(this.options.stoppers)) {
    this.options.stoppers = [];
  }
  if (!isNumeric(speed)) {
    if (this.options.speed !== nop && isNumeric(this.options.speed)) {
      speed = this.options.speed - 0;
    } else {
      speed = defaults.speed;
    }
  }
  if (!isFunction(canceller)) {
    canceller = defaults.canceller;
  }
  if (!isFunction(stopper)) {
    stopper = defaults.stopper;
  }
  if (!isBoolean(async)) {
    if (this.options.async !== nop && isBoolean(this.options.async)) {
      async = this.options.async;
    } else {
      async = defaults.async;
    }
  }
  update(this.options, {
    speed : speed - 0,
    async : async
  });
  if (isFunction(canceller)) {
    this.options.cancellers.push(canceller);
  }
  if (isFunction(stopper)) {
    this.options.stoppers.push(stopper);
  }
  return this;
}

/**
 * Cancel the chains.
 *
 * @private
 * @ignore
 */
function cancelize(type) {
  var func;
  while (this.options[type] && this.options[type].length) {
    func = this.options[type].shift();
    if (isFunction(func)) {
      func.call(this);
    }
  }
}

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Create each speeds constructors (optional)

update(Deferred, {
  /**
   * @lends Pot.Deferred
   */
  /**
   * Extends object with speeds.
   *
   * @type Function
   * @function
   * @private
   * @ignore
   */
  extendSpeeds : function(target, name, construct, speeds) {
    /**@ignore*/
    var create = function(speedName, speed) {
      /**@ignore*/
      var func = function() {
        var opts = {}, args = arguments, me = func;
        args = arrayize(args);
        initOptions.call(opts, args, {
          speed     : speed,
          canceller : Deferred.defaults.canceller,
          stopper   : Deferred.defaults.stopper,
          async     : Deferred.defaults.async
        });
        opts.speedName = speedName;
        args.unshift(opts);
        return construct.apply(me.instance, args);
      };
      return func;
    },
    methods = {};
    each(speeds, function(val, key) {
      methods[key] = create(key, val);
    });
    return update(target[name], methods);
  }
});

update(PotInternal, {
  /**
   * Reference to instance of object.
   *
   * @private
   * @ignore
   */
  referSpeeds : update(function(speeds) {
    var me = PotInternal.referSpeeds, prop, speed;
    if (speeds && this.forEach.fast.instance !== this) {
      for (prop in me.props) {
        if (prop in this && this[prop]) {
          for (speed in me.speeds) {
            if (speed in speeds && speed in this[prop] && this[prop][speed]) {
              this[prop][speed].instance = this;
            }
          }
        }
      }
    }
  }, {
    /**@ignore*/
    props : {
      forEach : true,
      repeat  : true,
      forEver : true,
      iterate : true,
      items   : true,
      zip     : true,
      map     : true,
      filter  : true,
      reduce  : true,
      every   : true,
      some    : true
    },
    /**@ignore*/
    speeds : {
      limp   : 0,
      doze   : 1,
      slow   : 2,
      normal : 3,
      fast   : 4,
      rapid  : 5,
      ninja  : 6
    }
  })
});

/**
 * Pot.Deferred.*speed*
 * 
 * Ability to establish a chain method asynchronously with specified speed.
 *
 * @example
 *   // This chain will run slower than normal.
 *   var d = new Pot.Deferred.slow(); // or limp (comprehensible)
 *   d.then(function() {
 *     debug(1);
 *   }).then(function() {
 *     debug(2);
 *   }).then(function() {
 *     debug(3);
 *   }).begin();
 *
 *
 * @param  {Object|*}  Options.
 * @return {Deferred}  Returns new instance of Deferred.
 *
 * @static
 * @lends Pot.Deferred
 * @property {Function} limp
 *           Create new Deferred with slowest speed. (static)
 * @property {Function} doze
 *           Create new Deferred with slower speed. (static)
 * @property {Function} slow
 *           Create new Deferred with slow speed. (static)
 * @property {Function} normal
 *           Create new Deferred with normal speed. (static)
 * @property {Function} fast
 *           Create new Deferred with fast speed. (static)
 * @property {Function} rapid
 *           Create new Deferred with faster speed. (static)
 * @property {Function} ninja
 *           Create new Deferred with fastest speed. (static)
 */
Deferred.extendSpeeds(Pot, 'Deferred', function(options) {
  return Deferred(options);
}, Deferred.speeds);

}());
//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Deferred utilities.
(function() {

update(Deferred, {
  /**
   * @lends Pot.Deferred
   */
  /**
   * Check whether the argument object is an instance of Pot.Deferred.
   *
   *
   * @example
   *   var o = {hoge: 1};
   *   var d = new Pot.Deferred();
   *   debug(isDeferred(o)); // false
   *   debug(isDeferred(d)); // true
   *
   *
   * @param  {Object|*}  x  The target object to test.
   * @return {Boolean}      Return true if the argument object is an
   *                          instance of Pot.Deferred,
   *                          otherwise return false.
   * @type Function
   * @function
   * @public
   * @static
   */
  isDeferred : isDeferred,
  /**
   * Return a Deferred that has already had .begin(result) called.
   *
   * This method useful when you execute synchronous code to
   *   an asynchronous interface.
   * i.e., some code is calling you expecting a Deferred result,
   *   but you don't actually need to do anything asynchronous.
   * Just return succeed(theResult).
   *
   *
   * @example
   *   function testFunc(value) {
   *     var result;
   *     if (value) {
   *       result = Pot.Deferred.succeed(value);
   *     } else {
   *       result = Pot.Deferred.begin(function() {
   *         return 'anything';
   *       });
   *     }
   *     return result;
   *   }
   *   testFunc( Math.random() * 10 >= 5 ? 'OK' : false ).then(function(res) {
   *     debug(res);
   *     // @results  res = 'OK' or 'anything'
   *   });
   *
   *
   * @param  {*}        (...)  The result to give to
   *                             Deferred.prototype.begin(result).
   * @return {Deferred}        Return a new Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  succeed : function(/*[...args]*/) {
    var d = new Deferred();
    return d.begin.apply(d, arguments);
  },
  /**
   * Return a Deferred that has already had .raise(result) called.
   *
   *
   * @example
   *   function testFunc(value) {
   *     var result;
   *     if (!value) {
   *       result = Pot.Deferred.failure('error');
   *     } else {
   *       result = Pot.Deferred.begin(function() {
   *         return 'success';
   *       });
   *     }
   *     return result;
   *   }
   *   testFunc(Math.random() * 10 >= 5 ? false : true).ensure(function(res) {
   *     debug(res);
   *     // @results  res = Error('error') or 'success'
   *   });
   *
   *
   * @param  {*}        (...)   The result to give to
   *                              Deferred.prototype.raise(result).
   * @return {Deferred}         Return a new Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  failure : function(/*[...args]*/) {
    var d = new Deferred();
    return d.raise.apply(d, arguments);
  },
  /**
   * Return a new cancellable Deferred that will .begin() after
   *  at least seconds seconds have elapsed.
   *
   *
   * @example
   *   // Called after 5 seconds.
   *   Pot.Deferred.wait(5).then(function() {
   *     debug('Begin wait() test');
   *   }).then(function() {
   *     return Pot.Deferred.wait(2); // Wait 2 seconds.
   *   }).then(function() {
   *     debug('End wait() test');
   *   });
   *
   *
   * @param  {Number}  seconds  Number of seconds.
   * @param  {*}       (value)  (optional) The value passed to the next chain.
   * @return {Deferred}         Return a new Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  wait : function(seconds, value) {
    var timer, d = new Deferred({
      /**@ignore*/
      canceller : function() {
        try {
          PotInternalClearTimeout(timer);
        } catch (e) {}
      }
    });
    if (arguments.length >= 2) {
      d.then(function() {
        return value;
      });
    }
    timer = PotInternalSetTimeout(function() {
      d.begin();
    }, Math.floor(((seconds - 0) || 0) * 1000));
    return d;
  },
  /**
   * Call the specified function after a few(seconds) seconds.
   *
   *
   * @example
   *   var value = null;
   *   // Called after 1 second.
   *   Pot.Deferred.callLater(1, function() {
   *     value = 'hoge';
   *   });
   *   debug(value); // null
   *   Pot.Deferred.callLater(1, function() {
   *     debug(value); // 'hoge'
   *   });
   *
   *
   * @example
   *   // Create a new Deferred synchronously.
   *   var d = new Pot.Deferred({ async : false });
   *   d.then(function() {
   *     return 'Hello Deferred!';
   *   }).then(function(res) {
   *     debug(res);
   *   });
   *   // But, run with asynchronously.
   *   // If the argument is the instance of Deferred
   *   //  then will be called "begin" method.
   *   Pot.Deferred.callLater(5, d); // Called after 5 seconds.
   *
   *
   * @param  {Number}   seconds   The number of seconds to delay.
   * @param  {Function} callback  The callback function.
   * @return {Deferred}           Return a new Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  callLater : function(seconds, callback) {
    var args = arrayize(arguments, 2);
    return Deferred.wait(seconds).then(function() {
      if (isDeferred(callback)) {
        return callback.begin.apply(callback, args);
      } else if (isFunction(callback)) {
        return callback.apply(callback, args);
      } else {
        return callback;
      }
    });
  },
  /**
   * Call the specified function as browser-non-blocking in background.
   * If callback is a Deferred, then will call .begin(args)
   *
   *
   * @example
   *   var value = null;
   *   Pot.Deferred.callLazy(function() {
   *     value = 'hoge';
   *   });
   *   debug(value); // null
   *   Pot.Deferred.callLazy(function() {
   *     debug(value); // 'hoge'
   *   });
   *
   *
   * @example
   *   // Create a new Deferred synchronously.
   *   var d = new Pot.Deferred({ async : false });
   *   d.then(function() {
   *     return 'Hello Deferred!';
   *   }).then(function(res) {
   *     debug(res);
   *   });
   *   // But, run with asynchronously.
   *   // If the argument is the instance of Deferred
   *   //  then will be called "begin" method.
   *   Pot.Deferred.callLazy(d);
   *
   *
   * @param  {Function} callback  A function to execute.
   * @return {Deferred}           Return a new Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  callLazy : function(callback) {
    var args = arrayize(arguments, 1);
    return Deferred.begin(function() {
      if (isDeferred(callback)) {
        return callback.begin.apply(callback, args);
      } else if (isFunction(callback)) {
        return callback.apply(callback, args);
      } else {
        return callback;
      }
    });
  },
  /**
   * Return a Deferred surely that maybe as a Deferred.
   *
   *
   * @example
   *   var maybeTest = function(obj) {
   *     var deferred = Pot.Deferred.maybeDeferred(obj);
   *     debug(deferred);
   *     // @results  deferred = (object Deferred {...})
   *     return deferred;
   *   };
   *   var obj;
   *   if (Math.random() * 10 < 5) {
   *     obj = new Pot.Deferred().then(function() {
   *       return 'foo';
   *     });
   *   } else {
   *     obj = 'bar';
   *   }
   *   maybeTest(obj).then(function(res) {
   *     debug('res = ' + res); // 'foo' or 'bar'
   *   }).begin();
   *
   *
   * @param  {*}         x    The value like a Deferred.
   * @retrun {Deferred}       Return a Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  maybeDeferred : function(x) {
    var d;
    if (isDeferred(x)) {
      return x;
    }
    if (isError(x)) {
      return Deferred.failure(x);
    }
    if (x) {
      try {
        // jQuery Deferred convertion.
        if (typeof jQuery === 'function' && jQuery.Deferred &&
            typeof x.then === 'function' &&
            x.promise && x.always && x.resolve && x.rejectWith
        ) {
          d = new Deferred();
          x.then(function() {
            d.begin.apply(d, arguments);
          }, function() {
            d.raise.apply(d, arguments);
          });
          return d;
        }
      } catch (e) {}
      try {
        // JSDeferred convertion.
        if (x._id === 0xE38286E381AE &&
            typeof x.next === 'function' && typeof x.error === 'function' &&
            typeof x.fail === 'function' && typeof x.cancel === 'function'
        ) {
          d = new Deferred();
          x.next(function() {
            d.begin.apply(d, arguments);
          }).error(function() {
            d.raise.apply(d, arguments);
          });
          return d;
        }
      } catch (e) {}
    }
    return Deferred.succeed(x);
  },
  /**
   * Check whether the callback chain was fired.
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   debug( Pot.Deferred.isFired(d) ); // false
   *   d.then(function() {
   *     return 'hoge';
   *   });
   *   debug( Pot.Deferred.isFired(d) ); // false
   *   d.begin();
   *   debug( Pot.Deferred.isFired(d) ); // true
   *
   *
   * @param  {Deferred}  deferred  The target Deferred object.
   * @return {Boolean}             Return whether the
   *                                 callback chain was fired.
   * @type Function
   * @function
   * @public
   * @static
   */
  isFired : function(deferred) {
    return isDeferred(deferred) &&
           ((deferred.state & Deferred.states.fired) !== 0);
  },
  /**
   * Get the last result of the callback chains.
   *
   *
   * @example
   *   var d = new Pot.Deferred({ async : false });
   *   d.then(function() {
   *     return 'foo';
   *   }).then(function(res) {
   *     return 'bar';
   *   }).then(function(res) {
   *     return 'baz';
   *   }).begin();
   *   var result = Pot.Deferred.lastResult(d);
   *   debug(result);
   *   // @results  result = 'baz'
   *
   *
   * @param  {Deferred}  deferred  The target Deferred object.
   * @param  {*}         (value)   (Optional) The input value.
   * @return {*}                   Return the last result if exist.
   * @type Function
   * @function
   * @public
   * @static
   */
  lastResult : function(deferred, value) {
    var result, args = arguments, key;
    if (isDeferred(deferred)) {
      try {
        key = Deferred.states[Deferred.states.success];
        if (args.length <= 1) {
          result = deferred.results[key];
        } else {
          deferred.results[key] = value;
          result = deferred;
        }
      } catch (e) {}
    }
    return result;
  },
  /**
   * Get the last Error of the callback chains.
   *
   *
   * @example
   *   var d = new Pot.Deferred({ async : false });
   *   d.then(function() {
   *     throw new Error('foo');
   *   }).then(function(res) {
   *     throw new Error('bar');
   *   }).then(function(res) {
   *     throw new Error('baz');
   *   }).begin();
   *   var result = Pot.Deferred.lastError(d);
   *   debug(result);
   *   // @results  result = (Error: foo)
   *
   *
   * @param  {Deferred}  deferred  The target Deferred object.
   * @param  {*}         (value)   (Optional) The input value.
   * @return {*}                   Return the last Error if exist.
   * @type Function
   * @function
   * @public
   * @static
   */
  lastError : function(deferred, value) {
    var result, args = arguments, key;
    if (isDeferred(deferred)) {
      try {
        key = Deferred.states[Deferred.states.failure];
        if (args.length <= 1) {
          result = deferred.results[key];
        } else {
          if (!isError(value)) {
            value = new Error(value);
          }
          deferred.results[key] = value;
          result = deferred;
        }
      } catch (e) {}
    }
    return result;
  },
  /**
   * Register the new method into Pot.Deferred.prototype.
   *
   *
   * @example
   *   // Register the new method for waiting 5 seconds.
   *   Pot.Deferred.register('wait5', function(args) {
   *     return Pot.Deferred.wait(5).then(function() {
   *       return args.result;
   *     });
   *   });
   *   // Use registered method.
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     debug('begin');
   *     return 1;
   *   }).wait5().then(function(res) {
   *     debug(res); // @results  res = 1
   *     debug('end');
   *   });
   *   d.begin();
   *
   *
   * @example
   *   // Register a new method for add the input value and the result.
   *   Pot.Deferred.register('add', function(args) {
   *     return args.inputs[0] + args.results[0];
   *   });
   *   // Use registered method.
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     debug('begin');
   *     return 100;
   *   }).add(50).then(function(res) {
   *     debug(res); // @results  res = 150
   *     debug('end');
   *   });
   *   d.begin();
   *
   *
   * @param  {String|Object}  name  The name of the new method.
   *                                  Or, the new methods as key-value object.
   * @param  {Function}       func  The new method.
   *                                  A new function has defined argument
   *                                    that is an object.
   *                                  <pre>
   *                                  -------------------------------------
   *                                  function(args)
   *                                    - args.inputs  : {Arguments}
   *                                        The original input arguments.
   *                                    - args.results : {Arguments}
   *                                        The result of previous
   *                                          callback chain.
   *                                  -------------------------------------
   *                                  </pre>
   * @return {Number}               Return the registered count.
   * @type Function
   * @function
   * @public
   * @static
   */
  register : function(/*name, func*/) {
    var result = 0, that = Deferred.fn,
        args = arrayize(arguments), methods = [];
    switch (args.length) {
      case 0:
          break;
      case 1:
          if (isObject(args[0])) {
            each(args[0], function(val, key) {
              if (isFunction(val) && isString(key)) {
                methods.push([key, val]);
              } else if (isFunction(key) && isString(val)) {
                methods.push([val, key]);
              }
            });
          }
          break;
      default:
          if (isFunction(args[0])) {
            methods.push([args[1], args[0]]);
          } else {
            methods.push([args[0], args[1]]);
          }
    }
    if (methods && methods.length) {
      each(methods, function(item) {
        var subs = {}, name, func, method;
        if (item && item.length >= 2 && isFunction(item[1])) {
          name = stringify(item[0], true);
          func = item[1];
          /**@ignore*/
          method = function() {
            var params = {};
            params.inputs = arguments;
            return this.then(function() {
              params.results = arguments;
              return func.call(this, params);
            });
          };
          subs[name] = method;
          update(that, subs);
          result++;
        }
      });
    }
    return result;
  },
  /**
   * Unregister the user defined method from Pot.Deferred.prototype.
   *
   *
   * @example
   *   // Register a new method for add the input value and the result.
   *   Pot.Deferred.register('add', function(args) {
   *     return args.inputs[0] + args.results[0];
   *   });
   *   // Use registered method.
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     debug('begin');
   *     return 100;
   *   }).add(50).then(function(res) {
   *     debug(res); // @results  res = 150
   *     debug('end');
   *   });
   *   d.begin();
   *   // Unregister the user defined method from Pot.Deferred.prototype.
   *   Pot.Deferred.unregister('add');
   *   var dfd = new Pot.Deferred();
   *   dfd.then(function() {
   *     debug('After unregister');
   *     return 10;
   *     // Next chain will be occur an error: add is undefined.
   *   }).add(20).then(function(res) {
   *     debug(res);
   *   });
   *   dfd.begin();
   *
   *
   * @param  {String|Array}  name  The name of the user defined method.
   * @return {Number}              Return the unregistered count.
   * @type Function
   * @function
   * @public
   * @static
   */
  unregister : function(/*name*/) {
    var result = 0, that = Deferred.fn, args = arrayize(arguments), names;
    if (args.length > 1) {
      names = args;
    } else {
      names = args[0];
    }
    each(arrayize(names), function(name) {
      try {
        delete that[name];
        result++;
      } catch (e) {}
    });
    return result;
  },
  /**
   * Create new defer function from static function.
   * That returns a new instance of Pot.Deferred that
   *   has already ".begin()" called.
   *
   *
   * @example
   *   var timer = Pot.Deferred.deferrize(window, 'setTimeout');
   *   // Call the defer function with same as the original arguments usage.
   *   timer(function() {
   *     debug('in timer (2000 ms.)');
   *   }, 2000).then(function() {
   *     debug('End timer');
   *   });
   *
   *
   * @example
   *   var byId = Pot.Deferred.deferrize(document, 'getElementById');
   *   // Call the defer function with same as the original arguments usage.
   *   byId('container').then(function(element) {
   *     debug('End byId()');
   *     debug('tagName = ' + element.tagName);
   *     // @results  tagName = 'DIV'
   *   });
   *
   *
   * @example
   *   // Example of user defined function.
   *   var toCharCode = Pot.Deferred.deferrize(function(string) {
   *     var chars = [], i, len = string.length;
   *     for (i = 0; i < len; i++) {
   *       chars.push(string.charCodeAt(i));
   *     }
   *     return chars;
   *   });
   *   var string = 'abcdef';
   *   Pot.Deferred.begin(function() {
   *     debug('string = ' + string);
   *     return toCharCode(string).then(function(result) {
   *       debug('result = ' + result);
   *       // @results  result = [97, 98, 99, 100, 101, 102]
   *     });
   *   });
   *
   *
   * @param  {Object|Function}   object   The context object.
   *                                        or the target function.
   * @param  {String|Function}  (method)  The target function name.
   *                                        or the target function.
   * @return {Function}                   The defer function that
   *                                        returns Deferred object.
   * @based  JSDeferred.connect
   * @type   Function
   * @function
   * @public
   * @static
   */
  deferrize : function(object, method) {
    var args = arguments, func, context, err;
    try {
      switch (args.length) {
        case 0:
            throw false;
        case 1:
            func = object;
            break;
        default:
            if (isObject(method)) {
              context = method;
              func    = object;
            } else {
              func    = method;
              context = object;
            }
      }
      if (!func) {
        throw func;
      }
    } catch (e) {
      err = e;
      throw (isError(err) ? err : new Error(err));
    }
    return function() {
      var that = this, args = arrayize(arguments), d = new Deferred();
      d.then(function() {
        var dd = new Deferred(), result, params = [],
            done = false, error, isFired = Deferred.isFired;
        each(args, function(val) {
          if (isFunction(val)) {
            params.push(function() {
              var r, er;
              try {
                r = val.apply(that, arguments);
              } catch (e) {
                er = e;
                if (!isFired(dd)) {
                  dd.raise(er);
                }
              } finally {
                if (!isFired(dd)) {
                  dd.begin(r);
                }
              }
              if (er != null) {
                throw er;
              }
              return r;
            });
            done = true;
          } else {
            params[params.length] = val;
          }
        });
        try {
          result = invoke(context, func, params);
        } catch (e) {
          error = e;
          if (!done && !isFired(dd)) {
            dd.raise(error);
          }
        } finally {
          if (!done && !isFired(dd)) {
            dd.begin(result);
          }
        }
        if (error != null) {
          throw isError(error) ? error : new Error(error);
        }
        return dd;
      }).begin();
      return d;
    };
  },
  /**
   * Update the Pot.Deferred.
   *
   *
   * @example
   *   // Update Pot.Deferred.
   *   Pot.Deferred.update({
   *     sayHoge : function() {
   *       alert('hoge');
   *     }
   *   });
   *   Pot.Deferred.sayHoge(); // hoge
   *
   *
   * @param  {Object}        (...)  The object to update.
   * @return {Pot.Deferred}         Return Pot.Deferred.
   * @type   Function
   * @function
   * @public
   * @static
   */
  update : function() {
    var that = Deferred, args = arrayize(arguments);
    args.unshift(that);
    return update.apply(that, args);
  }
});

// Definitions of the loop/iterator methods.
update(Deferred, {
  /**
   * @lends Pot.Deferred
   */
  /**
   * A shortcut faster way of creating new Deferred sequence.
   *
   *
   * @example
   *   Pot.Deferred.begin(function() {
   *     debug('Begin Deferred.begin');
   *   }).wait(1).then(function() {
   *     debug('End Deferred.begin');
   *   });
   *   // Without having to call  the ".begin()", has already executed.
   *
   *
   * @param  {Function|*}   x   A callback function or any value.
   * @return {Deferred}         Return a new Deferred.
   * @class
   * @type Function
   * @function
   * @public
   * @static
   */
  begin : function(x) {
    var d = new Deferred(), args = arrayize(arguments, 1), value;
    if (x && isFunction(x)) {
      d.then(function() {
        return x.apply(this, args);
      });
    } else {
      value = x;
    }
    PotInternalCallInBackground.flush(function() {
      d.begin(value);
    });
    return d;
  },
  /**
   * Call the function with asynchronous.
   *
   *
   * @example
   *   var value = null;
   *   // Call the function with asynchronous.
   *   Pot.Deferred.flush(function() {
   *     debug('Begin Deferred.flush');
   *     value = 1;
   *   }).wait(1).then(function() {
   *     debug('End Deferred.flush');
   *     value = 2;
   *   });
   *   // Without having to call the ".begin()", has already executed.
   *   debug(value);
   *   // @results  value = null
   *   Pot.Deferred.callLater(2.5, function() {
   *     debug(value);
   *     // @results  value = 2
   *   });
   *
   *
   * @param  {Function|*} callback  A function to call.
   * @param  {...}        (...)     Arguments passed to callback.
   * @return {Deferred}             Return a new Deferred.
   * @class
   * @type Function
   * @function
   * @public
   * @static
   */
  flush : function(callback) {
    var args = arrayize(arguments, 1);
    return Deferred.begin(function() {
      if (isDeferred(callback)) {
        return callback.begin.apply(callback, args);
      } else if (isFunction(callback)) {
        return callback.apply(this, args);
      } else {
        return callback;
      }
    });
  },
  /**
   * Wait until the condition completed.
   * If true returned, waiting state will end.
   *
   *
   * @example
   *   debug('Begin till');
   *   Pot.Deferred.till(function() {
   *     // wait until the DOM body element is loaded
   *     if (!document.body) {
   *       return false;
   *     } else {
   *       return true;
   *     }
   *   }).then(function() {
   *     debug('End till');
   *     document.body.innerHTML += 'hoge';
   *   });
   *
   *
   * @param  {Function|*}   cond   A function or value as condition.
   * @return {Deferred}            Return the Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  till : function(cond) {
    var d = new Deferred(), args = arrayize(arguments, 1), interval = 13;
    return Deferred.begin(function till() {
      var that = this, time = now();
      if (cond && !cond.apply(this, args)) {
        PotInternalSetTimeout(function() {
          till.call(that);
        }, Math.min(1000, interval + (now() - time)));
      } else {
        d.begin();
      }
      return d;
    });
  },
  /**
   * Bundle up some Deferreds (DeferredList) to one Deferred
   *  then returns results of  these list.
   *
   * The DeferredList can be as Array or Object.
   *
   *
   * @example
   *   Pot.Deferred.parallel([
   *     function() {
   *       debug(1);
   *       return 1;
   *     },
   *     function() {
   *       debug(2);
   *       var d = new Pot.Deferred();
   *       return d.then(function() { return 2; }).begin();
   *     },
   *     Pot.Deferred.begin(function() {
   *       return Pot.Deferred.wait(2).then(function() {
   *         debug(3);
   *         return 3;
   *       });
   *     }),
   *     '{4}',
   *     (new Pot.Deferred()).then(function() {
   *       return Pot.Deferred.wait(1.5).then(function() {
   *         debug(5);
   *         return 5;
   *       });
   *     }).begin(),
   *     6.00126,
   *     function() {
   *       return Pot.Deferred.succeed().then(function() {
   *         return Pot.Deferred.wait(1).then(function() {
   *           return 7;
   *         });
   *       });
   *     },
   *     function() {
   *       return Pot.Deferred.begin(function() {
   *         debug(8);
   *         return 8;
   *       });
   *     }
   *   ]).then(function(values) {
   *     debug(values);
   *     // values[0] == 1
   *     // values[1] == 2
   *     // values[2] == 3
   *     // values[3] == '{4}'
   *     // ...
   *   });
   *   // @results  values = [1, 2, 3, '{4}', 5, 6.00126, 7, 8]
   *   //
   *   // output: 1, 2, 8, 5, 3 ...
   *   //
   *
   *
   * @example
   *   Pot.Deferred.parallel({
   *     foo : function() {
   *       debug(1);
   *       return 1;
   *     },
   *     bar : (new Pot.Deferred()).then(function() {
   *       return Pot.Deferred.begin(function() {
   *         return Pot.Deferred.wait(1).then(function() {
   *           debug(2);
   *           return Pot.Deferred.succeed(2);
   *         });
   *       });
   *     }).begin(),
   *     baz : function() {
   *       var d = new Pot.Deferred();
   *       return d.async(false).then(function() {
   *         debug(3);
   *         return 3;
   *       }).begin();
   *     }
   *   }).then(function(values) {
   *     debug(values);
   *     // values.foo == 1
   *     // values.bar == 2
   *     // values.baz == 3
   *   });
   *   // @results  values = {foo: 1, baz: 3, bar: 2}
   *   //
   *   // output: 1, 3, 2
   *   //
   *
   *
   * @param  {...[Array|Object|*]} deferredList  Deferred list to get
   *                                               the results in bundles.
   * @return {Deferred}                          Return the Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  parallel : function(deferredList) {
    var result, args = arguments, d, deferreds, values, bounds;
    if (args.length === 0) {
      result = Deferred.succeed();
    } else {
      if (args.length === 1) {
        if (isObject(deferredList)) {
          deferreds = deferredList;
        } else {
          deferreds = arrayize(deferredList);
        }
      } else {
        deferreds = arrayize(args);
      }
      result = new Deferred({
        /**@ignore*/
        canceller : function() {
          each(deferreds, function(deferred) {
            if (isDeferred(deferred)) {
              deferred.cancel();
            }
          });
        }
      });
      d = new Deferred();
      bounds = [];
      values = isObject(deferreds) ? {} : [];
      each(deferreds, function(deferred, key) {
        var defer;
        if (isDeferred(deferred)) {
          defer = deferred;
        } else if (isFunction(deferred)) {
          defer = new Deferred();
          defer.then(deferred);
        } else {
          defer = Deferred.succeed(deferred);
        }
        if (!isDeferred(defer)) {
          defer = Deferred.maybeDeferred(defer);
        }
        bounds[bounds.length] = key;
        d.then(function() {
          if (defer.state === Deferred.states.unfired) {
            Deferred.flush(defer);
          }
          defer.then(function(value) {
            if (bounds.length) {
              values[key] = value;
              bounds.pop();
              if (bounds.length === 0) {
                result.begin(values);
              }
            }
          }, function(err) {
            bounds = [];
            result.raise(err);
          });
        });
      });
      Deferred.flush(d);
    }
    return result;
  },
  /**
   * Create a new Deferred with callback chains by
   *   some functionable arguments.
   *
   *
   * @example
   *   var deferred = Pot.Deferred.chain(
   *     function() {
   *       debug(1);
   *       return Pot.Deferred.wait(1);
   *     },
   *     function() {
   *       debug(2);
   *       throw new Error('error');
   *     },
   *     function rescue(err) {
   *       debug(3);
   *       debug('Error : ' + err);
   *     },
   *     1000,
   *     function(number) {
   *       debug(4);
   *       debug('prev number = ' + number);
   *       return Pot.Deferred.wait(2);
   *     },
   *     {
   *       foo : function() {
   *         debug('5 foo');
   *         return '{{foo}}';
   *       },
   *       bar : function() {
   *         debug('6 bar');
   *         return Pot.Deferred.begin(function() {
   *           return '{{bar}}';
   *         });
   *       }
   *     },
   *     function(res) {
   *       debug('7 res:');
   *       debug(res);
   *     },
   *     new Error('error2'),
   *     function() {
   *       debug('This chain will not be called.');
   *     },
   *     function rescue(e) {
   *       debug(8);
   *       debug('Error : ' + e);
   *     },
   *     [
   *       function() {
   *         debug(9);
   *         return Pot.Deferred.wait(1).then(function() {
   *           return 9;
   *         });
   *       },
   *       function() {
   *         debug(10);
   *         return Pot.Deferred.wait(1.5).then(function() {
   *           return Pot.Deferred.succeed(10);
   *         });
   *       }
   *     ],
   *     function(res) {
   *       debug('11 res:');
   *       debug('res[0] = ' + res[0] + ', res[1] = ' + res[1]);
   *     },
   *     (new Pot.Deferred()).then(function() {
   *       debug('12 [END]');
   *     })
   *   );
   *
   *
   * @param  {...[Function|Array|Object|*]}  (...)  Arguments to
   *                                                  concatenate the chains.
   * @return {Deferred}                             Return a new Deferred.
   * @type Function
   * @function
   * @public
   * @static
   * @based  JSDeferred.chain
   */
  chain : (function() {
    var re = {
      funcName : /^\s*[()]*\s*function\s*([^\s()]+)/,
      rescue   : /rescue|raise|err|fail/i
    };
    return function(/*...args*/) {
      var args = arguments, len = args.length, chains,
          chain = new Deferred();
      if (len > 0) {
        chains = arrayize((len === 1) ? args[0] : args);
        each(chains, function(o) {
          var name;
          if (isFunction(o)) {
            try {
              name = Pot.getFunctionCode(o).match(re.funcName)[1];
            } catch (e) {}
            if (name && re.rescue.test(name)) {
              chain.rescue(o);
            } else {
              chain.then(o);
            }
          } else if (isDeferred(o)) {
            chain.then(function(v) {
              if (o.state === Deferred.states.unfired) {
                o.begin(v);
              }
              return o;
            });
          } else if (isObject(o) || isArray(o)) {
            chain.then(function() {
              return Deferred.parallel(o);
            });
          } else if (isError(o)) {
            chain.then(function() {
              throw o;
            });
          } else {
            chain.then(function() {
              return o;
            });
          }
        });
      }
      Deferred.callLazy(chain);
      return chain;
    };
  }())
});

// Extends the speeds control methods
/**
 * Pot.Deferred.begin.*speed* (limp/doze/slow/normal/fast/rapid/ninja).
 *
 * A shortcut faster way of
 *   creating new Deferred sequence with specified speed.
 *
 * @param  {Function|*}   x   A callback function or any value.
 * @return {Deferred}         Return a new Deferred.
 *
 * @static
 * @lends Pot.Deferred.begin
 * @property {Function} limp
 *           Return new Deferred with slowest speed. (static)
 * @property {Function} doze
 *           Return new Deferred with slower speed. (static)
 * @property {Function} slow
 *           Return new Deferred with slow speed. (static)
 * @property {Function} normal
 *           Return new Deferred with normal speed. (static)
 * @property {Function} fast
 *           Return new Deferred with fast speed. (static)
 * @property {Function} rapid
 *           Return new Deferred with faster speed. (static)
 * @property {Function} ninja
 *           Return new Deferred with fastest speed. (static)
 */
Deferred.extendSpeeds(Deferred, 'begin', function(opts, x) {
  var d, timer, args = arrayize(arguments, 2),
      isCallable = (x && isFunction(x)),
      op = opts.options || opts || {},
      speed, value;
  if (!op.cancellers) {
    op.cancellers = [];
  }
  op.cancellers.push(function() {
    try {
      if (timer != null) {
        PotInternalClearTimeout(timer);
      }
    } catch (e) {}
  });
  d = new Deferred(op);
  if (isCallable) {
    d.then(function() {
      return x.apply(this, args);
    });
  } else {
    value = x;
  }
  speed = (((opts.options && opts.options.speed) || opts.speed) - 0) || 0;
  if (isNumeric(speed) && speed > 0) {
    timer = PotInternalSetTimeout(function() {
      d.begin(value);
    }, speed);
  } else {
    PotInternalCallInBackground.flush(function() {
      d.begin(value);
    });
  }
  return d;
}, Deferred.speeds);

/**
 * Pot.Deferred.flush.*speed* (limp/doze/slow/normal/fast/rapid/ninja).
 *
 * Call the function with asynchronous by specified speed.
 *
 * @param  {Function|*} callback  A function to call.
 * @param  {...}        (...)     Arguments passed to callback.
 * @return {Deferred}
 *
 * @static
 * @lends Pot.Deferred.flush
 * @property {Function} limp
 *           Return new Deferred with slowest speed. (static)
 * @property {Function} doze
 *           Return new Deferred with slower speed. (static)
 * @property {Function} slow
 *           Return new Deferred with slow speed. (static)
 * @property {Function} normal
 *           Return new Deferred with normal speed. (static)
 * @property {Function} fast
 *           Return new Deferred with fast speed. (static)
 * @property {Function} rapid
 *           Return new Deferred with faster speed. (static)
 * @property {Function} ninja
 *           Return new Deferred with fastest speed. (static)
 */
Deferred.extendSpeeds(Deferred, 'flush', function(opts, callback) {
  var speed, name, method, args = arrayize(arguments, 2);
  speed = opts.options ? opts.options.speed : opts.speed;
  if (speed in Deferred.speeds &&
      isString(Deferred.speeds[speed])) {
    name = Deferred.speeds[speed];
  } else {
    each(Deferred.speeds, function(val, key) {
      if (val == speed) {
        name = key;
        throw PotStopIteration;
      }
    });
  }
  if (name && name in Deferred.begin) {
    method = Deferred.begin[name];
  } else {
    method = Deferred.begin;
  }
  return method(function() {
    if (isDeferred(callback)) {
      return callback.begin.apply(callback, args);
    } else if (isFunction(callback)) {
      return callback.apply(this, args);
    } else {
      return callback;
    }
  });
}, Deferred.speeds);

// Update Pot object.
Pot.update({
  succeed       : Pot.Deferred.succeed,
  failure       : Pot.Deferred.failure,
  wait          : Pot.Deferred.wait,
  callLater     : Pot.Deferred.callLater,
  callLazy      : Pot.Deferred.callLazy,
  maybeDeferred : Pot.Deferred.maybeDeferred,
  isFired       : Pot.Deferred.isFired,
  lastResult    : Pot.Deferred.lastResult,
  lastError     : Pot.Deferred.lastError,
  register      : Pot.Deferred.register,
  unregister    : Pot.Deferred.unregister,
  deferrize     : Pot.Deferred.deferrize,
  begin         : Pot.Deferred.begin,
  flush         : Pot.Deferred.flush,
  till          : Pot.Deferred.till,
  parallel      : Pot.Deferred.parallel,
  chain         : Pot.Deferred.chain
});

}());

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Define iteration methods. (internal)
(function() {
var LightIterator,
    QuickIteration,
    createLightIterateConstructor,
    createSyncIterator;

update(PotInternal, {
  /**
   * @lends Pot.Internal
   */
  /**
   * LightIterator.
   *
   * Async/Sync iterator.
   *
   * @class
   * @private
   * @constructor
   * @ignore
   */
  LightIterator : update(function(object, callback, options) {
    return new LightIterator.fn.doit(
      object, callback, options
    );
  }, {
    /**@ignore*/
    speeds : {
      limp   : -1,
      doze   :  0,
      slow   :  2,
      normal :  5,
      fast   : 12,
      rapid  : 36,
      ninja  : 60
    },
    /**@ignore*/
    delays : {
      limp   : 1000,
      doze   :  100,
      slow   :   13,
      normal :    0,
      fast   :    0,
      rapid  :    0,
      ninja  :    0
    },
    /**@ignore*/
    types : {
      forLoop   : 0x01,
      forInLoop : 0x02,
      repeat    : 0x04,
      forEver   : 0x08,
      iterate   : 0x10,
      items     : 0x20,
      zip       : 0x40
    }
  })
});

// Refer the Pot properties/functions.
PotInternalLightIterator = LightIterator = PotInternal.LightIterator;

update(LightIterator, {
  /**@ignore*/
  defaults : {
    speed : LightIterator.speeds.normal
  },
  /**@ignore*/
  revSpeeds : {}
});

each(LightIterator.speeds, function(v, k) {
  LightIterator.revSpeeds[v] = k;
});

LightIterator.fn = LightIterator.prototype =
  update(LightIterator.prototype, {
  /**
   * @lends Pot.Internal.LightIterator.prototype
   */
  /**
   * @ignore
   */
  constructor : LightIterator,
  /**
   * @private
   * @ignore
   */
  interval : LightIterator.defaults.speed,
  /**
   * @private
   * @ignore
   */
  iter : null,
  /**
   * @private
   * @ignore
   */
  result : null,
  /**
   * @private
   * @ignore
   */
  deferred : null,
  /**
   * @private
   * @ignore
   */
  revDeferred : null,
  /**
   * @private
   * @ignore
   */
  isDeferStopIter : false,
  /**
   * @private
   * @ignore
   */
  time : {},
  /**
   * @private
   * @ignore
   */
  waiting : false,
  /**
   * @private
   * @ignore
   */
  restable : false,
  /**
   * @private
   * @ignore
   */
  async : false,
  /**
   * @private
   * @ignore
   */
  options : null,
  /**
   * @private
   * @ignore
   */
  doit : function(object, callback, options) {
    this.setOptions(options);
    this.execute(object, callback);
    this.watch();
    return this;
  },
  /**
   * Set the options.
   *
   * @private
   * @ignore
   */
  setOptions : function(options) {
    this.options = options || {};
    this.setInterval();
    this.setAsync();
  },
  /**
   * Set the interval option.
   *
   * @private
   * @ignore
   */
  setInterval : function() {
    var n = null;
    if (isNumeric(this.options.interval)) {
      n = this.options.interval - 0;
    } else if (this.options.interval in LightIterator.speeds) {
      n = LightIterator.speeds[this.options.interval] - 0;
    }
    if (n !== null && !isNaN(n)) {
      this.interval = n;
    }
    if (!isNumeric(this.interval)) {
      this.interval = LightIterator.defaults.speed;
    }
  },
  /**
   * Set the async option.
   *
   * @private
   * @ignore
   */
  setAsync : function() {
    var a = null;
    if (this.options.async !== void 0) {
      a = !!this.options.async;
    }
    if (a !== null) {
      this.async = !!a;
    }
    if (!isBoolean(this.async)) {
      this.async = !!this.async;
    }
  },
  /**
   * Create a new Deferred.
   *
   * @private
   * @ignore
   */
  createDeferred : function() {
    return new Deferred({ async : false });
  },
  /**
   * Watch the process.
   *
   * @private
   * @ignore
   */
  watch : function() {
    var that = this;
    if (!this.async && this.waiting === true && PotSystem.isWaitable) {
      Pot.XPCOM.throughout(function() {
        return that.waiting !== true;
      });
    }
  },
  /**
   * Execute process.
   *
   * @private
   * @ignore
   */
  execute : function(object, callback) {
    var d, that = this;
    this.waiting = true;
    if (!object) {
      this.result = {};
      this.waiting = false;
    } else {
      this.waiting  = true;
      this.restable = true;
      this.time = {
        start : now(),
        total : null,
        loop  : null,
        diff  : null,
        risk  : null,
        axis  : null,
        count : 1,
        rest  : 100,
        limit : 255
      };
      this.setIter(object, callback);
      if (!this.async && !PotSystem.isWaitable) {
        this.revback();
        this.waiting = false;
      } else {
        d = this.createDeferred();
        d.then(function() {
          var d1 = that.createDeferred(),
              d2 = that.createDeferred();
          d1.then(function() {
            return that.revolve().then(function() {
              d2.begin();
            });
          }).begin();
          return d2;
        }).ensure(function() {
          that.waiting = false;
        });
        if (this.async) {
          this.deferred = d.then(function() {
            if (isDeferred(that.result) &&
                isStopIter(Deferred.lastError(that.result))) {
              that.result = Deferred.lastResult(that.result);
            }
            return that.result;
          });
        }
        this.flush(d);
      }
    }
  },
  /**
   * @private
   * @ignore
   */
  setIter : function(object, callback) {
    var type = this.options.type,
        types = LightIterator.types,
        context = this.options.context;
    switch (true) {
      case ((type & types.iterate) === types.iterate):
          this.result = null;
          this.iter = this.iterate(object, callback, context);
          break;
      case ((type & types.forEver) === types.forEver):
          this.result = {};
          this.iter = this.forEver(object, context);
          break;
      case ((type & types.repeat) === types.repeat):
          this.result = {};
          this.iter = this.repeat(object, callback, context);
          break;
      case ((type & types.items) === types.items):
          this.result = [];
          this.iter = this.items(object, callback, context);
          break;
      case ((type & types.zip) === types.zip):
          this.result = [];
          this.iter = this.zip(object, callback, context);
          break;
      default:
          if (isArrayLike(object)) {
            this.result = object;
            this.iter = this.forLoop(object, callback, context);
          } else {
            this.result = object;
            this.iter = this.forInLoop(object, callback, context);
          }
    }
  },
  /**
   * @private
   * @ignore
   */
  revback : function() {
    var that = this, result, err, cutback = false, time;
    this.time.loop = now();
    REVOLVE: {
      do {
        try {
          if (this.isDeferStopIter) {
            this.isDeferStopIter = false;
            throw PotStopIteration;
          }
          result = this.iter.next();
        } catch (e) {
          err = e;
          if (isStopIter(err)) {
            break REVOLVE;
          }
          throw err;
        }
        if (this.async && isDeferred(result)) {
          return result.ensure(function(res) {
            if (res !== void 0) {
              if (isError(res)) {
                if (isStopIter(res)) {
                  that.isDeferStopIter = true;
                  if (isDeferred(that.result) &&
                      isStopIter(Deferred.lastError(that.result))) {
                    that.result = Deferred.lastResult(that.result);
                  }
                } else {
                  Deferred.lastError(this, res);
                }
              } else {
                Deferred.lastResult(this, res);
              }
            }
            that.flush(that.revback, true);
          });
        }
        time = now();
        if (PotSystem.isWaitable) {
          if (this.time.total === null) {
            this.time.total = time;
          } else if (time - this.time.total >= this.time.rest) {
            Pot.XPCOM.throughout(0);
            this.time.total = now();
          }
        } else if (!this.async) {
          if (this.restable && this.time.count >= this.time.limit) {
            this.restable = false;
          }
        }
        this.time.risk = time - this.time.start;
        this.time.diff = time - this.time.loop;
        if (this.time.diff >= this.interval) {
          if (this.async &&
              this.interval < LightIterator.speeds.normal) {
            cutback = true;
          } else if (this.async || this.restable || PotSystem.isWaitable) {
            if (this.time.diff < this.interval + 8) {
              this.time.axis = 2;
            } else if (this.time.diff < this.interval + 36) {
              this.time.axis = 5;
            } else if (this.time.diff < this.interval + 48) {
              this.time.axis = 7;
            } else {
              this.time.axis = 10;
            }
            if (this.time.axis >= 10 ||
                (Math.random() * 10 < this.time.axis)) {
              cutback = true;
            }
          }
        }
      } while (!cutback);
      if (this.time.count <= this.time.limit) {
        this.time.count++;
      }
      return this.flush(this.revback, true);
    }
    if (isDeferred(this.revDeferred)) {
      this.revDeferred.begin();
    }
  },
  /**
   * Revolve the process.
   *
   * @private
   * @ignore
   */
  revolve : function() {
    var that = this,
        d  = this.createDeferred(),
        de = this.createDeferred();
    d.then(function() {
      var dd = that.createDeferred();
      that.revDeferred = that.createDeferred();
      dd.then(function() {
        return that.revback();
      }).begin();
      return that.revDeferred;
    }).ensure(function(er) {
      de.begin();
      if (isError(er)) {
        throw er;
      }
    });
    this.flush(d);
    return de;
  },
  /**
   * Flush the callback.
   *
   * @private
   * @ignore
   */
  flush : function(callback, useSpeed) {
    var that = this, d, lazy = false, speed, speedKey;
    if (this.async || PotSystem.isWaitable) {
      lazy = true;
    }
    if (!lazy && isFunction(callback)) {
      return callback.call(this);
    } else {
      d = this.createDeferred();
      d.then(function() {
        if (isDeferred(callback)) {
          callback.begin();
        } else {
          callback.call(that);
        }
      });
      if (lazy) {
        speed = 0;
        if (useSpeed) {
          speedKey = LightIterator.revSpeeds[this.interval];
          if (speedKey &&
              isNumeric(LightIterator.delays[speedKey])) {
            speed = LightIterator.delays[speedKey];
          }
          if (Math.random() * 10 < Math.max(2, (this.time.axis || 2) / 2.75)) {
            speed += Math.min(
              this.time.rest,
              Math.max(1,
                Math.ceil(
                  (this.time.risk / (this.time.rest + this.time.diff)) +
                   this.time.diff
                )
              )
            );
          }
        }
        PotInternalSetTimeout(function() {
          d.begin();
        }, speed);
      } else {
        d.begin();
      }
    }
  },
  /**
   * Return noop function.
   *
   * @private
   * @ignore
   */
  noop : function() {
    return {
      /**@ignore*/
      next : function() {
        throw PotStopIteration;
      }
    };
  },
  /**
   * forEver.
   *
   * @private
   * @ignore
   */
  forEver : function(callback, context) {
    var i = 0;
    if (!isFunction(callback)) {
      return this.noop();
    }
    return {
      /**@ignore*/
      next : function() {
        var result = callback.call(context, i);
        try {
          if (!isFinite(++i) || i >= Number.MAX_VALUE) {
            throw 0;
          }
        } catch (ex) {
          i = 0;
        }
        return result;
      }
    };
  },
  /**
   * repeat.
   *
   * @private
   * @ignore
   */
  repeat : function(max, callback, context) {
    var i, loops, n, last;
    if (!isFunction(callback)) {
      return this.noop();
    }
    if (!max || max == null) {
      n = 0;
    } else if (isNumeric(max)) {
      n = max - 0;
    } else {
      n = max || {};
      if (isNumeric(n.start)) {
        n.begin = n.start;
      }
      if (isNumeric(n.stop)) {
        n.end = n.stop;
      }
    }
    loops = {
      begin : isNumeric(n.begin) ? n.begin - 0 : 0,
      end   : isNumeric(n.end)   ? n.end   - 0 : (n || 0) - 0,
      step  : isNumeric(n.step)  ? n.step  - 0 : 1,
      last  : false,
      prev  : null
    };
    i = loops.step ? loops.begin : loops.end;
    last = loops.end - loops.step;
    return {
      /**@ignore*/
      next : function() {
        var result;
        if (i < loops.end) {
          loops.last = (i >= last);
          result = callback.call(context, i, loops.last, loops);
          loops.prev = result;
        } else {
          throw PotStopIteration;
        }
        i += loops.step;
        return result;
      }
    };
  },
  /**
   * forLoop.
   *
   * @private
   * @ignore
   */
  forLoop : function(object, callback, context) {
    var copy, i = 0;
    if (!object || !object.length || !isFunction(callback)) {
      return this.noop();
    }
    copy = arrayize(object);
    return {
      /**@ignore*/
      next : function() {
        var val, result;
        while (true) {
          if (i >= copy.length) {
            throw PotStopIteration;
          }
          if (!(i in copy)) {
            i++;
            continue;
          }
          try {
            val = copy[i];
          } catch (e) {
            i++;
            continue;
          }
          result = callback.call(context, val, i, object);
          i++;
          return result;
        }
      }
    };
  },
  /**
   * forInLoop.
   *
   * @private
   * @ignore
   */
  forInLoop : function(object, callback, context) {
    var copy, i = 0;
    //XXX: Should use "yield" for duplicate loops.
    if (isFunction(callback)) {
      copy = [];
      each(object, function(value, prop) {
        copy[copy.length] = [value, prop];
      });
    }
    if (!copy || !copy.length) {
      return this.noop();
    }
    return {
      /**@ignore*/
      next : function() {
        var result, c, key, val;
        while (true) {
          if (i >= copy.length) {
            throw PotStopIteration;
          }
          if (!(i in copy)) {
            i++;
            continue;
          }
          try {
            c = copy[i];
            val = c[0];
            key = c[1];
          } catch (e) {
            i++;
            continue;
          }
          result = callback.call(context, val, key, object);
          i++;
          return result;
        }
      }
    };
  },
  /**
   * iterate.
   *
   * @private
   * @ignore
   */
  iterate : function(object, callback, context) {
    var that = this, iterable;
    if (Pot.isIterable(object) && !Pot.isIter(object)) {
      // using "yield" generator.
      if (isFunction(callback)) {
        return {
          /**@ignore*/
          next : function() {
            var res = object.next();
            that.result = callback.apply(context, arrayize(res));
            return that.result;
          }
        };
      } else {
        return {
          /**@ignore*/
          next : function() {
            that.result = object.next();
            return that.result;
          }
        };
      }
    } else {
      iterable = Iter.toIter(object);
      if (!isIter(iterable)) {
        return this.noop();
      }
      if (isFunction(callback)) {
        return {
          /**@ignore*/
          next : function() {
            var results = iterable.next();
            results = arrayize(results);
            while (results.length < 2) {
              results.push((void 0));
            }
            results.push(object);
            that.result = callback.apply(context, results);
            return that.result;
          }
        };
      } else {
        return {
          /**@ignore*/
          next : function() {
            that.result = iterable.next();
            return that.result;
          }
        };
      }
    }
  },
  /**
   * items format loop.
   *
   * @private
   * @ignore
   */
  items : function(object, callback, context) {
    var that = this, copy, i = 0, isPair;
    if (isObject(object)) {
      copy = [];
      each(object, function(ov, op) {
        copy[copy.length] = [op, ov];
      });
      isPair = true;
    } else if (isArrayLike(object)) {
      copy = arrayize(object);
    }
    if (!copy || !copy.length) {
      return this.noop();
    }
    if (isFunction(callback)) {
      return {
        /**@ignore*/
        next : function() {
          var result, c, key, val;
          while (true) {
            if (i >= copy.length) {
              throw PotStopIteration;
            }
            if (!(i in copy)) {
              i++;
              continue;
            }
            try {
              c = copy[i];
              if (isPair) {
                key = c[0];
                val = c[1];
              } else {
                key = i;
                val = c;
              }
            } catch (e) {
              i++;
              continue;
            }
            result = callback.call(context, [key, val], object);
            i++;
            that.result[that.result.length] = result;
            return result;
          }
        }
      };
    } else {
      return {
        /**@ignore*/
        next : function() {
          var r, t, k, v;
          while (true) {
            if (i >= copy.length) {
              throw PotStopIteration;
            }
            if (!(i in copy)) {
              i++;
              continue;
            }
            try {
              t = copy[i];
              if (isPair) {
                k = t[0];
                v = t[1];
              } else {
                k = i;
                v = t;
              }
            } catch (e) {
              i++;
              continue;
            }
            i++;
            r = [k, v];
            that.result[that.result.length] = r;
            return r;
          }
        }
      };
    }
  },
  /**
   * zip iteration.
   *
   * @private
   * @ignore
   */
  zip : function(object, callback, context) {
    var that = this, copy, i = 0, max;
    if (isArrayLike(object)) {
      copy = arrayize(object);
      max = copy.length;
    }
    if (!max || !copy || !copy.length) {
      return this.noop();
    }
    if (isFunction(callback)) {
      return {
        /**@ignore*/
        next : function() {
          var result, zips = [], j, item;
          for (j = 0; j < max; j++) {
            item = arrayize(copy[j]);
            if (!item || !item.length || i >= item.length) {
              throw PotStopIteration;
            }
            zips[zips.length] = item[i];
          }
          result = callback.call(context, zips, object);
          that.result[that.result.length] = result;
          i++;
          return result;
        }
      };
    } else {
      return {
        /**@ignore*/
        next : function() {
          var z = [], k, t;
          for (k = 0; k < max; k++) {
            t = arrayize(copy[k]);
            if (!t || !t.length || i >= t.length) {
              throw PotStopIteration;
            }
            z[z.length] = t[i];
          }
          that.result[that.result.length] = z;
          i++;
          return z;
        }
      };
    }
  }
});

LightIterator.fn.doit.prototype = LightIterator.fn;

// Update internal synchronous iteration.
update(LightIterator, {
  /**
   * @lends Pot.Internal.LightIterator
   */
  /**
   * Quick iteration for synchronous.
   *
   * @type Object
   * @class
   * @private
   * @ignore
   */
  QuickIteration : {
    /**
     * @lends Pot.Internal.LightIterator.QuickIteration
     */
    /**
     * @private
     * @ignore
     */
    resolve : function(iter) {
      var err;
      try {
        while (true) {
          iter.next();
        }
      } catch (e) {
        err = e;
        if (!isStopIter(err)) {
          throw err;
        }
      }
    },
    /**
     * @private
     * @ignore
     */
    forEach : function(object, callback, context) {
      var result, iter, that = LightIterator.fn;
      if (!object) {
        result = {};
      } else {
        result = object;
        if (isArrayLike(object)) {
          iter = that.forLoop(object, callback, context);
        } else {
          iter = that.forInLoop(object, callback, context);
        }
        QuickIteration.resolve(iter);
      }
      return result;
    },
    /**
     * @private
     * @ignore
     */
    repeat : function(max, callback, context) {
      var result = {}, iter, that = LightIterator.fn;
      if (max) {
        iter = that.repeat(max, callback, context);
        QuickIteration.resolve(iter);
      }
      return result;
    },
    /**
     * @private
     * @ignore
     */
    forEver : function(callback, context) {
      var result = {}, iter, that = LightIterator.fn;
      if (callback) {
        iter = that.forEver(callback, context);
        QuickIteration.resolve(iter);
      }
      return result;
    },
    /**
     * @private
     * @ignore
     */
    iterate : function(object, callback, context) {
      var result, iter, o, that = LightIterator.fn;
      if (!object) {
        result = {};
      } else {
        result = null;
        o = {
          noop   : that.noop,
          result : null
        };
        iter = that.iterate.call(o, object, callback, context);
        QuickIteration.resolve(iter);
        result = o.result;
      }
      return result;
    },
    /**
     * @private
     * @ignore
     */
    items : function(object, callback, context) {
      var result = [], iter, o, that = LightIterator.fn;
      if (object) {
        o = {
          noop   : that.noop,
          result : []
        };
        iter = that.items.call(o, object, callback, context);
        QuickIteration.resolve(iter);
        result = o.result;
      }
      return result;
    },
    /**
     * @private
     * @ignore
     */
    zip : function(object, callback, context) {
      var result = [], iter, o, that = LightIterator.fn;
      if (object) {
        o = {
          noop   : that.noop,
          result : []
        };
        iter = that.zip.call(o, object, callback, context);
        QuickIteration.resolve(iter);
        result = o.result;
      }
      return result;
    }
  }
});

QuickIteration = LightIterator.QuickIteration;
//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Define the main iterators.

// Temporary creation function.
update(PotTmp, {
  /**
   * @lends Pot.tmp
   */
  /**
   * @private
   * @ignore
   */
  createLightIterateConstructor : function(creator) {
    var
    name,
    /**@ignore*/
    create = function(speed) {
      var interval;
      if (LightIterator.speeds[speed] === void 0) {
        interval = LightIterator.defaults.speed;
      } else {
        interval = LightIterator.speeds[speed];
      }
      return creator(interval);
    },
    methods = {},
    construct = create();
    for (name in LightIterator.speeds) {
      methods[name] = create(name);
    }
    return update(construct, methods);
  }
});

createLightIterateConstructor = PotTmp.createLightIterateConstructor;

// Define the iterator functions to evaluate as synchronized.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Iterates as "for each" loop.
   *
   *
   * @desc
   * <pre>
   * Unlike Deferred, speed options affect to cutback count in loop.
   * Options append to after the forEach and execute it.
   *
   *  e.g.   Pot.forEach.slow(obj, function() {...})
   *
   * The available methods are below.
   * ------------------------------------
   *   method name   |  speed
   * ------------------------------------
   *      limp       :  slowest
   *      doze       :  slower
   *      slow       :  slow
   *      normal     :  normal (default)
   *      fast       :  fast
   *      rapid      :  faster
   *      ninja      :  fastest
   * ------------------------------------
   * </pre>
   *
   *
   * @example
   *   var a = 0;
   *   Pot.forEach([1, 2, 3], function(value) {
   *     a += value;
   *   });
   *   debug(a);
   *   // @results 6
   *
   *
   * @example
   *   var a = '';
   *   Pot.forEach({a:'foo', b:'bar'}, function(value, key) {
   *     a += key + '=' + value + ',';
   *   });
   *   debug(a);
   *   // @results 'a=foo,b=bar,'
   *
   *
   * @param  {Array|Object}  object    A target object.
   * @param  {Function}      callback  An iterable function.
   *                                     function(value, key, object)
   *                                       this == `context`.
   *                                   Throw Pot.StopIteration
   *                                     if you want to stop the loop.
   * @param  {*}            (context)  Optionally, context object. (i.e. this)
   * @result {Object}                  Return the object.
   * @class
   * @function
   * @static
   * @name Pot.forEach
   * @property {Function} limp   Iterates "for each" loop with slowest speed.
   * @property {Function} doze   Iterates "for each" loop with slower speed.
   * @property {Function} slow   Iterates "for each" loop with slow speed.
   * @property {Function} normal Iterates "for each" loop with default speed.
   * @property {Function} fast   Iterates "for each" loop with fast speed.
   * @property {Function} rapid  Iterates "for each" loop with faster speed.
   * @property {Function} ninja  Iterates "for each" loop with fastest speed.
   */
  forEach : createLightIterateConstructor(function(interval) {
    if (PotSystem.isWaitable &&
        interval < LightIterator.speeds.normal) {
      return function(object, callback, context) {
        var opts = {};
        opts.type = LightIterator.types.forLoop |
                    LightIterator.types.forInLoop;
        opts.interval = interval;
        opts.async = false;
        opts.context = context;
        return (new LightIterator(object, callback, opts)).result;
      };
    } else {
      return function(object, callback, context) {
        return QuickIteration.forEach(
          object, callback, context
        );
      };
    }
  }),
  /**
   * "repeat" loop iterates a specified number.
   *
   * The second argument of the callback function is
   *   passed the value to true only for the end of the loop.
   *
   * The first argument can pass as object
   *   that gives names "begin, end, step" any keys.
   *
   *
   * @example
   *   var a = [];
   *   Pot.repeat(10, function(i) {
   *     a.push(i);
   *   });
   *   debug(a);
   *   // @results [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
   *
   *
   * @example
   *   //
   *   // The second argument of the callback function is
   *   //  passed the value to true only for the end of the loop.
   *   //
   *   var s = '', a = 'abcdef'.split('');
   *   Pot.repeat(a.length, function(i, last) {
   *     s += a[i] + '=' + i + (last ? ';' : ',');
   *   });
   *   debug(s);
   *   // @results 'a=0,b=1,c=2,d=3,e=4,f=5;'
   *
   *
   * @example
   *   //
   *   // The first argument can pass as object
   *   //  that gives names "begin, end, step" any keys.
   *   //
   *   var a = [];
   *   Pot.repeat({begin: 0, end: 100, step: 10}, function(i) {
   *     a.push(i);
   *   });
   *   debug(a);
   *   // @results [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
   *
   *
   * @param  {Number|Object}  max       The maximum number of times to loop,
   *                                      or object.
   * @param  {Function}       callback  An iterable function.
   *                                    Throw Pot.StopIteration
   *                                      if you want to stop the loop.
   * @param  {*}             (context)  Optionally, context object. (i.e. this)
   * @class
   * @function
   * @static
   * @name Pot.repeat
   * @property {Function} limp   Iterates "repeat" loop with slowest speed.
   * @property {Function} doze   Iterates "repeat" loop with slower speed.
   * @property {Function} slow   Iterates "repeat" loop with slow speed.
   * @property {Function} normal Iterates "repeat" loop with default speed.
   * @property {Function} fast   Iterates "repeat" loop with fast speed.
   * @property {Function} rapid  Iterates "repeat" loop with faster speed.
   * @property {Function} ninja  Iterates "repeat" loop with fastest speed.
   */
  repeat : createLightIterateConstructor(function(interval) {
    if (PotSystem.isWaitable &&
        interval < LightIterator.speeds.normal) {
      return function(max, callback, context) {
        var opts = {};
        opts.type = LightIterator.types.repeat;
        opts.interval = interval;
        opts.async = false;
        opts.context = context;
        return (new LightIterator(max, callback, opts)).result;
      };
    } else {
      return function(max, callback, context) {
        return QuickIteration.repeat(
          max, callback, context
        );
      };
    }
  }),
  /**
   * Iterates indefinitely until "Pot.StopIteration" is thrown.
   *
   *
   * @example
   *   var s = '', a = 'abc*';
   *   Pot.forEver(function(i) {
   *     s += i + ':' + a;
   *     if (s.length > 50) {
   *       throw Pot.StopIteration;
   *     }
   *   });
   *   debug(s);
   *   // @results
   *   // '0:abc*1:abc*2:abc*3:abc*4:abc*5:abc*6:abc*7:abc*8:abc*'
   *
   *
   * @param  {Function}  callback   An iterable function.
   *                                Throw Pot.StopIteration
   *                                  if you want to stop the loop.
   * @param  {*}         (context)  Optionally, context object. (i.e. this)
   * @class
   * @function
   * @static
   * @name Pot.forEver
   * @property {Function} limp   Iterates "forEver" loop with slowest speed.
   * @property {Function} doze   Iterates "forEver" loop with slower speed.
   * @property {Function} slow   Iterates "forEver" loop with slow speed.
   * @property {Function} normal Iterates "forEver" loop with default speed.
   * @property {Function} fast   Iterates "forEver" loop with fast speed.
   * @property {Function} rapid  Iterates "forEver" loop with faster speed.
   * @property {Function} ninja  Iterates "forEver" loop with fastest speed.
   */
  forEver : createLightIterateConstructor(function(interval) {
    if (PotSystem.isWaitable &&
        interval < LightIterator.speeds.normal) {
      return function(callback, context) {
        var opts = {};
        opts.type = LightIterator.types.forEver;
        opts.interval = interval;
        opts.async = false;
        opts.context = context;
        return (new LightIterator(callback, null, opts)).result;
      };
    } else {
      return function(callback, context) {
        return QuickIteration.forEver(
          callback, context
        );
      };
    }
  }),
  /**
   * Iterate an iterable object. (using Pot.Iter)
   *
   * @param  {*}         object     An iterable object.
   * @param  {Function}  callback   An iterable function.
   *                                  function(value, key, object)
   *                                    this == `context`.
   *                                Throw Pot.StopIteration
   *                                  if you want to stop the loop.
   * @param  {Object}    (context)  Optionally, context object. (i.e. this)
   * @return {*}                    Result of iteration.
   * @class
   * @function
   * @static
   * @name Pot.iterate
   * @property {Function} limp   Iterates "iterate" loop with slowest speed.
   * @property {Function} doze   Iterates "iterate" loop with slower speed.
   * @property {Function} slow   Iterates "iterate" loop with slow speed.
   * @property {Function} normal Iterates "iterate" loop with default speed.
   * @property {Function} fast   Iterates "iterate" loop with fast speed.
   * @property {Function} rapid  Iterates "iterate" loop with faster speed.
   * @property {Function} ninja  Iterates "iterate" loop with fastest speed.
   */
  iterate : createLightIterateConstructor(function(interval) {
    if (PotSystem.isWaitable &&
        interval < LightIterator.speeds.normal) {
      return function(object, callback, context) {
        var opts = {};
        opts.type = LightIterator.types.iterate;
        opts.interval = interval;
        opts.async = false;
        opts.context = context;
        return (new LightIterator(object, callback, opts)).result;
      };
    } else {
      return function(object, callback, context) {
        return QuickIteration.iterate(
          object, callback, context
        );
      };
    }
  }),
  /**
   * Collect the object key and value and make array as items format.
   *
   *
   * @example
   *   var obj = {foo: 1, bar: 2, baz: 3};
   *   debug(items(obj));
   *   // @results [['foo', 1], ['bar', 2], ['baz', 3]]
   *
   *
   * @example
   *   var array = ['foo', 'bar', 'baz'];
   *   debug(items(array));
   *   // @results [[0, 'foo'], [1, 'bar'], [2, 'baz']]
   *
   *
   * @example
   *   // Example for using callback.
   *   var arr = ['foo', 'bar', 'baz'];
   *   var func = function(item) {
   *     return '(' + item[0] + ')' + item[1];
   *   };
   *   debug(items(arr, func));
   *   // @results ['(0)foo', '(1)bar', '(2)baz']
   *
   *
   * @example
   *   // Example for using callback.
   *   var obj = {foo: 1, bar: 2, baz: 3};
   *   var func = function(item) {
   *     return [item[0] + '::' + item[1]];
   *   };
   *   debug(items(obj, func));
   *   // @results [['foo::1'], ['bar::2'], ['baz::3']]
   *
   *
   * @param  {Object|Array}  object     The target object or an array.
   * @param  {Function}     (callback)  (Optional) Callback function.
   *                                      function({Array} item[, object])
   *                                        this == `context`.
   * @param  {*}            (context)   (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {Array}                    The collected items as an array.
   *
   * @class
   * @function
   * @static
   * @name Pot.items
   *
   * @property {Function} limp   Iterates "items" loop with slowest speed.
   * @property {Function} doze   Iterates "items" loop with slower speed.
   * @property {Function} slow   Iterates "items" loop with slow speed.
   * @property {Function} normal Iterates "items" loop with default speed.
   * @property {Function} fast   Iterates "items" loop with fast speed.
   * @property {Function} rapid  Iterates "items" loop with faster speed.
   * @property {Function} ninja  Iterates "items" loop with fastest speed.
   */
  items : createLightIterateConstructor(function(interval) {
    if (PotSystem.isWaitable &&
        interval < LightIterator.speeds.normal) {
      return function(object, callback, context) {
        var opts = {};
        opts.type = LightIterator.types.items;
        opts.interval = interval;
        opts.async = false;
        opts.context = context;
        return (new LightIterator(object, callback, opts)).result;
      };
    } else {
      return function(object, callback, context) {
        return QuickIteration.items(
          object, callback, context
        );
      };
    }
  }),
  /**
   * Create a new array which has the elements at
   *   position ith of the provided arrays.
   * This function is handled as seen from the longitudinal for array
   *   that is similar to the zip() function in Python.
   *
   * <pre>
   * Example:
   *
   *   arguments:  [[1, 2, 3],
   *                [4, 5, 6]]
   *
   *   results:    [[1, 4],
   *                [2, 5],
   *                [3, 6]]
   * </pre>
   *
   *
   * @link http://docs.python.org/library/functions.html#zip
   *
   *
   * @example
   *   var result = zip([[1, 2, 3], [4, 5, 6]]);
   *   debug(result);
   *   // @results
   *   //   [[1, 4], [2, 5], [3, 6]]
   *   //
   *
   *
   * @example
   *   var result = zip([[1, 2, 3], [1, 2, 3, 4, 5]]);
   *   debug(result);
   *   // @results
   *   //   [[1, 1], [2, 2], [3, 3]]
   *   //
   *
   *
   * @example
   *   var result = zip([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11]]);
   *   debug(result);
   *   // @results
   *   //   [[1, 4, 7, 10], [2, 5, 8, 11]]
   *   //
   *
   *
   * @example
   *   var result = zip(['hoge']);
   *   debug(result);
   *   // @results
   *   //   [['hoge']]
   *   //
   *
   *
   * @example
   *   var result = zip([[1], [2], [3]]);
   *   debug(result);
   *   // @results
   *   //   [[1, 2, 3]]
   *   //
   *
   *
   * @example
   *   var result = zip([[1, 2, 3], ['foo', 'bar', 'baz'], [4, 5]]);
   *   debug(result);
   *   // @results
   *   //   [[1, 'foo', 4], [2, 'bar', 5]]
   *   //
   *
   *
   * @example
   *   var callback = function(items) { return items[0] + items[1]; };
   *   var result = zip([[1, 2, 3], [4, 5, 6]], callback);
   *   debug(result);
   *   // @results [5, 7, 9]
   *
   *
   * @param  {Array}     object     An array to be combined.
   * @param  {Function} (callback)  (Optional) Callback function.
   *                                  function({Array} items[, {*} object])
   *                                    this == `context`.
   * @param  {*}        (context)   (Optional) Object to use
   *                                  as `this` when executing callback.
   * @return {Array}                A new array of arrays created from
   *                                  provided objects.
   *
   * @class
   * @function
   * @static
   * @name Pot.zip
   *
   * @property {Function} limp   Iterates "zip" loop with slowest speed.
   * @property {Function} doze   Iterates "zip" loop with slower speed.
   * @property {Function} slow   Iterates "zip" loop with slow speed.
   * @property {Function} normal Iterates "zip" loop with default speed.
   * @property {Function} fast   Iterates "zip" loop with fast speed.
   * @property {Function} rapid  Iterates "zip" loop with faster speed.
   * @property {Function} ninja  Iterates "zip" loop with fastest speed.
   */
  zip : createLightIterateConstructor(function(interval) {
    if (PotSystem.isWaitable &&
        interval < LightIterator.speeds.normal) {
      return function(object, callback, context) {
        var opts = {};
        opts.type = LightIterator.types.zip;
        opts.interval = interval;
        opts.async = false;
        opts.context = context;
        return (new LightIterator(object, callback, opts)).result;
      };
    } else {
      return function(object, callback, context) {
        return QuickIteration.zip(
          object, callback, context
        );
      };
    }
  })
});

// Define iterators for Deferred (Asynchronous)
update(Deferred, {
  /**
   * Iterates as "for each" loop. (Asynchronous)
   *
   * @desc
   * <pre>
   * Unlike Deferred, speed options affect to cutback count in loop.
   * Options append to after the forEach and execute it.
   *
   *  e.g.   Pot.Deferred.forEach.fast(obj, function() {...})
   *
   * The available methods are below.
   * ------------------------------------
   *   method name   |  speed
   * ------------------------------------
   *      limp       :  slowest
   *      doze       :  slower
   *      slow       :  slow
   *      normal     :  normal (default)
   *      fast       :  fast
   *      rapid      :  faster
   *      ninja      :  fastest
   * ------------------------------------
   * </pre>
   *
   * @param  {Array|Object}  object    A target object.
   * @param  {Function}      callback  An iterable function.
   *                                     function(value, key, object)
   *                                       this == `context`.
   *                                   Throw Pot.StopIteration
   *                                     if you want to stop the loop.
   * @param  {*}            (context)  Optionally, context object. (i.e. this)
   * @result {Deferred}                Return the Deferred.
   * @class
   * @function
   * @public
   * @type Function
   * @name Pot.Deferred.forEach
   * @property {Function} limp   Iterates "for each" loop with slowest speed.
   * @property {Function} doze   Iterates "for each" loop with slower speed.
   * @property {Function} slow   Iterates "for each" loop with slow speed.
   * @property {Function} normal Iterates "for each" loop with default speed.
   * @property {Function} fast   Iterates "for each" loop with fast speed.
   * @property {Function} rapid  Iterates "for each" loop with faster speed.
   * @property {Function} ninja  Iterates "for each" loop with fastest speed.
   */
  forEach : createLightIterateConstructor(function(interval) {
    return function(object, callback, context) {
      var opts = {};
      opts.type = LightIterator.types.forLoop |
                  LightIterator.types.forInLoop;
      opts.interval = interval;
      opts.async = true;
      opts.context = context;
      return (new LightIterator(object, callback, opts)).deferred;
    };
  }),
  /**
   * "repeat" loop iterates a specified number. (Asynchronous)
   *
   * @param  {Number|Object}  max       The maximum number of times to loop,
   *                                      or object.
   * @param  {Function}       callback  An iterable function.
   *                                    Throw Pot.StopIteration
   *                                      if you want to stop the loop.
   * @param  {*}             (context)  Optionally, context object. (i.e. this)
   * @return {Deferred}                 Return the Deferred.
   * @class
   * @function
   * @public
   * @type Function
   * @name Pot.Deferred.repeat
   * @property {Function} limp   Iterates "repeat" loop with slowest speed.
   * @property {Function} doze   Iterates "repeat" loop with slower speed.
   * @property {Function} slow   Iterates "repeat" loop with slow speed.
   * @property {Function} normal Iterates "repeat" loop with default speed.
   * @property {Function} fast   Iterates "repeat" loop with fast speed.
   * @property {Function} rapid  Iterates "repeat" loop with faster speed.
   * @property {Function} ninja  Iterates "repeat" loop with fastest speed.
   */
  repeat : createLightIterateConstructor(function(interval) {
    return function(max, callback, context) {
      var opts = {};
      opts.type = LightIterator.types.repeat;
      opts.interval = interval;
      opts.async = true;
      opts.context = context;
      return (new LightIterator(max, callback, opts)).deferred;
    };
  }),
  /**
   * Iterates indefinitely until "Pot.StopIteration" is thrown. (Asynchronous)
   *
   * @param  {Function}  callback   An iterable function.
   *                                Throw Pot.StopIteration
   *                                  if you want to stop the loop.
   * @param  {*}         (context)  Optionally, context object. (i.e. this)
   * @return {Deferred}             Return the Deferred.
   * @class
   * @function
   * @public
   * @type Function
   * @name Pot.Deferred.forEver
   * @property {Function} limp   Iterates "forEver" loop with slowest speed.
   * @property {Function} doze   Iterates "forEver" loop with slower speed.
   * @property {Function} slow   Iterates "forEver" loop with slow speed.
   * @property {Function} normal Iterates "forEver" loop with default speed.
   * @property {Function} fast   Iterates "forEver" loop with fast speed.
   * @property {Function} rapid  Iterates "forEver" loop with faster speed.
   * @property {Function} ninja  Iterates "forEver" loop with fastest speed.
   */
  forEver : createLightIterateConstructor(function(interval) {
    return function(callback, context) {
      var opts = {};
      opts.type = LightIterator.types.forEver;
      opts.interval = interval;
      opts.async = true;
      opts.context = context;
      return (new LightIterator(callback, null, opts)).deferred;
    };
  }),
  /**
   * Iterate an iterable object. (using Pot.Iter)
   *
   * @param  {*}         object     An iterable object.
   * @param  {Function}  callback   An iterable function.
   *                                  function(value, key, object)
   *                                    this == `context`.
   *                                Throw Pot.StopIteration
   *                                  if you want to stop the loop.
   * @param  {Object}    (context)  Optionally, context object. (i.e. this)
   * @return {Deferred}             Return the Deferred.
   * @class
   * @function
   * @public
   * @type Function
   * @name Pot.Deferred.iterate
   * @property {Function} limp   Iterates "iterate" loop with slowest speed.
   * @property {Function} doze   Iterates "iterate" loop with slower speed.
   * @property {Function} slow   Iterates "iterate" loop with slow speed.
   * @property {Function} normal Iterates "iterate" loop with default speed.
   * @property {Function} fast   Iterates "iterate" loop with fast speed.
   * @property {Function} rapid  Iterates "iterate" loop with faster speed.
   * @property {Function} ninja  Iterates "iterate" loop with fastest speed.
   */
  iterate : createLightIterateConstructor(function(interval) {
    return function(object, callback, context) {
      var opts = {};
      opts.type = LightIterator.types.iterate;
      opts.interval = interval;
      opts.async = true;
      opts.context = context;
      return (new LightIterator(object, callback, opts)).deferred;
    };
  }),
  /**
   * Collect the object key and value and make array as items format.
   *
   * @param  {Object|Array}  object     The target object or an array.
   * @param  {Function}     (callback)  (Optional) Callback function.
   *                                      function({Array} item[, object])
   *                                        this == `context`.
   * @param  {*}            (context)   (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {Deferred}                 Return a new instance of Deferred that
   *                                      has the collected items as an array.
   *
   * @class
   * @function
   * @public
   * @type Function
   * @name Pot.Deferred.items
   *
   * @property {Function} limp   Iterates "items" loop with slowest speed.
   * @property {Function} doze   Iterates "items" loop with slower speed.
   * @property {Function} slow   Iterates "items" loop with slow speed.
   * @property {Function} normal Iterates "items" loop with default speed.
   * @property {Function} fast   Iterates "items" loop with fast speed.
   * @property {Function} rapid  Iterates "items" loop with faster speed.
   * @property {Function} ninja  Iterates "items" loop with fastest speed.
   */
  items : createLightIterateConstructor(function(interval) {
    return function(object, callback, context) {
      var opts = {};
      opts.type = LightIterator.types.items;
      opts.interval = interval;
      opts.async = true;
      opts.context = context;
      return (new LightIterator(object, callback, opts)).deferred;
    };
  }),
  /**
   * Create a new array which has the elements at
   *   position ith of the provided arrays.
   * This function is handled as seen from the longitudinal for array
   *   that is similar to the zip() function in Python.
   *
   * <pre>
   * Example:
   *
   *   arguments:  [[1, 2, 3],
   *                [4, 5, 6]]
   *
   *   results:    [[1, 4],
   *                [2, 5],
   *                [3, 6]]
   * </pre>
   *
   * @link http://docs.python.org/library/functions.html#zip
   *
   * @param  {Array}     object     Objects to be combined.
   * @param  {Function} (callback)  (Optional) Callback function.
   *                                  function({Array} items[, {*} object])
   *                                    this == `context`.
   * @param  {*}        (context)   (Optional) Object to use
   *                                  as `this` when executing callback.
   * @return {Deferred}             Return a new instance of Deferred that has
   *                                  a new array of arrays created from
   *                                  provided objects.
   * @class
   * @function
   * @public
   * @type Function
   * @name Pot.Deferred.zip
   *
   * @property {Function} limp   Iterates "zip" loop with slowest speed.
   * @property {Function} doze   Iterates "zip" loop with slower speed.
   * @property {Function} slow   Iterates "zip" loop with slow speed.
   * @property {Function} normal Iterates "zip" loop with default speed.
   * @property {Function} fast   Iterates "zip" loop with fast speed.
   * @property {Function} rapid  Iterates "zip" loop with faster speed.
   * @property {Function} ninja  Iterates "zip" loop with fastest speed.
   */
  zip : createLightIterateConstructor(function(interval) {
    return function(object, callback, context) {
      var opts = {};
      opts.type = LightIterator.types.zip;
      opts.interval = interval;
      opts.async = true;
      opts.context = context;
      return (new LightIterator(object, callback, opts)).deferred;
    };
  })
});

delete PotTmp.createLightIterateConstructor;
//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Iter.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Iter.
   *
   * A Simple iterator.
   * Constructor.
   *
   * @param  {*}          Options.
   * @return {Pot.Iter}   Returns an instance of Pot.Iter
   *
   * @name  Pot.Iter
   * @class
   * @constructor
   * @public
   */
  Iter : function() {
    return isIter(this) ? this.init(arguments)
                        : new Iter.fn.init(arguments);
  }
});

// Refer the Pot properties/functions.
Iter = Pot.Iter;

// Definition of the prototype
Iter.fn = Iter.prototype = update(Iter.prototype, {
  /**
   * @lends Pot.Iter.prototype
   */
  /**
   * @ignore
   */
  constructor : Iter,
  /**
   * @private
   * @ignore
   */
  id : PotInternal.getMagicNumber(),
  /**
   * A unique strings.
   *
   * @type String
   * @private
   * @const
   */
  serial : null,
  /**
   * @private
   * @ignore
   * @const
   */
  NAME : 'Iter',
  /**
   * toString.
   *
   * @return  Return formatted string of object.
   * @type  Function
   * @function
   * @const
   * @static
   * @public
   */
  toString : PotToString,
  /**
   * isIter.
   *
   * @type Function
   * @function
   * @const
   * @static
   * @public
   */
  isIter : isIter,
  /**
   * Initialize properties.
   *
   * @private
   * @ignore
   */
  init : function(args) {
    if (!this.serial) {
      this.serial = buildSerial(this);
    }
    return this;
  },
  /**
   * Abstract function.
   *
   * Note: Firebug 1.7.x never shows the name of "next" method.
   *
   * @abstract
   * @type Function
   * @function
   * @public
   */
  next : function() {
    throw PotStopIteration;
  }
  /**
   * The property that implemented since JavaScript 1.7
   *   as the extended ECMAScript-3rd edition.
   *
   * @return  {Object}       Return the iterator object
   */
  //XXX: __iterator__ unimplemented for Object.prototype.__iterator__.
  //__iterator__ : function() {
  //  return this;
  //}
});

Iter.fn.init.prototype = Iter.fn;

// Define Iter object properties.
update(Iter, {
  /**
   * @lends Pot.Iter
   */
  /**
   * StopIteration.
   *
   * @type Object
   * @static
   * @const
   * @public
   */
  StopIteration : PotStopIteration,
  /**
   * Assign to an iterator from the argument object value.
   *
   * @param  {*}         x   An iterable object.
   * @return {Pot.Iter}      An iterator object instance.
   * @type Function
   * @function
   * @static
   * @public
   */
  toIter : function(x) {
    var iter, o, arrayLike, objectLike;
    if (isIter(x)) {
      return x;
    }
    arrayLike  = x && isArrayLike(x);
    objectLike = x && !arrayLike && isObject(x);
    if (objectLike) {
      o = [];
      each(x, function(xv, xp) {
        o[o.length] = [xv, xp];
      });
    } else {
      o = arrayize(x);
    }
    iter = new Iter();
    /**@ignore*/
    iter.next = (function() {
      var i = 0;
      if (objectLike) {
        return function() {
          var key, val, pair;
          while (true) {
            if (i >= o.length) {
              throw PotStopIteration;
            }
            if (!(i in o)) {
              i++;
              continue;
            }
            try {
              key = o[i][1];
              val = o[i][0];
            } catch (e) {
              i++;
              continue;
            }
            pair = [val, key];
            i++;
            return pair;
          }
        };
      } else {
        return function() {
          var value, result;
          while (true) {
            if (i >= o.length) {
              throw PotStopIteration;
            }
            if (!(i in o)) {
              i++;
              continue;
            }
            try {
              value = o[i];
            } catch (e) {
              i++;
              continue;
            }
            result = [value, i];
            i++;
            return result;
          }
        };
      }
    }());
    return iter;
  },
  /**
   * @private
   * @ignore
   */
  forEach : function(/*object, callback[, context]*/) {
    return Pot.iterate.apply(null, arguments);
  },
  /**
   * Creates a new object with the results of calling a
   *   provided function on every element in object.
   *
   * This method like Array.prototype.map
   *
   *
   * @example
   *   function fuzzyPlural(single) {
   *     return single.replace(/o/g, 'e');
   *   }
   *   var words = ['foot', 'goose', 'moose'];
   *   debug(Pot.Iter.map(words, fuzzyPlural));
   *   // @results ['feet', 'geese', 'meese']
   *
   *
   * @example
   *   var object = {foo: 'foo1', bar: 'bar2', baz: 'baz3'};
   *   var result = Pot.Iter.map(object, function(value, key) {
   *     return value + '00';
   *   });
   *   debug(result);
   *   // @results {foo: 'foo100', bar: 'bar200', baz: 'baz300'}
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {*}                        Return the result of each callbacks.
   * @type Function
   * @function
   * @static
   * @public
   */
  map : function(object, callback, context) {
    var result, arrayLike, objectLike, iterateDefer, it, iterable;
    iterateDefer = this && this.iterateSpeed;
    arrayLike  = object && isArrayLike(object);
    objectLike = object && !arrayLike && isObject(object);
    if (arrayLike) {
      result = [];
    } else if (objectLike) {
      result = {};
    } else {
      result = null;
    }
    iterable = iterateDefer || this && this.iterateSpeedSync || Pot.iterate;
    /**@ignore*/
    it = function() {
      return iterable(object, function(val, key, obj) {
        var res = callback.call(context, val, key, obj);
        if (isDeferred(res)) {
          return res.then(function(rv) {
            if (arrayLike) {
              result[result.length] = rv;
            } else if (objectLike) {
              result[key] = rv;
            } else {
              result = rv;
            }
          });
        } else {
          if (arrayLike) {
            result[result.length] = res;
          } else if (objectLike) {
            result[key] = res;
          } else {
            result = res;
          }
        }
      }, context);
    };
    if (iterateDefer) {
      return it().then(function() {
        return result;
      });
    } else {
      it();
      return result;
    }
  },
  /**
   * Creates a new object with all elements that
   *  pass the test implemented by the provided function.
   *
   * This method like Array.prototype.filter
   *
   *
   * @example
   *   function isBigEnough(value, index, array) {
   *     return (value >= 10);
   *   }
   *   var filtered = Pot.Iter.filter([12, 5, 8, 130, 44], isBigEnough);
   *   debug(filtered);
   *   // @results [12, 130, 44]
   *
   *
   * @example
   *   function isBigEnough(value, key, object) {
   *     return (value >= 10);
   *   }
   *   var object = {a: 1, b: 20, c: 7, d: 5, e: 27, f: 99};
   *   var result = Pot.Iter.filter(object, isBigEnough);
   *   debug(result);
   *   // @results {b: 20, e: 27, f: 99}
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {*}                        Return the result of each callbacks.
   * @type Function
   * @function
   * @static
   * @public
   */
  filter : (function() {
    /**@ignore*/
    var emptyFilter = function(a) { return a; };
    return function(object, callback, context) {
      var result, arrayLike, objectLike, iterateDefer, it, iterable, cb;
      cb = callback || emptyFilter;
      iterateDefer = this && this.iterateSpeed;
      arrayLike  = object && isArrayLike(object);
      objectLike = object && !arrayLike && isObject(object);
      if (arrayLike) {
        result = [];
      } else if (objectLike) {
        result = {};
      } else {
        result = null;
      }
      iterable = iterateDefer || this && this.iterateSpeedSync || Pot.iterate;
      /**@ignore*/
      it = function() {
        return iterable(object, function(val, key, obj) {
          var res = cb.call(context, val, key, obj);
          if (isDeferred(res)) {
            return res.then(function(rv) {
              if (rv) {
                if (arrayLike) {
                  result[result.length] = val;
                } else if (objectLike) {
                  result[key] = val;
                } else {
                  result = val;
                }
              }
            });
          } else {
            if (res) {
              if (arrayLike) {
                result[result.length] = val;
              } else if (objectLike) {
                result[key] = val;
              } else {
                result = val;
              }
            }
          }
        }, context);
      };
      if (iterateDefer) {
        return it().then(function() {
          return result;
        });
      } else {
        it();
        return result;
      }
    };
  }()),
  /**
   * Apply a function against an accumulator and each value of
   *  the object (from left-to-right) as to reduce it to a single value.
   *
   * This method like Array.prototype.reduce
   *
   *
   * @example
   *   var array = [1, 2, 3, 4, 5];
   *   var total = Pot.Iter.reduce(array, function(a, b) { return a + b; });
   *   debug(total);
   *   // @results 15
   *
   * @example
   *   var object = {a: 1, b: 2, c: 3};
   *   var total = Pot.Iter.reduce(object, function(a, b) { return a + b; });
   *   debug(total);
   *   // @results 6
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (initial)  An initial value passed as `callback`
   *                                      argument that will be used on
   *                                      first iteration.
   * @param  {*}             (context)  (Optional) Object to use as
   *                                      the first argument to the
   *                                      first call of the `callback`.
   * @return {*}                        Return the result of each callbacks.
   * @type Function
   * @function
   * @static
   * @public
   */
  reduce : function(object, callback, initial, context) {
    var arrayLike, objectLike, value, skip, iterateDefer, it, iterable;
    iterateDefer = this && this.iterateSpeed;
    arrayLike  = object && isArrayLike(object);
    objectLike = object && !arrayLike && isObject(object);
    if (initial === void 0) {
      /**@ignore*/
      value = (function() {
        var first;
        if (arrayLike || objectLike) {
          each(object, function(v) {
            first = v;
            throw PotStopIteration;
          });
        }
        return first;
      }());
    } else {
      value = initial;
    }
    skip = true;
    iterable = iterateDefer || this && this.iterateSpeedSync || Pot.iterate;
    /**@ignore*/
    it = function() {
      return iterable(object, function(val, key, obj) {
        var res;
        if (skip) {
          skip = false;
        } else {
          res = callback.call(context, value, val, key, obj);
          if (isDeferred(res)) {
            return res.then(function(rv) {
              value = rv;
            });
          } else {
            value = res;
          }
        }
      }, context);
    };
    if (iterateDefer) {
      return it().then(function() {
        return value;
      });
    } else {
      it();
      return value;
    }
  },
  /**
   * Tests whether all elements in the object pass the
   *  test implemented by the provided function.
   *
   * This method like Array.prototype.every
   *
   * @example
   *   function isBigEnough(value, index, array) {
   *     return (value >= 10);
   *   }
   *   var passed = Pot.Iter.every([12, 5, 8, 130, 44], isBigEnough);
   *   debug(passed);
   *   // passed is false
   *   passed = Pot.Iter.every([12, 54, 18, 130, 44], isBigEnough);
   *   debug(passed);
   *   // passed is true
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {Boolean}                  Return the Boolean result by callback.
   * @type Function
   * @function
   * @static
   * @public
   */
  every : function(object, callback, context) {
    var result = true, iterateDefer, it, iterable;
    iterateDefer = this && this.iterateSpeed;
    iterable = iterateDefer || this && this.iterateSpeedSync || Pot.iterate;
    /**@ignore*/
    it = function() {
      return iterable(object, function(val, key, obj) {
        var res = callback.call(context, val, key, obj);
        if (isDeferred(res)) {
          return res.then(function(rv) {
            if (!rv) {
              result = false;
              throw PotStopIteration;
            }
          });
        } else {
          if (!res) {
            result = false;
            throw PotStopIteration;
          }
        }
      }, context);
    };
    if (iterateDefer) {
      return it().then(function() {
        return result;
      });
    } else {
      it();
      return result;
    }
  },
  /**
   * Tests whether some element in the object passes the
   *  test implemented by the provided function.
   *
   * This method like Array.prototype.some
   *
   *
   * @example
   *   function isBigEnough(value, index, array) {
   *     return (value >= 10);
   *   }
   *   var passed = Pot.Iter.some([2, 5, 8, 1, 4], isBigEnough);
   *   debug(passed);
   *   // passed is false
   *   passed = Pot.Iter.some([12, 5, 8, 1, 4], isBigEnough);
   *   debug(passed);
   *   // passed is true
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {Boolean}                  Return the Boolean result by callback.
   * @type Function
   * @function
   * @static
   * @public
   */
  some : function(object, callback, context) {
    var result = false, iterateDefer, it, iterable;
    iterateDefer = this && this.iterateSpeed;
    iterable = iterateDefer || this && this.iterateSpeedSync || Pot.iterate;
    /**@ignore*/
    it = function() {
      return iterable(object, function(val, key, obj) {
        var res = callback.call(context, val, key, obj);
        if (isDeferred(res)) {
          return res.then(function(rv) {
            if (rv) {
              result = true;
              throw PotStopIteration;
            }
          });
        } else {
          if (res) {
            result = true;
            throw PotStopIteration;
          }
        }
      }, context);
    };
    if (iterateDefer) {
      return it().then(function() {
        return result;
      });
    } else {
      it();
      return result;
    }
  },
  /**
   * Create continuously array that
   *  has numbers between start number and end number.
   *
   * First argument can given an object that has "begin, end, step" any keys.
   *
   * This function can be a letter rather than just numbers.
   *
   * @example
   *   var numbers = Pot.Iter.range(1, 5);
   *   debug(numbers); // @results [1, 2, 3, 4, 5]
   *   var chars = Pot.Iter.range('a', 'f');
   *   debug(chars);   // @results ['a', 'b', 'c', 'd', 'e', 'f']
   *   var ranges = Pot.Iter.range({begin: 0, step: 10, end: 50});
   *   debug(ranges);  // @results [0, 10, 20, 30, 40, 50]
   *
   *
   * @param  {Number|Object}  end/begin  The end number or object.
   * @param  {Number}         (end)      (optinal) The end number.
   * @param  {Number}         (step)     (optinal) The step number.
   * @return {Array}                     Return an array result.
   * @type Function
   * @function
   * @static
   * @public
   */
  range : function(/*[begin,] end[, step]*/) {
    var args = arguments, arg, result = [],
        begin = 0,
        end   = 0,
        step  = 1,
        n, string, iter;
    switch (args.length) {
      case 0:
          return;
      case 1:
          arg = args[0];
          if (isObject(arg)) {
            if ('begin' in arg) {
              begin = arg.begin;
            } else if ('start' in arg) {
              begin = arg.start;
            }
            if ('end' in arg) {
              end = arg.end;
            } else if ('stop' in arg) {
              end = arg.stop;
            }
            if ('step' in arg) {
              step = arg.step;
            }
          } else {
            end = arg;
          }
          break;
      case 2:
          begin = args[0];
          end   = args[1];
          break;
      default:
          begin = args[0];
          end   = args[1];
          step  = args[2];
    }
    if (isString(begin) && begin.length === 1 &&
        isString(end)   && end.length   === 1) {
      begin  = begin.charCodeAt(0) || 0;
      end    = end.charCodeAt(0)   || 0;
      string = true;
    } else {
      begin  = begin - 0;
      end    = end   - 0;
      string = false;
    }
    step = step - 0;
    if (isNaN(begin) || isNaN(end) || isNaN(step) || step == 0) {
      return result;
    }
    if ((step > 0 && begin > end) ||
        (step < 0 && begin < end)) {
      n     = begin;
      begin = end;
      end   = n;
    }
    iter = new Iter();
    /**@ignore*/
    iter.next = function() {
      if ((step > 0 && begin > end) ||
          (step < 0 && begin < end)) {
        throw PotStopIteration;
      }
      result[result.length] = string ? fromUnicode(begin) : begin;
      begin += step;
    };
    Pot.iterate(iter);
    return result;
  },
  /**
   * Returns the first index at which a
   *  given element can be found in the object, or -1 if it is not present.
   *
   * This method like Array.prototype.indexOf
   *
   *
   * @example
   *   var array = [2, 5, 9];
   *   var index = Pot.Iter.indexOf(array, 2);
   *   // index is 0
   *   index = Pot.Iter.indexOf(array, 7);
   *   // index is -1
   *   var object = {a: 2, b: 5, c: 9};
   *   index = Pot.Iter.indexOf(object, 2);
   *   // index is 'a'
   *   index = Pot.Iter.indexOf(object, 7);
   *   // index is -1
   *
   *
   * @param  {Array|Object|*} object  A target object.
   * @param  {*}              subject A subject object.
   * @param  {*}              (from)  (Optional) The index at
   *                                    which to begin the search.
   *                                  Defaults to 0.
   * @return {Number|String}          Return the index of result, or -1.
   * @type Function
   * @function
   * @static
   * @public
   */
  indexOf : function(object, subject, from) {
    var result = -1, i, len, val, passed,
        args = arguments, argn = args.length,
        arrayLike = object && isArrayLike(object),
        objectLike = object && !arrayLike && isObject(object);
    if (arrayLike) {
      try {
        if (PotSystem.isBuiltinArrayIndexOf) {
          i = indexOf.apply(object, arrayize(args, 1));
          if (isNumeric(i)) {
            result = i;
          } else {
            throw i;
          }
        } else {
          throw i;
        }
      } catch (err) {
        len = (object && object.length) || 0;
        i = (+from) || 0;
        i = (i < 0) ? Math.ceil(i) : Math.floor(i);
        if (i < 0) {
          i += len;
        }
        for (; i < len; i++) {
          try {
            if (i in object) {
              val = object[i];
              if (val === subject) {
                result = i;
                break;
              }
            }
          } catch (e) {
            continue;
          }
        }
      }
    } else if (objectLike) {
      passed = false;
      each(object, function(ov, op) {
        if (!passed && argn >= 3 && from !== op) {
          return;
        } else {
          passed = true;
        }
        if (ov === subject) {
          result = op;
        }
      });
    } else if (object != null) {
      try {
        val = (object.toString && object.toString()) || String(object);
        result = StringProto.indexOf.apply(val, arrayize(args, 1));
      } catch (e) {
        result = -1;
      }
    } else {
      result = -1;
    }
    return result;
  },
  /**
   * Returns the last index at which a
   *  given element can be found in the object, or -1 if it is not present.
   *
   * This method like Array.prototype.lastIndexOf
   *
   *
   * @example
   *   debug('array');
   *   var index, array = [2, 5, 9, 2];
   *   index = Pot.Iter.lastIndexOf(array, 2);
   *   debug('index is 3 : result = ' + index);      // 3
   *   index = Pot.Iter.lastIndexOf(array, 7);
   *   debug('index is -1 : result = ' + index);     // -1
   *   index = Pot.Iter.lastIndexOf(array, 2, 3);
   *   debug('index is 3 : result = ' + index);      // 3
   *   index = Pot.Iter.lastIndexOf(array, 2, 2);
   *   debug('index is 0 : result = ' + index);      // 0
   *   index = Pot.Iter.lastIndexOf(array, 2, -2);
   *   debug('index is 0 : result = ' + index);      // 0
   *   index = Pot.Iter.lastIndexOf(array, 2, -1);
   *   debug('index is 3 : result = ' + index);      // 3
   *   debug('object');
   *   var object = {a: 2, b: 5, c: 9, d: 2};
   *   index = Pot.Iter.lastIndexOf(object, 2);
   *   debug('index is  d : result = ' + index);     // 'd'
   *   index = Pot.Iter.lastIndexOf(object, 7);
   *   debug('index is -1 : result = ' + index);     // -1
   *   index = Pot.Iter.lastIndexOf(object, 2, 'd'); // 'd'
   *   debug('index is  d : result = ' + index);
   *   index = Pot.Iter.lastIndexOf(object, 2, 'c'); // 'a'
   *   debug('index is  a : result = ' + index);
   *
   *
   * @param  {Array|Object|*} object  A target object.
   * @param  {*}              subject A subject object.
   * @param  {*}             (from)   (Optional) The index at which to
   *                                    start searching backwards.
   *                                  Defaults to the array's length.
   * @return {Number|String}          Return the index of result, or -1.
   * @type Function
   * @function
   * @static
   * @public
   */
  lastIndexOf : function(object, subject, from) {
    var result = -1, i, len,  key, val, passed, pairs,
        args = arguments,
        arrayLike  = object && isArrayLike(object),
        objectLike = object && !arrayLike && isObject(object);
    if (arrayLike) {
      try {
        if (PotSystem.isBuiltinArrayLastIndexOf) {
          i = lastIndexOf.apply(object, arrayize(args, 1));
          if (isNumeric(i)) {
            result = i;
          } else {
            throw i;
          }
        } else {
          throw i;
        }
      } catch (err) {
        len = (object && object.length) || 0;
        i = (+from);
        if (isNaN(i)) {
          i = len - 1;
        } else {
          i = (i < 0) ? Math.ceil(i) : Math.floor(i);
          if (i < 0) {
            i += len;
          } else if (i >= len) {
            i = len - 1;
          }
        }
        for (; i > -1; i--) {
          try {
            if (i in object) {
              val = object[i];
              if (val === subject) {
                result = i;
                break;
              }
            }
          } catch (e) {
            continue;
          }
        }
      }
    } else if (objectLike) {
      pairs = [];
      passed = false;
      each(object, function(ov, op) {
        pairs[pairs.length] = [op, ov];
        if (ov === subject) {
          result = op;
        }
        if (op === from) {
          passed = true;
          throw PotStopIteration;
        }
      });
      if (passed) {
        result = -1;
        len = pairs.length;
        while (--len >= 0) {
          key = pairs[len][0];
          val = pairs[len][1];
          if (val === subject) {
            result = key;
            break;
          }
        }
      }
    } else if (object != null) {
      try {
        val = (object.toString && object.toString()) || String(object);
        result = StringProto.lastIndexOf.apply(val, arrayize(args, 1));
      } catch (e) {
        result = -1;
      }
    } else {
      result = -1;
    }
    return result;
  }
});

// Update methods for reference.
Pot.update({
  toIter : Iter.toIter
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Update the Pot.Deferred object for iterators.

// Extends the Pot.Deferred object for iterators with speed.
update(PotTmp, {
  /**
   * @private
   * @ignore
   */
  createIterators : function(iters) {
    each(iters, function(iter) {
      var o = {};
      /**@ignore*/
      o[iter.NAME] = function() {
        var me = {}, args = arrayize(arguments);
        me.iterateSpeed = (this && this.iterateSpeed) || Deferred.iterate;
        return Deferred.begin(function() {
          var d = new Deferred();
          iter.method.apply(me, args).then(function(res) {
            d.begin(res);
          }, function(err) {
            d.raise(err);
          });
          return d;
        });
      };
      update(Deferred, o);
      Deferred.extendSpeeds(Deferred, iter.NAME, function(opts) {
        var me = {}, args = arrayize(arguments, 1);
        me.iterateSpeed = Deferred.iterate[opts.speedName];
        return Deferred.begin(function() {
          var d = new Deferred();
          iter.method.apply(me, args).then(function(res) {
            d.begin(res);
          }, function(err) {
            d.raise(err);
          });
          return d;
        });
      }, LightIterator.speeds);
    });
  },
  /**
   * @private
   * @ignore
   */
  createProtoIterators : function(iters) {
    each(iters, function(iter) {
      var o = {}, sp = {};
      /**@ignore*/
      o[iter.NAME] = function() {
        var args = arrayize(arguments), options = update({}, this.options);
        return this.then(function(value) {
          var d = new Deferred();
          args = iter.args(value, args);
          iter.method.apply(iter.context, args).ensure(function(res) {
            extendDeferredOptions(d, options);
            if (isError(res)) {
              d.raise(res);
            } else {
              d.begin(res);
            }
          });
          return d;
        });
      };
      update(Deferred.fn, o);
      if (iter.speed) {
        if (iter.iterable) {
          /**@ignore*/
          sp.methods = function(speed) {
            return {
              iter    : iter.iterable[speed],
              context : iter.context
            };
          };
        } else {
          /**@ignore*/
          sp.methods = function(speed) {
            return {
              iter    : iter.method,
              context : {iterateSpeed : iter.context.iterateSpeed[speed]}
            };
          };
        }
        Deferred.extendSpeeds(Deferred.fn, iter.NAME, function(opts) {
          var args = arrayize(arguments, 1),
              iterable = sp.methods(opts.speedName),
              options  = update({}, this.options);
          return this.then(function(value) {
            var d = new Deferred();
            args = iter.args(value, args);
            iterable.iter.apply(iterable.context, args).ensure(function(res) {
              extendDeferredOptions(d, options);
              if (isError(res)) {
                d.raise(res);
              } else {
                d.begin(res);
              }
            });
            return d;
          });
        }, LightIterator.speeds);
      }
    });
  },
  /**
   * @private
   * @ignore
   */
  createSyncIterator : function(creator) {
    var methods, construct,
        /**@ignore*/
        create = function(speed) {
          var key = speed;
          if (!key) {
            each(LightIterator.speeds, function(v, k) {
              if (v === LightIterator.defaults.speed) {
                key = k;
                throw PotStopIteration;
              }
            });
          }
          return creator(key);
        };
    construct = create();
    methods = {};
    each(LightIterator.speeds, function(v, k) {
      methods[k] = create(k);
    });
    return update(construct, methods);
  }
});

// Create iterators to Pot.Deferred.
PotTmp.createIterators([{
  /**
   * Creates a new object with the results of calling a
   *   provided function on every element in object.
   *
   * Iteration will use the results of the previous chain.
   *
   * This method like Array.prototype.map
   *
   *
   * @example
   *   var words = ['foot', 'goose', 'moose'];
   *   Pot.Deferred.map(words, function(word) {
   *     return word.replace(/o/g, 'e');
   *   }).then(function(result) {
   *     debug(result);
   *   });
   *   // @results result = ['feet', 'geese', 'meese']
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {*}                        Return the result of each callbacks.
   * @name   Pot.Deferred.map
   * @type   Function
   * @class
   * @function
   * @static
   * @public
   *
   * @property {Function} limp   Iterates "map" loop with slowest speed.
   * @property {Function} doze   Iterates "map" loop with slower speed.
   * @property {Function} slow   Iterates "map" loop with slow speed.
   * @property {Function} normal Iterates "map" loop with default speed.
   * @property {Function} fast   Iterates "map" loop with fast speed.
   * @property {Function} rapid  Iterates "map" loop with faster speed.
   * @property {Function} ninja  Iterates "map" loop with fastest speed.
   */
  NAME   : 'map',
  /**@ignore*/
  method : Iter.map
}, {
  /**
   * Creates a new object with all elements that
   *  pass the test implemented by the provided function.
   *
   * Iteration will use the results of the previous chain.
   *
   * This method like Array.prototype.filter
   *
   *
   * @example
   *   var numbers = [12, 5, 8, 130, 44];
   *   Pot.Deferred.filter(numbers, function(value, index, array) {
   *     return (value >= 10);
   *   }).then(function(result) {
   *     debug(result);
   *   });
   *   // @results result = [12, 130, 44]
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {*}                        Return the result of each callbacks.
   * @name   Pot.Deferred.filter
   * @type   Function
   * @class
   * @function
   * @static
   * @public
   *
   * @property {Function} limp   Iterates "filter" loop with slowest speed.
   * @property {Function} doze   Iterates "filter" loop with slower speed.
   * @property {Function} slow   Iterates "filter" loop with slow speed.
   * @property {Function} normal Iterates "filter" loop with default speed.
   * @property {Function} fast   Iterates "filter" loop with fast speed.
   * @property {Function} rapid  Iterates "filter" loop with faster speed.
   * @property {Function} ninja  Iterates "filter" loop with fastest speed.
   */
  NAME   : 'filter',
  /**@ignore*/
  method : Iter.filter
}, {
  /**
   * Apply a function against an accumulator and each value of
   *  the object (from left-to-right) as to reduce it to a single value.
   *
   * Iteration will use the results of the previous chain.
   *
   * This method like Array.prototype.reduce
   *
   *
   * @example
   *   var numbers = [1, 2, 3, 4, 5];
   *   Pot.Deferred.reduce(numbers, function(a, b) {
   *     return a + b;
   *   }).then(function(result) {
   *     debug(result);
   *   });
   *   // @results result = 15
   *
   *
   * @param  {Array|Object|*}  object     A target object.
   * @param  {Function}        callback   A callback function.
   * @param  {*}               initial    An initial value passed as
   *                                        `callback` argument that
   *                                        will be used on
   *                                        first iteration.
   * @param  {*}              (context)   (Optional) Object to use as
   *                                        the first argument to the
   *                                        first call of the `callback`.
   * @return {*}                          Return the result of each callbacks.
   * @name   Pot.Deferred.reduce
   * @type   Function
   * @class
   * @function
   * @static
   * @public
   *
   * @property {Function} limp   Iterates "reduce" loop with slowest speed.
   * @property {Function} doze   Iterates "reduce" loop with slower speed.
   * @property {Function} slow   Iterates "reduce" loop with slow speed.
   * @property {Function} normal Iterates "reduce" loop with default speed.
   * @property {Function} fast   Iterates "reduce" loop with fast speed.
   * @property {Function} rapid  Iterates "reduce" loop with faster speed.
   * @property {Function} ninja  Iterates "reduce" loop with fastest speed.
   */
  NAME   : 'reduce',
  /**@ignore*/
  method : Iter.reduce
}, {
  /**
   * Tests whether all elements in the object pass the
   *  test implemented by the provided function.
   *
   * Iteration will use the results of the previous chain.
   *
   * This method like Array.prototype.every
   *
   * @example
   *   var numbers = [12, 5, 8, 130, 44];
   *   Pot.Deferred.every(numbers, function(value, index, array) {
   *     return (value >= 10);
   *   }).then(function(result) {
   *     debug(result);
   *     // @results false
   *   });
   *
   * @example
   *   var numbers = [12, 54, 18, 130, 44];
   *   Pot.Deferred.every(numbers, function(value, index, array) {
   *     return (value >= 10);
   *   }).then(function(result) {
   *     debug(result);
   *     // @results true
   *   });
   *
   * @param  {Array|Object|*}  object      A target object.
   * @param  {Function}        callback    A callback function.
   * @param  {*}               (context)   (Optional) Object to use as
   *                                         `this` when executing callback.
   * @return {Boolean}                     Return the Boolean result
   *                                          by callback.
   * @name   Pot.Deferred.every
   * @type   Function
   * @class
   * @function
   * @static
   * @public
   *
   * @property {Function} limp   Iterates "every" loop with slowest speed.
   * @property {Function} doze   Iterates "every" loop with slower speed.
   * @property {Function} slow   Iterates "every" loop with slow speed.
   * @property {Function} normal Iterates "every" loop with default speed.
   * @property {Function} fast   Iterates "every" loop with fast speed.
   * @property {Function} rapid  Iterates "every" loop with faster speed.
   * @property {Function} ninja  Iterates "every" loop with fastest speed.
   */
  NAME   : 'every',
  /**@ignore*/
  method : Iter.every
}, {
  /**
   * Tests whether some element in the object passes the
   *  test implemented by the provided function.
   *
   * Iteration will use the results of the previous chain.
   *
   * This method like Array.prototype.some
   *
   *
   * @example
   *   var numbers = [2, 5, 8, 1, 4];
   *   Pot.Deferred.some(numbers, function(value, index, array) {
   *     return (value >= 10);
   *   }).then(function(result) {
   *     debug(result);
   *     // @results false
   *   });
   *
   * @example
   *   var numbers = [12, 5, 8, 1, 4];
   *   Pot.Deferred.some(numbers, function(value, index, array) {
   *     return (value >= 10);
   *   }).then(function(result) {
   *     debug(result);
   *     // @results true
   *   });
   *
   *
   * @param  {Array|Object|*}  object      A target object.
   * @param  {Function}        callback    A callback function.
   * @param  {*}               (context)   (Optional) Object to use as
   *                                         `this` when executing callback.
   * @return {Boolean}                     Return the Boolean result by
   *                                         callback.
   * @name   Pot.Deferred.some
   * @type   Function
   * @class
   * @function
   * @static
   * @public
   *
   * @property {Function} limp   Iterates "some" loop with slowest speed.
   * @property {Function} doze   Iterates "some" loop with slower speed.
   * @property {Function} slow   Iterates "some" loop with slow speed.
   * @property {Function} normal Iterates "some" loop with default speed.
   * @property {Function} fast   Iterates "some" loop with fast speed.
   * @property {Function} rapid  Iterates "some" loop with faster speed.
   * @property {Function} ninja  Iterates "some" loop with fastest speed.
   */
  NAME   : 'some',
  /**@ignore*/
  method : Iter.some
}]);

// Create iterators to Pot.Deferred.prototype.
PotTmp.createProtoIterators([{
  /**
   * Iterates as "for each" loop. (Asynchronous)
   *
   * Iteration will use the results of the previous chain.
   *
   * @desc
   * <pre>
   * Unlike Deferred, speed options affect to cutback count in loop.
   * Options append to after the forEach and execute it.
   *
   *  e.g. d.forEach.slow(function() {...}).then(function() {...})
   *
   * The available methods are below.
   * ------------------------------------
   *   method name   |  speed
   * ------------------------------------
   *      limp       :  slowest
   *      doze       :  slower
   *      slow       :  slowly
   *      normal     :  normal (default)
   *      fast       :  fast
   *      rapid      :  faster
   *      ninja      :  fastest
   * ------------------------------------
   * </pre>
   *
   *
   * @example
   *   var elems = document.getElementsByTagName('*');
   *   var defer = new Pot.Deferred();
   *   var alpha = 1;
   *   defer.forEach.slow(function(elem, i, elems) {
   *     alpha -= 0.02;
   *     if (alpha < 0.02) {
   *       alpha = 0.02;
   *     }
   *     elem.style.opacity = alpha;
   *   }).wait(5).forEach(function(elem, i, elems) {
   *     elem.style.opacity = 1;
   *   }).then(function() {
   *     debug('end');
   *   }).begin(elems);
   *
   *
   * @param  {Function}   callback   An iterable function.
   *                                   function(value, key, object)
   *                                     this == `context`.
   *                                 Throw Pot.StopIteration
   *                                   if you want to stop the loop.
   * @param  {*}          (context)  Optionally, context object. (i.e. this)
   * @result {Deferred}              Return the Deferred.
   *
   * @name  Pot.Deferred.prototype.forEach
   * @class
   * @public
   *
   * @property {Function} limp   Iterates "for each" loop with slowest speed.
   * @property {Function} doze   Iterates "for each" loop with slower speed.
   * @property {Function} slow   Iterates "for each" loop with slow speed.
   * @property {Function} normal Iterates "for each" loop with default speed.
   * @property {Function} fast   Iterates "for each" loop with fast speed.
   * @property {Function} rapid  Iterates "for each" loop with faster speed.
   * @property {Function} ninja  Iterates "for each" loop with fastest speed.
   */
  NAME : 'forEach',
  /**
   * @ignore
   */
  method : Deferred.forEach,
  /**
   * @ignore
   */
  context : null,
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : Deferred.forEach,
  /**
   * @ignore
   */
  args : function(arg, args) {
    return [arg].concat(args);
  }
}, {
  /**
   * "repeat" loop iterates a specified number. (Asynchronous)
   *
   * If you specify the first argument as a function
   *  then the results of the previous chain will be used.
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   var p = document.getElementsByTagName('p');
   *   d.repeat(p.length, function(i, last) {
   *     p[i].innerHTML += last ? 'end' : i;
   *   }).then(function() {
   *     debug('finish');
   *   }).begin();
   *
   *
   * @param  {Number|Object}  (max)     The maximum number of times to loop,
   *                                      or object.
   * @param  {Function}       callback  An iterable function.
   *                                    Throw Pot.StopIteration
   *                                      if you want to stop the loop.
   * @param  {*}             (context)  Optionally, context object. (i.e. this)
   * @return {Deferred}                 Return the Deferred.
   *
   * @name  Pot.Deferred.prototype.repeat
   * @class
   * @public
   * 
   * @property {Function} limp   Iterates "repeat" loop with slowest speed.
   * @property {Function} doze   Iterates "repeat" loop with slower speed.
   * @property {Function} slow   Iterates "repeat" loop with slow speed.
   * @property {Function} normal Iterates "repeat" loop with default speed.
   * @property {Function} fast   Iterates "repeat" loop with fast speed.
   * @property {Function} rapid  Iterates "repeat" loop with faster speed.
   * @property {Function} ninja  Iterates "repeat" loop with fastest speed.
   */
  NAME : 'repeat',
  /**
   * @ignore
   */
  method : Deferred.repeat,
  /**
   * @ignore
   */
  context : null,
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : Deferred.repeat,
  /**
   * @ignore
   */
  args : function(arg, args) {
    if (isNumeric(arg)) {
      return [arg - 0].concat(args);
    }
    if (arg && isNumber(arg.length)) {
      return [arg.length].concat(args);
    }
    if (arg && isObject(arg) &&
        ('end'  in arg || 'begin' in arg || 'step' in arg ||
         'stop' in arg || 'start' in arg)) {
      return [arg].concat(args);
    }
    return args;
  }
}, {
  /**
   * Iterates indefinitely until "Pot.StopIteration" is thrown. (Asynchronous)
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   var s = '';
   *   d.forEver(function(i) {
   *     s += 'i=' + i + ',';
   *     if (s.length > 25) {
   *       throw Pot.StopIteration;
   *     }
   *   }).then(function() {
   *     debug(s);
   *   }).begin();
   *   // @results  s = 'i=0,i=1,i=2,i=3,i=4,i=5,i=6,'
   *
   *
   * @param  {Function}  callback   An iterable function.
   *                                Throw Pot.StopIteration
   *                                  if you want to stop the loop.
   * @param  {*}         (context)  Optionally, context object. (i.e. this)
   * @return {Deferred}             Return the Deferred.
   *
   * @name  Pot.Deferred.prototype.forEver
   * @class
   * @public
   *
   * @property {Function} limp   Iterates "forEver" loop with slowest speed.
   * @property {Function} doze   Iterates "forEver" loop with slower speed.
   * @property {Function} slow   Iterates "forEver" loop with slow speed.
   * @property {Function} normal Iterates "forEver" loop with default speed.
   * @property {Function} fast   Iterates "forEver" loop with fast speed.
   * @property {Function} rapid  Iterates "forEver" loop with faster speed.
   * @property {Function} ninja  Iterates "forEver" loop with fastest speed.
   */
  NAME : 'forEver',
  /**
   * @ignore
   */
  method : Deferred.forEver,
  /**
   * @ignore
   */
  context : null,
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : Deferred.forEver,
  /**
   * @ignore
   */
  args : function(arg, args) {
    return args;
  }
}, {
  /**
   * Iterate an iterable object that is previous chain result.
   *
   * Iteration will use the results of the previous chain.
   *
   * @param  {Function}  callback   An iterable function.
   *                                  function(value, key, object)
   *                                    this == `context`.
   *                                Throw Pot.StopIteration
   *                                  if you want to stop the loop.
   * @param  {Object}    (context)  Optionally, context object. (i.e. this)
   * @return {Deferred}             Return the Deferred.
   *
   * @name  Pot.Deferred.prototype.iterate
   * @class
   * @public
   *
   * @property {Function} limp   Iterates "iterate" loop with slowest speed.
   * @property {Function} doze   Iterates "iterate" loop with slower speed.
   * @property {Function} slow   Iterates "iterate" loop with slow speed.
   * @property {Function} normal Iterates "iterate" loop with default speed.
   * @property {Function} fast   Iterates "iterate" loop with fast speed.
   * @property {Function} rapid  Iterates "iterate" loop with faster speed.
   * @property {Function} ninja  Iterates "iterate" loop with fastest speed.
   */
  NAME : 'iterate',
  /**
   * @ignore
   */
  method : Deferred.iterate,
  /**
   * @ignore
   */
  context : null,
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : Deferred.iterate,
  /**
   * @ignore
   */
  args : function(arg, args) {
    return [arg].concat(args);
  }
}, {
  /**
   * Collect the object key and value and make array as items format.
   *
   *
   * @example
   *   var obj = {foo: 1, bar: 2, baz: 3};
   *   var d = new Deferred();
   *   d.items().then(function(res) {
   *     debug(res);
   *     // @results [['foo', 1], ['bar', 2], ['baz', 3]]
   *   }).begin(obj);
   *
   *
   * @example
   *   var array = ['foo', 'bar', 'baz'];
   *   var d = new Deferred();
   *   d.items().then(function(res) {
   *     debug(res);
   *     // @results [[0, 'foo'], [1, 'bar'], [2, 'baz']]
   *   }).begin(array);
   *
   *
   * @example
   *   // Example for using callback.
   *   var arr = ['foo', 'bar', 'baz'];
   *   var func = function(item) {
   *     return '(' + item[0] + ')' + item[1];
   *   };
   *   var d = new Deferred();
   *   d.items(func).then(function(res) {
   *     debug(res);
   *     // @results ['(0)foo', '(1)bar', '(2)baz']
   *   }).begin(arr);
   *
   *
   * @example
   *   // Example for using callback.
   *   var obj = {foo: 1, bar: 2, baz: 3};
   *   var func = function(item) {
   *     return [item[0] + '::' + item[1]];
   *   };
   *   var d = new Deferred();
   *   d.items(func).then(function(res) {
   *     debug(res);
   *     // @results [['foo::1'], ['bar::2'], ['baz::3']]
   *   }).begin(obj);
   *
   *
   * @param  {Function}     (callback)  (Optional) Callback function.
   *                                      function({Array} item[, object])
   *                                        this == `context`.
   * @param  {*}            (context)   (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {Array}                    The collected items as an array.
   *
   * @name  Pot.Deferred.prototype.items
   * @class
   * @public
   *
   * @property {Function} limp   Iterates "items" loop with slowest speed.
   * @property {Function} doze   Iterates "items" loop with slower speed.
   * @property {Function} slow   Iterates "items" loop with slow speed.
   * @property {Function} normal Iterates "items" loop with default speed.
   * @property {Function} fast   Iterates "items" loop with fast speed.
   * @property {Function} rapid  Iterates "items" loop with faster speed.
   * @property {Function} ninja  Iterates "items" loop with fastest speed.
   */
  NAME : 'items',
  /**
   * @ignore
   */
  method : Deferred.items,
  /**
   * @ignore
   */
  context : null,
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : Deferred.items,
  /**
   * @ignore
   */
  args : function(arg, args) {
    return [arg].concat(args);
  }
}, {
  /**
   * Create a new array which has the elements at
   *   position ith of the provided arrays.
   * This function is handled as seen from the longitudinal for array
   *   that is similar to the zip() function in Python.
   *
   * <pre>
   * Example:
   *
   *   arguments:  [[1, 2, 3],
   *                [4, 5, 6]]
   *
   *   results:    [[1, 4],
   *                [2, 5],
   *                [3, 6]]
   * </pre>
   *
   *
   * @link http://docs.python.org/library/functions.html#zip
   *
   *
   * @example
   *   var d = new Deferred();
   *   d.then(function() {
   *     return [[1, 2, 3], [4, 5, 6]];
   *   }).zip().then(function(res) {
   *     debug(res);
   *     // @results
   *     //     [[1, 4], [2, 5], [3, 6]]
   *     //
   *   }).begin();
   *
   *
   * @example
   *   var d = new Deferred();
   *   d.then(function() {
   *     return [[1, 2, 3], [1, 2, 3, 4, 5]];
   *   }).zip().then(function(res) {
   *     debug(res);
   *     // @results
   *     //     [[1, 1], [2, 2], [3, 3]]
   *     //
   *   }).begin();
   *
   *
   * @example
   *   var d = new Deferred();
   *   d.then(function() {
   *     return [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11]];
   *   }).zip().then(function(res) {
   *     debug(res);
   *     // @results
   *     //     [[1, 4, 7, 10], [2, 5, 8, 11]]
   *     //
   *   }).begin();
   *
   *
   * @example
   *   begin(function() {
   *     return ['hoge'];
   *   }).zip().then(function(res) {
   *     debug(res);
   *     // @results
   *     //     [['hoge']]
   *     //
   *   });
   *
   *
   * @example
   *   begin(function() {
   *     return [[1], [2], [3]];
   *   }).zip().then(function(res) {
   *     debug(res);
   *     // @results
   *     //     [[1, 2, 3]]
   *     //
   *   });
   *
   *
   * @example
   *   begin(function() {
   *     return [[1, 2, 3], ['foo', 'bar', 'baz'], [4, 5]];
   *   }).zip().then(function(res) {
   *     debug(res);
   *     // @results
   *     //     [[1, 'foo', 4], [2, 'bar', 5]]
   *     //
   *   });
   *
   *
   * @example
   *   var callback = function(items) { return items[0] + items[1]; };
   *   begin(function() {
   *     return [[1, 2, 3], [4, 5, 6]];
   *   }).zip(callback).then(function(res) {
   *     debug(res);
   *     // @results [5, 7, 9]
   *   });
   *
   *
   * @param  {Function} (callback)  (Optional) Callback function.
   *                                  function({Array} items[, {*} object])
   *                                    this == `context`.
   * @param  {*}        (context)   (Optional) Object to use
   *                                  as `this` when executing callback.
   * @return {Array}                A new array of arrays created from
   *                                  provided objects.
   *
   * @name  Pot.Deferred.prototype.zip
   * @class
   * @public
   *
   * @property {Function} limp   Iterates "zip" loop with slowest speed.
   * @property {Function} doze   Iterates "zip" loop with slower speed.
   * @property {Function} slow   Iterates "zip" loop with slow speed.
   * @property {Function} normal Iterates "zip" loop with default speed.
   * @property {Function} fast   Iterates "zip" loop with fast speed.
   * @property {Function} rapid  Iterates "zip" loop with faster speed.
   * @property {Function} ninja  Iterates "zip" loop with fastest speed.
   */
  NAME : 'zip',
  /**
   * @ignore
   */
  method : Deferred.zip,
  /**
   * @ignore
   */
  context : null,
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : Deferred.zip,
  /**
   * @ignore
   */
  args : function(arg, args) {
    return [arg].concat(args);
  }
}, {
  /**
   * Creates a new object with the results of calling a
   *   provided function on every element in chains result.
   *
   * Iteration will use the results of the previous chain.
   *
   * This method like Array.prototype.map
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     return ['foot', 'goose', 'moose'];
   *   }).map(function(word) {
   *     return word.replace(/o/g, 'e');
   *   }).then(function(result) {
   *     debug(result);
   *   }).begin();
   *   // @results result = ['feet', 'geese', 'meese']
   *
   *
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {*}                        Return the result of each callbacks.
   *
   * @name  Pot.Deferred.prototype.map
   * @class
   * @public
   *
   * @property {Function} limp   Iterates "map" loop with slowest speed.
   * @property {Function} doze   Iterates "map" loop with slower speed.
   * @property {Function} slow   Iterates "map" loop with slow speed.
   * @property {Function} normal Iterates "map" loop with default speed.
   * @property {Function} fast   Iterates "map" loop with fast speed.
   * @property {Function} rapid  Iterates "map" loop with faster speed.
   * @property {Function} ninja  Iterates "map" loop with fastest speed.
   */
  NAME : 'map',
  /**
   * @ignore
   */
  method : Iter.map,
  /**
   * @ignore
   */
  context : {iterateSpeed : Deferred.iterate},
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : null,
  /**
   * @ignore
   */
  args : function(arg, args) {
    return [arg].concat(args);
  }
}, {
  /**
   * Creates a new object with all elements that
   *  pass the test implemented by the provided function.
   *
   * Iteration will use the results of the previous chain.
   *
   * This method like Array.prototype.filter
   *
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     return [12, 5, 8, 130, 44];
   *   }).filter(function(value, index, array) {
   *     return (value >= 10);
   *   }).then(function(result) {
   *     debug(result);
   *   }).begin();
   *   // @results [12, 130, 44]
   *
   *
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {*}                        Return the result of each callbacks.
   *
   * @name  Pot.Deferred.prototype.filter
   * @class
   * @public
   *
   * @property {Function} limp   Iterates "filter" loop with slowest speed.
   * @property {Function} doze   Iterates "filter" loop with slower speed.
   * @property {Function} slow   Iterates "filter" loop with slow speed.
   * @property {Function} normal Iterates "filter" loop with default speed.
   * @property {Function} fast   Iterates "filter" loop with fast speed.
   * @property {Function} rapid  Iterates "filter" loop with faster speed.
   * @property {Function} ninja  Iterates "filter" loop with fastest speed.
   */
  NAME : 'filter',
  /**
   * @ignore
   */
  method : Iter.filter,
  /**
   * @ignore
   */
  context : {iterateSpeed : Deferred.iterate},
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : null,
  /**
   * @ignore
   */
  args : function(arg, args) {
    return [arg].concat(args);
  }
}, {
  /**
   * Apply a function against an accumulator and each value of
   *  the object (from left-to-right) as to reduce it to a single value.
   *
   * Iteration will use the results of the previous chain.
   *
   * This method like Array.prototype.reduce
   *
   *
   * @example
   *   Pot.Deferred.begin(function() {
   *     return [1, 2, 3, 4, 5];
   *   }).reduce(function(a, b) {
   *     return a + b;
   *   }).then(function(result) {
   *     debug(result);
   *   });
   *   // @results 15
   *
   *
   * @param  {Function}  callback    A callback function.
   * @param  {*}         initial     An initial value passed as `callback`
   *                                   argument that will be used on
   *                                   first iteration.
   * @param  {*}         (context)   (Optional) Object to use as
   *                                   the first argument to the
   *                                   first call of the `callback`.
   * @return {*}                     Return the result of each callbacks.
   *
   * @name  Pot.Deferred.prototype.reduce
   * @class
   * @public
   *
   * @property {Function} limp   Iterates "reduce" loop with slowest speed.
   * @property {Function} doze   Iterates "reduce" loop with slower speed.
   * @property {Function} slow   Iterates "reduce" loop with slow speed.
   * @property {Function} normal Iterates "reduce" loop with default speed.
   * @property {Function} fast   Iterates "reduce" loop with fast speed.
   * @property {Function} rapid  Iterates "reduce" loop with faster speed.
   * @property {Function} ninja  Iterates "reduce" loop with fastest speed.
   */
  NAME : 'reduce',
  /**
   * @ignore
   */
  method : Iter.reduce,
  /**
   * @ignore
   */
  context : {iterateSpeed : Deferred.iterate},
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : null,
  /**
   * @ignore
   */
  args : function(arg, args) {
    return [arg].concat(args);
  }
}, {
  /**
   * Tests whether all elements in the object pass the
   *  test implemented by the provided function.
   *
   * Iteration will use the results of the previous chain.
   *
   * This method like Array.prototype.every
   *
   * @example
   *   var d = new Pot.Deferred();
   *   d.then(function() {
   *     return [12, 5, 8, 130, 44];
   *   }).every(function(value, index, array) {
   *     return (value >= 10);
   *   }).then(function(result) {
   *     debug(result);
   *     // @results false
   *   }).then(function() {
   *     return [12, 54, 18, 130, 44];
   *   }).every(function(value, index, array) {
   *     return (value >= 10);
   *   }).then(function(result) {
   *     debug(result);
   *     // @results true
   *   });
   *   d.begin();
   *
   *
   * @param  {Function}  callback    A callback function.
   * @param  {*}         (context)   (Optional) Object to use
   *                                   as `this` when executing callback.
   * @return {Boolean}               Return the Boolean result by callback.
   *
   * @name  Pot.Deferred.prototype.every
   * @class
   * @public
   *
   * @property {Function} limp   Iterates "every" loop with slowest speed.
   * @property {Function} doze   Iterates "every" loop with slower speed.
   * @property {Function} slow   Iterates "every" loop with slow speed.
   * @property {Function} normal Iterates "every" loop with default speed.
   * @property {Function} fast   Iterates "every" loop with fast speed.
   * @property {Function} rapid  Iterates "every" loop with faster speed.
   * @property {Function} ninja  Iterates "every" loop with fastest speed.
   */
  NAME : 'every',
  /**
   * @ignore
   */
  method : Iter.every,
  /**
   * @ignore
   */
  context : {iterateSpeed : Deferred.iterate},
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : null,
  /**
   * @ignore
   */
  args : function(arg, args) {
    return [arg].concat(args);
  }
}, {
  /**
   * Tests whether some element in the object passes the
   *  test implemented by the provided function.
   *
   * Iteration will use the results of the previous chain.
   *
   * This method like Array.prototype.some
   *
   *
   * @example
   *   Pot.Deferred.begin(function() {
   *     return [2, 5, 8, 1, 4];
   *   }).some(function(value, index, array) {
   *     return (value >= 10);
   *   }).then(function(result) {
   *     debug(result);
   *     // @results false
   *   }).then(function() {
   *     return [12, 5, 8, 1, 4];
   *   }).some(function(value, index, array) {
   *     return (value >= 10);
   *   }).then(function(result) {
   *     debug(result);
   *     // @results true;
   *   });
   *
   *
   * @param  {Function}  callback    A callback function.
   * @param  {*}         (context)   (Optional) Object to use
   *                                   as `this` when executing callback.
   * @return {Boolean}               Return the Boolean result by callback.
   *
   * @name  Pot.Deferred.prototype.some
   * @class
   * @public
   *
   * @property {Function} limp   Iterates "some" loop with slowest speed.
   * @property {Function} doze   Iterates "some" loop with slower speed.
   * @property {Function} slow   Iterates "some" loop with slow speed.
   * @property {Function} normal Iterates "some" loop with default speed.
   * @property {Function} fast   Iterates "some" loop with fast speed.
   * @property {Function} rapid  Iterates "some" loop with faster speed.
   * @property {Function} ninja  Iterates "some" loop with fastest speed.
   */
  NAME : 'some',
  /**
   * @ignore
   */
  method : Iter.some,
  /**
   * @ignore
   */
  context : {iterateSpeed : Deferred.iterate},
  /**
   * @ignore
   */
  speed : true,
  /**
   * @ignore
   */
  iterable : null,
  /**
   * @ignore
   */
  args : function(arg, args) {
    return [arg].concat(args);
  }
}]);

createSyncIterator = PotTmp.createSyncIterator;

// Update iterator methods for Pot
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Creates a new object with the results of calling a
   *   provided function on every element in object.
   *
   * This method like Array.prototype.map
   *
   *
   * @example
   *   function fuzzyPlural(single) {
   *     return single.replace(/o/g, 'e');
   *   }
   *   var words = ['foot', 'goose', 'moose'];
   *   debug(Pot.map(words, fuzzyPlural));
   *   // @results ['feet', 'geese', 'meese']
   *
   * @example
   *   var object = {foo: 'foo1', bar: 'bar2', baz: 'baz3'};
   *   var result = Pot.map(object, function(value, key) {
   *     return value + '00';
   *   });
   *   debug(result);
   *   // @results {foo: 'foo100', bar: 'bar200', baz: 'baz300'}
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {*}                        Return the result of each callbacks.
   * @name  Pot.map
   * @class
   * @function
   * @static
   * @public
   */
  map : createSyncIterator(function(speedKey) {
    return function() {
      var context = {iterateSpeedSync : Pot.iterate[speedKey]};
      return Iter.map.apply(context, arguments);
    };
  }),
  /**
   * Creates a new object with all elements that
   *  pass the test implemented by the provided function.
   *
   * This method like Array.prototype.filter
   *
   *
   * @example
   *   function isBigEnough(value, index, array) {
   *     return (value >= 10);
   *   }
   *   var filtered = Pot.filter([12, 5, 8, 130, 44], isBigEnough);
   *   debug(filtered);
   *   // @results [12, 130, 44]
   *
   *
   * @example
   *   function isBigEnough(value, key, object) {
   *     return (value >= 10);
   *   }
   *   var object = {a: 1, b: 20, c: 7, d: 5, e: 27, f: 99};
   *   var result = Pot.filter(object, isBigEnough);
   *   debug(result);
   *   // @results {b: 20, e: 27, f: 99}
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {*}                        Return the result of each callbacks.
   * @name  Pot.filter
   * @class
   * @function
   * @static
   * @public
   */
  filter : createSyncIterator(function(speedKey) {
    return function() {
      var context = {iterateSpeedSync : Pot.iterate[speedKey]};
      return Iter.filter.apply(context, arguments);
    };
  }),
  /**
   * Apply a function against an accumulator and each value of
   *  the object (from left-to-right) as to reduce it to a single value.
   *
   * This method like Array.prototype.reduce
   *
   *
   * @example
   *   var array = [1, 2, 3, 4, 5];
   *   var total = Pot.reduce(array, function(a, b) { return a + b; });
   *   debug(total);
   *   // @results 15
   *
   * @example
   *   var object = {a: 1, b: 2, c: 3};
   *   var total = Pot.reduce(object, function(a, b) { return a + b; });
   *   debug(total);
   *   // @results 6
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}              initial   An initial value passed as `callback`
   *                                      argument that will be used on
   *                                      first iteration.
   * @param  {*}             (context)  (Optional) Object to use as
   *                                      the first argument to the
   *                                      first call of the `callback`.
   * @return {*}                        Return the result of each callbacks.
   * @name  Pot.reduce
   * @class
   * @function
   * @static
   * @public
   */
  reduce : createSyncIterator(function(speedKey) {
    return function() {
      var context = {iterateSpeedSync : Pot.iterate[speedKey]};
      return Iter.reduce.apply(context, arguments);
    };
  }),
  /**
   * Tests whether all elements in the object pass the
   *  test implemented by the provided function.
   *
   * This method like Array.prototype.every
   *
   * @example
   *   function isBigEnough(value, index, array) {
   *     return (value >= 10);
   *   }
   *   var passed = Pot.every([12, 5, 8, 130, 44], isBigEnough);
   *   // passed is false
   *   passed = Pot.every([12, 54, 18, 130, 44], isBigEnough);
   *   // passed is true
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {Boolean}                  Return the Boolean result by callback.
   * @name  Pot.every
   * @class
   * @function
   * @static
   * @public
   */
  every : createSyncIterator(function(speedKey) {
    return function() {
      var context = {iterateSpeedSync : Pot.iterate[speedKey]};
      return Iter.every.apply(context, arguments);
    };
  }),
  /**
   * Tests whether some element in the object passes the
   *  test implemented by the provided function.
   *
   * This method like Array.prototype.some
   *
   *
   * @example
   *   function isBigEnough(value, index, array) {
   *     return (value >= 10);
   *   }
   *   var passed = Pot.some([2, 5, 8, 1, 4], isBigEnough);
   *   // passed is false
   *   passed = Pot.some([12, 5, 8, 1, 4], isBigEnough);
   *   // passed is true
   *
   *
   * @param  {Array|Object|*} object    A target object.
   * @param  {Function}       callback  A callback function.
   * @param  {*}             (context)  (Optional) Object to use
   *                                      as `this` when executing callback.
   * @return {Boolean}                  Return the Boolean result by callback.
   * @name  Pot.some
   * @class
   * @function
   * @static
   * @public
   */
  some : createSyncIterator(function(speedKey) {
    return function() {
      var context = {iterateSpeedSync : Pot.iterate[speedKey]};
      return Iter.some.apply(context, arguments);
    };
  }),
  /**
   * Create continuously array that
   *  has numbers between start number and end number.
   *
   * First argument can given an object that has "begin, end, step" any keys.
   *
   * This function can be a letter rather than just numbers.
   *
   * @example
   *   var numbers = Pot.range(1, 5);
   *   debug(numbers); // @results [1, 2, 3, 4, 5]
   *   var chars = Pot.range('a', 'f');
   *   debug(chars);   // @results ['a', 'b', 'c', 'd', 'e', 'f']
   *   var ranges = Pot.range({begin: 0, step: 10, end: 50});
   *   debug(ranges);  // @results [0, 10, 20, 30, 40, 50]
   *
   *
   * @param  {Number|Object}  end/begin  The end number or object.
   * @param  {Number}         (end)      (optinal) The end number.
   * @param  {Number}         (step)     (optinal) The step number.
   * @return {Array}                     Return an array result.
   * @function
   * @static
   * @public
   */
  range : function(/*[begin,] end[, step]*/) {
    return Iter.range.apply(null, arguments);
  },
  /**
   * Returns the first index at which a
   *  given element can be found in the object, or -1 if it is not present.
   *
   * This method like Array.prototype.indexOf
   *
   *
   * @example
   *   var array = [2, 5, 9];
   *   var index = Pot.indexOf(array, 2);
   *   // index is 0
   *   index = Pot.indexOf(array, 7);
   *   // index is -1
   *   var object = {a: 2, b: 5, c: 9};
   *   index = Pot.indexOf(object, 2);
   *   // index is 'a'
   *   index = Pot.indexOf(object, 7);
   *   // index is -1
   *
   *
   * @param  {Array|Object|*} object  A target object.
   * @param  {*}              subject A subject object.
   * @param  {*}              (from)  (Optional) The index at
   *                                    which to begin the search.
   *                                  Defaults to 0.
   * @return                          Return the index of result, or -1.
   * @function
   * @static
   * @public
   */
  indexOf : function() {
    return Iter.indexOf.apply(null, arguments);
  },
  /**
   * Returns the last index at which a
   *  given element can be found in the object, or -1 if it is not present.
   *
   * This method like Array.prototype.lastIndexOf
   *
   *
   * @example
   *   debug('array');
   *   var index, array = [2, 5, 9, 2];
   *   index = Pot.lastIndexOf(array, 2);
   *   debug('index is 3 : result = ' + index);   // 3
   *   index = Pot.lastIndexOf(array, 7);
   *   debug('index is -1 : result = ' + index);  // -1
   *   index = Pot.lastIndexOf(array, 2, 3);
   *   debug('index is 3 : result = ' + index);   // 3
   *   index = Pot.lastIndexOf(array, 2, 2);
   *   debug('index is 0 : result = ' + index);   // 0
   *   index = Pot.lastIndexOf(array, 2, -2);
   *   debug('index is 0 : result = ' + index);   // 0
   *   index = Pot.lastIndexOf(array, 2, -1);
   *   debug('index is 3 : result = ' + index);   // 3
   *   debug('object');
   *   var object = {a: 2, b: 5, c: 9, d: 2};
   *   index = Pot.lastIndexOf(object, 2);
   *   debug('index is  d : result = ' + index);  // 'd'
   *   index = Pot.lastIndexOf(object, 7);
   *   debug('index is -1 : result = ' + index);  // -1
   *   index = Pot.lastIndexOf(object, 2, 'd');   // 'd'
   *   debug('index is  d : result = ' + index);
   *   index = Pot.lastIndexOf(object, 2, 'c');   // 'a'
   *   debug('index is  a : result = ' + index);
   *
   *
   * @param  {Array|Object|*} object  A target object.
   * @param  {*}              subject A subject object.
   * @param  {*}             (from)   (Optional) The index at which to
   *                                    start searching backwards.
   *                                  Defaults to the array's length.
   * @return                          Return the index of result, or -1.
   * @function
   * @static
   * @public
   */
  lastIndexOf : function() {
    return Iter.lastIndexOf.apply(null, arguments);
  }
});

update(PotInternal, {
  defineDeferrater : createSyncIterator
});

// Definition of deferreed function.
(function() {
  /**@ignore*/
  var Deferrizer = function(func) {
    return new Deferrizer.prototype.init(func);
  },
  SPEED = buildSerial({NAME : '.\u0000[~`{{*@:SPEED:@*}}`~]\u0001'}),
  CACHE = {},
  CACHE_COUNT = 0,
  CACHE_LIMIT = 0x2000;
  Deferrizer.prototype = update(Deferrizer.prototype, {
    /**
     * @private
     * @ignore
     * @internal
     */
    constructor : Deferrizer,
    /**
     * @private
     * @ignore
     */
    id : PotInternal.getMagicNumber(),
    /**
     * @ignore
     * @private
     */
    func : null,
    /**
     * @ignore
     * @private
     */
    code : null,
    /**
     * @ignore
     * @private
     */
    tokens : [],
    /**
     * @ignore
     * @private
     */
    uniqs : {},
    /**
     * @ignore
     * @private
     */
    tails : [],
    /**
     * @ignore
     * @private
     */
    iteration : {},
    /**
     * Initialize properties.
     *
     * @private
     * @ignore
     */
    init : function(func) {
      this.func = func;
      this.code = this.toCode(this.func);
      this.tokens = [];
      this.iteration = {};
      this.tails = [];
      return this;
    },
    /**
     * Execute.
     *
     * @private
     * @ignore
     */
    execute : function() {
      var that = this, result = '';
      if (this.code) {
        if (this.code in CACHE) {
          result = CACHE[this.code];
        } else {
          this.uniqs = {};
          each('key val ret rev err nxt'.split(' '), function(v) {
            that.uniqs[v] = that.generateUniqName({
              NAME : '$_' + v + '_'
            });
          });
          this.tokens = this.tokenize(this.code);
          if (!this.hasIteration(this.tokens)) {
            result = this.func;
          } else {
            this.parseLoop();
            result = this.deferrizeFunction();
            if (result) {
              if (CACHE_COUNT < CACHE_LIMIT) {
                CACHE[this.code] = result;
                CACHE_COUNT++;
              }
            }
          }
        }
      }
      return result;
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    hasIteration : function(tokens) {
      var result = false, i, len, token;
      if (tokens) {
        len = tokens.length;
        for (i = 0; i < len; i++) {
          token = tokens[i];
          if (token === 'for' || token === 'while' || token === 'do') {
            result = true;
            break;
          }
        }
      }
      return result;
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    toCode : function(func) {
      return Pot.getFunctionCode(func);
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    isWord : (function() {
      var RE = {
        SPACE : /\s/,
        WORDS : /[$\w\u0100-\uFFFF]/
      };
      return function(c) {
        return c != null && !RE.SPACE.test(c) && RE.WORDS.test(c);
      };
    }()),
    /**
     * @internal
     * @private
     * @ignore
     */
    isNL : (function() {
      var RE = /\r\n|\r|\n/;
      return function(c) {
        return c != null && RE.test(c);
      };
    }()),
    /**
     * @internal
     * @private
     * @ignore
     */
    format : function(/*format[, ...args]*/) {
      var args = arrayize(arguments);
      return args[0].replace(/#(\d+)/g, function(a, i) {
        return args[+i];
      });
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    joinTokens : function(tokens) {
      var result = [], len = tokens.length,
          prev, prevSuf, pre, suf, i, token;
      for (i = 0; i < len; i++) {
        token = tokens[i];
        if (!prev) {
          result[result.length] = token;
        } else {
          pre = '';
          suf = '';
          if (token === '+'  || token === '-'  ||
              token === '++' || token === '--' ||
              token === 'in'
          ) {
            pre = ' ';
            suf = ' ';
          } else if (this.isWord(prev.slice(-1)) &&
                     this.isWord(token.charAt(0))) {
            pre = ' ';
          }
          if (prevSuf === ' ') {
            pre = '';
          }
          result[result.length] = pre + token + suf;
        }
        prev = token;
        prevSuf = suf;
      }
      return result.join('');
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    toEnd : function(code) {
      var s;
      if (isArray(code)) {
        s = this.joinTokens(code);
      } else {
        s = stringify(code);
      }
      if (trim(s).slice(-1) === ';') {
        return s;
      }
      return s ? s + ';' : s;
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    generateUniqName : function(prefix) {
      var result;
      do {
        result = buildSerial(prefix || Pot, '');
      } while (~Pot.indexOf(this.tokens, result));
      return result;
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    tokenize : (function() {
      var RE = {
        TOKEN : new RegExp(
          '(' + '^\\s*function\\b[^{]*[{]' +            // function prefix
          '|' + '[}][^}]*$' +                           // function suffix
          '|' + '/[*][\\s\\S]*?[*]/' +                  // multiline comment
          '|' + '/{2,}[^\\r\\n]*(?:\\r\\n|\\r|\\n|)' +  // single line comment
          '|' + '"(?:\\\\[\\s\\S]|[^"\\r\\n\\\\])*"' +  // string literal
          '|' + "'(?:\\\\[\\s\\S]|[^'\\r\\n\\\\])*'" +  // string literal
          '|' + '/(?![*])(?:\\\\.|[^/\\r\\n\\\\])+/' +
                '[gimy]{0,4}' +
          '|' + '<([^\\s>]*)[^>]*>[\\s\\S]*?</\\2>' +   // e4x
          '|' + '>>>=?|<<=|===|!==|>>=' +               // operators
          '|' + '[+][+](?=[+])|[-][-](?=[-])' +
          '|' + '[=!<>*+/&|^-]=' +
          '|' + '[&][&]|[|][|]|[+][+]|[-][-]|<<|>>' +
          '|' + '0(?:[xX][0-9a-fA-F]+|[0-7]+)' +        // number literal
          '|' + '\\d+(?:[.]\\d+)?(?:[eE][+-]?\\d+)?' +
          '|' + '[1-9]\\d*' +
          '|' + '[-+/%*=&|^~<>!?:,;@()\\\\[\\].{}]' +   // operator
          '|' + '(?![\\r\\n])\\s+' +                    // white space
          '|' + '(?:\\r\\n|\\r|\\n)' +                  // nl
          '|' + '[^\\s+/%*=&|^~<>!?:,;@()\\\\[\\].{}\'"-]+' + // token
          ')',
          'g'
        ),
        NOTSPACE : /[\S\r\n]/,
        COMMENTS : /^\/{2,}[\s\S]*$|^\/[*][\s\S]*?[*]\/$/
      };
      return function(func) {
        var r = [], m, token, s = this.toCode(func);
        if (s) {
          RE.TOKEN.lastIndex = 0;
          while ((m = RE.TOKEN.exec(s)) != null) {
            token = m[1];
            if (!RE.NOTSPACE.test(token) || RE.COMMENTS.test(token)) {
              continue;
            } else {
              r[r.length] = token;
            }
          }
        }
        return r;
      };
    }()),
    /**
     * @internal
     * @private
     * @ignore
     */
    parseLoop : function() {
      var result, max = 0, loops = [], offsets = [], index = 0, nest = 0,
          level = 0, inLoop, i, token, len = this.tokens.length;
      for (i = 0; i < len; i++) {
        token = this.tokens[i];
        switch (token) {
          case 'for':
          case 'while':
          case 'do':
              if (!inLoop) {
                inLoop = {
                  token : token,
                  org : {
                    level : level,
                    nest  : nest
                  },
                  cur : {
                    level : level,
                    nest  : nest
                  }
                };
              }
              break;
          case '(':
              nest++;
              if (inLoop) {
                inLoop.cur.nest++;
              }
              break;
          case ')':
              nest--;
              if (inLoop) {
                if (--inLoop.cur.nest === inLoop.org.nest &&
                    inLoop.cur.level === inLoop.org.level &&
                    inLoop.token === 'do'
                ) {
                  inLoop.last = true;
                }
              }
              break;
          case '{':
              level++;
              if (inLoop) {
                inLoop.cur.level++;
              }
              break;
          case '}':
              level--;
              if (inLoop) {
                if (--inLoop.cur.level === inLoop.org.level &&
                    inLoop.cur.nest === inLoop.org.nest &&
                    inLoop.token !== 'do'
                ) {
                  inLoop.last = true;
                }
              }
              break;
        }
        if (inLoop) {
          if (!(index in loops)) {
            loops[index] = [];
            offsets[index] = {
              start : i
            };
          }
          loops[index][loops[index].length] = token;
          if (inLoop.last) {
            offsets[index].end = i;
            inLoop = null;
            index++;
          }
        }
      }
      len = loops.length;
      for (i = 0; i < len; i++) {
        if (loops[i].length > max) {
          max = i;
        }
      }
      this.iteration = {
        loops : loops[max],
        start : offsets[max].start,
        end   : offsets[max].end
      };
      return result;
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    deferrizeLoop : function() {
      var tokens = this.iteration.loops,
          state = tokens.shift();
      switch (state) {
        case 'for'   : return this.parseFor(tokens);
        case 'while' : return this.parseWhile(tokens);
        case 'do'    : return this.parseDoWhile(tokens);
      }
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    deferrizeFunction : function() {
      var result, next, looped, token, i, len = this.tokens.length,
          key = 'before', enclose,
          states = {
            level : 0,
            block : 0
          },
          parts = {
            before : [],
            loop   : [],
            after  : [],
            result : []
          },
          /**@ignore*/
          openBlock = function(k) {
            if (!states[k]) {
              states[k] = {
                block : states.block,
                level : states.level
              };
            }
          },
          /**@ignore*/
          closeBlock = function(kv) {
            each(kv ? arrayize(kv) : ['func', 'cond'], function(k) {
              if (states[k] &&
                  states[k].block === states.block &&
                  states[k].level === states.level) {
                states[k] = null;
              }
            });
          };
      for (i = 1; i < len - 1; i++) {
        if (i >= this.iteration.start &&
            i <= this.iteration.end
        ) {
          if (!looped) {
            looped = true;
            i = this.iteration.end - 1;
            parts.loop = arrayize(this.deferrizeLoop());
            key = 'after';
            if (states.cond) {
              enclose = true;
            }
          }
          continue;
        }
        token = this.tokens[i];
        next = this.tokens[i + 1];
        switch (token) {
          case '{':
              states.block++;
              break;
          case '}':
              states.block--;
              closeBlock();
              break;
          case '(':
              states.level++;
              break;
          case ')':
              states.level--;
              if (states.cond && states.cond.expr && next === '{') {
                states.cond.expr = null;
                closeBlock('func');
              } else {
                closeBlock();
              }
              break;
          case ';':
              closeBlock('result');
              break;
          case 'function':
              openBlock('func');
              break;
          case 'if':
              openBlock('cond');
              states.cond.expr = true;
              break;
          case 'return':
              if (!states.func && !states.result) {
                if (!next || next === ';' || this.isNL(next)) {
                  token = this.format('#1 #2=void 0#3',
                    token,
                    this.uniqs.ret,
                    (next === ';' || this.isNL(next)) ? '' : ';'
                  );
                } else {
                  token = this.format('#1(#2!==#3)?#2:#2=',
                    token,
                    this.uniqs.ret,
                    this.uniqs.rev
                  );
                }
                parts.result = [];
                openBlock('result');
              }
              break;
          default:
              if (states.result && this.isNL(token)) {
                closeBlock('result');
              }
              break;
        }
        parts[key][parts[key].length] = token;
        if (states.result) {
          parts.result[parts.result.length] = token;
        }
      }
      result = this.format(
        '#1' +
        'var #2={},#3=#2,#4={};' +
        'return Pot.Deferred.begin(function(){' +
            '#5' +
            '#6' +
            '#9' +
          '});' +
          '#7' +
          '#8' +
        '}).then(function(r){' +
          'return(#2===#3)?r:#2;' +
        '});' +
        '#10',
        this.tokens.shift(),
        this.uniqs.ret,
        this.uniqs.rev,
        this.uniqs.nxt,
        this.toEnd(this.joinTokens(parts.before)),
        this.joinTokens(parts.loop),
        this.joinTokens(this.tails),
        this.joinTokens(enclose ? parts.after  : []),
        this.joinTokens(enclose ? parts.result : parts.after),
        this.tokens.pop()
      );
      return result;
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    parseWhile : function(tokens) {
      var result = '', level = 0, nest = 0, started = false,
          prev, next, skip, key = 'cond', inLoop, token, i,
          len = tokens.length, isEnd = false,
          states = {
            cond : [],
            body : []
          };
      for (i = 0; i < len; i++) {
        token = tokens[i];
        next = tokens[i + 1];
        skip = false;
        switch (token) {
          case '(':
              nest++;
              if (inLoop) {
                inLoop.cur.nest++;
              }
              if (i === 0 && nest === 1) {
                skip = true;
              }
              break;
          case ')':
              nest--;
              if (inLoop) {
                if (--inLoop.cur.nest === inLoop.org.nest &&
                    inLoop.cur.level === inLoop.org.level &&
                    inLoop.token === 'do'
                ) {
                  inLoop = null;
                }
              }
              if (!started && nest === 0 &&
                  level === 0 && next === '{') {
                skip = true;
              }
              break;
          case '{':
              level++;
              if (inLoop) {
                inLoop.cur.level++;
              }
              if (level === 1 && nest === 0 && prev === ')') {
                skip = true;
                started = true;
                key = 'body';
              }
              break;
          case '}':
              level--;
              if (inLoop) {
                if (--inLoop.cur.level === inLoop.org.level &&
                    inLoop.cur.nest === inLoop.org.nest &&
                    inLoop.token !== 'do'
                ) {
                  inLoop = null;
                }
              }
              if (started && nest === 0 && level === 0) {
                states.body.unshift(this.format(
                  'if(#1!==#2||!(#3)){' +
                    'throw Pot.StopIteration;' +
                  '}' +
                  'try{',
                  this.uniqs.ret,
                  this.uniqs.rev,
                  this.joinTokens(states.cond) || 'false'
                ));
                states.body.push(this.format(
                  '}catch(#1){' +
                    'if(Pot.isError(#1)||Pot.isStopIter(#1)){' +
                      'throw #1;' +
                    '}' +
                    'if(#1!==#2){' +
                      'throw #1;' +
                    '}' +
                  '}',
                  this.uniqs.err,
                  this.uniqs.nxt
                ));
                token += ').then(function(){';
                isEnd = true;
              }
              break;
          case 'for':
          case 'while':
          case 'do':
              inLoop = {
                token : token,
                org : {
                  level : level,
                  nest  : nest
                },
                cur : {
                  level : level,
                  nest  : nest
                }
              };
              break;
          case 'break':
              if (!inLoop && started && !this.isWord(next)) {
                token = 'throw Pot.StopIteration';
              }
              break;
          case 'continue':
              if (!inLoop && started && !this.isWord(next)) {
                token = 'throw ' + this.uniqs.nxt;
              }
              break;
          case 'return':
              if (started) {
                if (!next || next === ';' || this.isNL(next)) {
                  token = this.format('#1 #2=void 0#3',
                    token,
                    this.uniqs.ret,
                    (next === ';' || this.isNL(next)) ? '' : ';'
                  );
                } else {
                  token = this.format('#1 #2=',
                    token,
                    this.uniqs.ret
                  );
                }
              }
              break;
        }
        if (!skip) {
          states[key][states[key].length] = token;
        }
        prev = token;
      }
      result = '';
      if (!isEnd) {
        throw new Error("Parse error, expect 'while(...)'");
      }
      result = this.format(
        'return Pot.Deferred.forEver.#1(function(){' +
        '#2',
        SPEED,
        this.joinTokens(states.body)
      );
      return result;
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    parseDoWhile : function(tokens) {
      var result = '', level = 0, nest = 0, prev, next, skip,
          key = 'body', inLoop, token, i, len = tokens.length, isEnd = false,
          states = {
            cond  : [],
            body  : [],
            after : []
          };
      for (i = 0; i < len; i++) {
        token = tokens[i];
        next = tokens[i + 1];
        skip = false;
        switch (token) {
          case '(':
              nest++;
              if (inLoop) {
                inLoop.cur.nest++;
              }
              if (level === 0 && nest === 1 && prev === 'while') {
                skip = true;
                key = 'cond';
              }
              break;
          case ')':
              nest--;
              if (inLoop) {
                if (--inLoop.cur.nest === inLoop.org.nest &&
                    inLoop.cur.level === inLoop.org.level &&
                    inLoop.token === 'do'
                ) {
                  inLoop = null;
                }
              }
              if (nest === 0 && level === 0 && key === 'cond') {
                skip = true;
              }
              break;
          case '{':
              level++;
              if (inLoop) {
                inLoop.cur.level++;
              }
              if (i === 0 && level === 1) {
                skip = true;
              }
              break;
          case '}':
              level--;
              if (inLoop) {
                if (--inLoop.cur.level === inLoop.org.level &&
                    inLoop.cur.nest === inLoop.org.nest &&
                    inLoop.token !== 'do'
                ) {
                  inLoop = null;
                }
              }
              if (nest === 0 && level === 0 && next === 'while') {
                isEnd = true;
                skip = true;
              }
              break;
          case 'while':
              if (level === 0 && nest === 0) {
                skip = true;
                break;
              }
              // FALLTHROUGH
          case 'for':
          case 'do':
              inLoop = {
                token : token,
                org : {
                  level : level,
                  nest  : nest
                },
                cur : {
                  level : level,
                  nest  : nest
                }
              };
              break;
          case 'break':
              if (!inLoop && !this.isWord(next)) {
                token = 'throw Pot.StopIteration';
              }
              break;
          case 'continue':
              if (!inLoop && !this.isWord(next)) {
                token = 'throw ' + this.uniqs.nxt;
              }
              break;
          case 'return':
              if (!next || next === ';' || this.isNL(next)) {
                token = this.format('#1 #2=void 0#3',
                  token,
                  this.uniqs.ret,
                  (next === ';' || this.isNL(next)) ? '' : ';'
                );
              } else {
                token = this.format('#1 #2=',
                  token,
                  this.uniqs.ret
                );
              }
              break;
        }
        if (!skip) {
          states[key][states[key].length] = token;
        }
        prev = token;
      }
      result = '';
      if (!isEnd) {
        throw new Error("Parse error, expect 'do...while()'");
      }
      states.body.unshift(this.format(
        'if(#1!==#2){' +
          'throw Pot.StopIteration;' +
        '}' +
        'try{',
        this.uniqs.ret,
        this.uniqs.rev
      ));
      states.body.push(this.format(
        '}catch(#1){' +
          'if(Pot.isError(#1)||Pot.isStopIter(#1)){' +
            'throw #1;' +
          '}' +
          'if(#1!==#2){' +
            'throw #1;' +
          '}' +
        '}finally{' +
          'if(!(#3)){' +
            'throw Pot.StopIteration;' +
          '}' +
        '}' +
        '}).then(function(){',
        this.uniqs.err,
        this.uniqs.nxt,
        this.joinTokens(states.cond) || 'false'
      ));
      result = this.format(
        'return Pot.Deferred.forEver.#1(function(){' +
        '#2',
        SPEED,
        this.joinTokens(states.body)
      );
      return result;
    },
    /**
     * @internal
     * @private
     * @ignore
     */
    parseFor : function(tokens) {
      var result = '', level = 0, nest = 0, isInOrOf = null, started = false,
          prev, next, skip, key = 'before', varType, inLoop, i, len, token,
          isEnd = false,
          states = {
            prefix : [],
            suffix : [],
            before : [],
            cond   : [],
            after  : [],
            key    : [],
            target : [],
            body   : []
          };
      len = tokens.length;
      for (i = 0; i < len; i++) {
        token = tokens[i];
        next = tokens[i + 1];
        skip = false;
        switch (token) {
          case '(':
              nest++;
              if (inLoop) {
                inLoop.cur.nest++;
              }
              if (i === 0 && nest === 1) {
                skip = true;
              }
              break;
          case ')':
              nest--;
              if (inLoop) {
                if (--inLoop.cur.nest === inLoop.org.nest &&
                    inLoop.cur.level === inLoop.org.level &&
                    inLoop.token === 'do'
                ) {
                  inLoop = null;
                }
              }
              if (!started && nest === 0 &&
                  level === 0 && next === '{') {
                skip = true;
              }
              break;
          case '{':
              level++;
              if (inLoop) {
                inLoop.cur.level++;
              }
              if (level === 1 && nest === 0 && prev === ')') {
                skip = true;
                started = true;
                key = 'body';
              }
              break;
          case '}':
              level--;
              if (inLoop) {
                if (--inLoop.cur.level === inLoop.org.level &&
                    inLoop.cur.nest === inLoop.org.nest &&
                    inLoop.token !== 'do'
                ) {
                  inLoop = null;
                }
              }
              if (started && nest === 0 && level === 0) {
                states.body.unshift(this.format(
                  'if(#1!==#2){' +
                    'throw Pot.StopIteration;' +
                  '}' +
                  'try{',
                  this.uniqs.ret,
                  this.uniqs.rev
                ));
                if (states.suffix.length) {
                  states.body.push(
                    this.toEnd(this.joinTokens(states.suffix))
                  );
                }
                states.body.push(this.format(
                  '}catch(#1){' +
                    'if(Pot.isError(#1)||Pot.isStopIter(#1)){' +
                      'throw #1;' +
                    '}' +
                    'if(#1!==#2){' +
                      'throw #1;' +
                    '}' +
                  '}finally{' +
                    '#3' +
                  '}',
                  this.uniqs.err,
                  this.uniqs.nxt,
                  this.toEnd(this.joinTokens(states.after))
                ));
                token += ').then(function(){';
                isEnd = true;
              }
              break;
          case 'each':
              if (i === 0) {
                throw new Error("Not supported 'for each'");
              }
              break;
          case 'in':
          case 'of':
              if (!started && isInOrOf === null &&
                  nest === 1 && level === 0
              ) {
                skip = true;
                isInOrOf = true;
                if (states.before.length > 2) {
                  throw new Error(
                    "Invalid keys, expect 'for(var [...] in ...);'"
                  );
                }
                if (varType) {
                  states.before.push(';');
                  unshift.apply(states.prefix, states.before);
                  states.before.shift();
                  states.before.pop();
                  if (varType === 'let') {
                    states.prefix.unshift('{');
                    this.tails.push('}');
                  }
                }
                states.before.push('=' + this.uniqs.key);
                states.before.push(';');
                states.key = states.before;
                unshift.apply(states.body, states.key);
                key = 'target';
              }
              break;
          case 'var':
          case 'let':
              if (!varType && i === 1 && nest === 1) {
                varType = token;
              }
              break;
          case ',':
              if (!started && nest === 1 && level === 0 &&
                  !varType &&
                  (key === 'before' || key === 'after')
              ) {
                token = ';';
              }
              break;
          case ';':
              if (!started && nest === 1 && level === 0) {
                skip = true;
                if (isInOrOf === null) {
                  isInOrOf = false;
                }
                if (key === 'before') {
                  key = 'cond';
                  states.prefix.push(
                    this.toEnd(this.joinTokens(states.before))
                  );
                  if (varType === 'let') {
                    states.prefix.unshift('{');
                    this.tails.push('}');
                  }
                } else if (key === 'cond') {
                  key = 'after';
                  if (states.cond.length) {
                    states.cond.unshift('if(');
                    states.cond.push('){');
                    states.suffix.push('}else{throw Pot.StopIteration;}');
                  }
                  push.apply(states.body, states.cond);
                }
              }
              break;
          case 'for':
          case 'while':
          case 'do':
              inLoop = {
                token : token,
                org : {
                  level : level,
                  nest  : nest
                },
                cur : {
                  level : level,
                  nest  : nest
                }
              };
              break;
          case 'break':
              if (!inLoop && started && !this.isWord(next)) {
                token = 'throw Pot.StopIteration';
              }
              break;
          case 'continue':
              if (!inLoop && started && !this.isWord(next)) {
                token = 'throw ' + this.uniqs.nxt;
              }
              break;
          case 'return':
              if (started) {
                if (!next || next === ';' || this.isNL(next)) {
                  token = this.format('#1 #2=void 0#3',
                    token,
                    this.uniqs.ret,
                    (next === ';' || this.isNL(next)) ? '' : ';'
                  );
                } else {
                  token = this.format('#1 #2=',
                    token,
                    this.uniqs.ret
                  );
                }
              }
              break;
        }
        if (!skip) {
          states[key][states[key].length] = token;
        }
        prev = token;
      }
      result = '';
      if (!isEnd) {
        throw new Error("Parse error, expect 'for(...)'");
      }
      if (isInOrOf) {
        result = this.format(
          '#1return Pot.Deferred.forEach.#2(#3,function(#4,#5){' +
          '#6',
          this.toEnd(this.joinTokens(states.prefix)),
          SPEED,
          this.joinTokens(states.target),
          this.uniqs.val,
          this.uniqs.key,
          this.joinTokens(states.body)
        );
      } else {
        result = this.format(
          '#1return Pot.Deferred.forEver.#2(function(){' +
          '#3',
          this.toEnd(this.joinTokens(states.prefix)),
          SPEED,
          this.joinTokens(states.body)
        );
      }
      return result;
    }
  });
  Deferrizer.prototype.init.prototype = Deferrizer.prototype;
  update(PotInternal, {
    /**
     * @lends Pot.Internal
     */
    /**
     * @type Function
     * @internal
     * @ignore
     */
    deferrate : function(func) {
      return (new Deferrizer(func)).execute();
    }
  });
  // Update Pot/Pot.Deferred.
  update(Deferred, {
    /**
     * @lends Pot.Deferred
     */
    /**
     * Create new defer function with speeds from static function.
     * That returns a new instance of Pot.Deferred that
     *  has already ".begin()" called.
     * This function works like 'deferrize'.
     * This function will redefine the function that converts the
     *  synchronous loop block (i.e. for, for-in, do, while) to the
     *  asynchronous iteration by Pot.Deferred.xxx.
     *
     *
     * @example
     *   var toCharCode = function(string) {
     *     var result = [];
     *     for (var i = 0; i < string.length; i++) {
     *       result.push(string.charCodeAt(i));
     *     }
     *     return result;
     *   };
     *   var toCharCodeDefer = Pot.deferreed(toCharCode);
     *   // Note:
     *   //  toCharCodeDefer like below.
     *   //
     *   //  function(string) {
     *   //    var result = [];
     *   //    return Pot.Deferred.repeat(string.length, function(i) {
     *   //      result.push(string.charCodeAt(i));
     *   //    }).then(function() {
     *   //      return result;
     *   //    });
     *   //  };
     *   //
     *   toCharCodeDefer('abc').then(function(res) {
     *     Pot.debug(res); // @results [97, 98, 99]
     *   });
     *   // Large string.
     *   var largeString = new Array(100000).join('abcdef');
     *   // Specify speed 'slow'.
     *   toCharCodeDefer.slow(largeString).then(function(res) {
     *     Pot.debug(res.length); // @results  599994
     *   });
     *
     *
     * @example
     *   // Compress/Decompress string by LZ77 algorithm.
     *   // http://polygon-planet.blogspot.com/2011/02/lz77javascript.html
     *   var TinyLz77 = {
     *     // compress (synchronous)
     *     compress : function(s) {
     *       var a = 53300, b, c, d, e, f, g = -1,
     *           h, i, r = [], x = String.fromCharCode;
     *       if (!s) {
     *         return '';
     *       }
     *       s = new Array(a--).join(' ') + s;
     *       while ((b = s.substr(a, 256))) {
     *         for (c = 2, i = b.length; c <= i; ++c) {
     *           d = s.substring(
     *               a - 52275,
     *               a + c - 1
     *           ).lastIndexOf(b.substring(0, c));
     *           if (!~d) {
     *             break;
     *           }
     *           e = d;
     *         }
     *         if (c === 2 || c === 3 && f === g) {
     *           f = g;
     *           h = s.charCodeAt(a++);
     *           r.push(
     *               x(h >> 8 & 255),
     *               x(h & 255)
     *           );
     *         } else {
     *           r.push(
     *               x((e >> 8 & 255) | 65280),
     *               x(e & 255),
     *               x(c - 3)
     *           );
     *           a += c - 1;
     *         }
     *       }
     *       return r.join('');
     *     },
     *     // decompress (synchronous)
     *     decompress : function(s) {
     *       var a = 53300, b = 0, c, d, e, f, g,
     *           h, r = new Array(a--).join(' '),
     *           x = String.fromCharCode;
     *       if (s && s.length) {
     *         do {
     *           c = s.charCodeAt(b++);
     *           if (c <= 255) {
     *             r += x((c << 8) | s.charCodeAt(b++));
     *           } else {
     *             e = ((c & 255) << 8) | s.charCodeAt(b++);
     *             f = e + s.charCodeAt(b++) + 2;
     *             h = r.slice(-52275);
     *             g = h.substring(e, f);
     *             if (g) {
     *               while (h.length < f) {
     *                 h += g;
     *               }
     *               r += h.substring(e, f);
     *             }
     *           }
     *         } while (b < s.length);
     *       }
     *       return r.slice(a);
     *     }
     *   };
     *   // create asynchronous iteration functions.
     *   var compressDefer   = Pot.deferreed(TinyLz77, 'compress');
     *   var decompressDefer = Pot.deferreed(TinyLz77, 'decompress');
     *   // original string.
     *   var string = 'foooooooooo baaaaaaaaaaaaar baaaaaaazzzzzzzzzzzz';
     *   Pot.debug(string.length); // 48
     *   // execute compress with asynchronous iterator.
     *   compressDefer(string).then(function(res) {
     *     Pot.debug(res.length); // 26
     *     return decompressDefer(res).then(function(res) {
     *       Pot.debug(res.length); // 48
     *     });
     *   });
     *
     *
     * @param  {Object|Function}   object   The context object.
     *                                        or the target function.
     * @param  {String|Function}  (method)  The target function name.
     *                                        or the target function.
     * @return {Function}                   The defer function that
     *                                        returns Deferred object.
     *                                      Returns new asynchronous
     *                                        function that has
     *                                        each speeds below.
     *                                      <pre>
     *                                      ----------------------------------
     *                                       method name |  speed
     *                                      ----------------------------------
     *                                       limp        :  slowest
     *                                       doze        :  slower
     *                                       slow        :  slow
     *                                       normal      :  normal (default)
     *                                       fast        :  fast
     *                                       rapid       :  faster
     *                                       ninja       :  fastest
     *                                      ----------------------------------
     *                                      You can control speed by
     *                                        specify key.
     *                                      e.g.
     *                                        var f = deferreed(func);
     *                                        f();      // normal
     *                                        f.slow(); // slow
     *                                      </pre>
     * @type   Function
     * @function
     * @public
     * @static
     */
    deferreed : function(object, method) {
      var result, func, context, err, code, proc;
      try {
        switch (arguments.length) {
          case 0:
              throw false;
          case 1:
              func = object;
              if (!isFunction(func)) {
                throw func;
              }
              proc = func;
              break;
          case 2:
          default:
              if (isObject(method)) {
                context = method;
                func    = object;
              } else {
                func    = method;
                context = object;
              }
              if (!isFunction(context[func])) {
                throw func;
              }
              proc = context[func];
              break;
        }
        if (!proc || !isFunction(proc) || Pot.isBuiltinMethod(proc)) {
          throw proc;
        }
        code = PotInternal.deferrate(proc);
        if (!code) {
          throw code;
        }
        if (code === proc) {
          result = Deferred.deferrize(proc);
        } else {
          if (!isString(code)) {
            throw code;
          }
          result = PotInternal.defineDeferrater(function(speedKey) {
            var c = code.replace(SPEED, speedKey),
                f = Pot.localEval(c, context);
            return function() {
              return f.apply(context, arguments);
            };
          });
        }
        if (!result || !isFunction(result)) {
          throw result;
        }
      } catch (e) {
        err = e;
        throw isError(err) ? err : new Error(err);
      }
      return result;
    }
  });
  // Refer Pot object.
  Pot.update({
    deferreed : Deferred.deferreed
  });
}());

delete PotTmp.createIterators;
delete PotTmp.createProtoIterators;
delete PotTmp.createSyncIterator;
}());

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Pot.ArrayBufferoid (ArrayBuffer).
(function() {
var ArrayBufferoidTypes;

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Pot.ArrayBufferoid is object like TypedArray that
   *  has DataView and Array prototype methods.
   * That is able to cast to the each TypedArray.
   * If environment not supported TypedArray, it will use native Array.
   * Pot.ArrayBufferoid can coding that
   *  is compatible with other environments.
   *
   *
   * @example
   *   var buffer = new Pot.ArrayBufferoid();
   *   var i = 0;
   *   buffer[i++] = 255;
   *   buffer[i++] = 254;
   *   buffer.push(253);
   *   buffer.push(252);
   *   // like DataView.
   *   Pot.debug(buffer.getUint16(0, true)); // 65279
   *   // length.
   *   Pot.debug('buffer.length = ' + buffer.size()); // 4
   *   // convert to typed array.
   *   var arrayBuffer = buffer.toArrayBuffer();
   *   var uint8Array = buffer.toUint8Array();
   *   // stream.
   *   buffer.seek(0);
   *   var data1 = buffer.read(1);
   *   Pot.debug(data1[0]); // 255
   *   Pot.debug(buffer.tell()); // 1
   *   var data2 = buffer.read(2);
   *   Pot.debug(data2); // [254, 253]
   *   buffer.seek(0);
   *   buffer.write([100, 101]);
   *   Pot.debug(buffer); // [100, 101, 253, 252]
   *
   *
   * @example
   *   var buffer = new Pot.ArrayBufferoid([1, 2, 3, 4]);
   *   var uint8Array = buffer.map(function(val) {
   *     return val + 100;
   *   }).toUint8Array();
   *   Pot.debug(uint8Array[0]); // 101
   *
   *
   * @param  {Array|TypedArray|Pot.ArrayBufferoid|Number|*} args parameters.
   * @return {Pot.ArrayBufferoid} A new instance of Pot.ArrayBufferoid.
   *
   * @name  Pot.ArrayBufferoid
   * @class
   * @constructor
   * @public
   */
  ArrayBufferoid : update(function() {
    return isArrayBufferoid(this) ? this.init(arguments)
                                  : new ArrayBufferoid.fn.init(arguments);
  }, {
    /**
     * @lends Pot.ArrayBufferoid
     */
    /**
     * @type Object
     * @const
     */
    types : {}
  })
});

// Refer the Pot properties/functions.
ArrayBufferoid      = Pot.ArrayBufferoid;
ArrayBufferoidTypes = ArrayBufferoid.types;

each({
  /**
   * @lends Pot.ArrayBufferoid.types
   */
  /**
   * @type Number
   */
  ArrayBuffer       : 1,
  Int8Array         : 2,
  Uint8Array        : 4,
  Uint8ClampedArray : 8,
  Int16Array        : 0x10,
  Uint16Array       : 0x20,
  Int32Array        : 0x40,
  Uint32Array       : 0x80,
  Float32Array      : 0x100,
  Float64Array      : 0x200
}, function(n, name) {
  ArrayBufferoidTypes[name] = n;
  /**
   * @lends Pot.ArrayBufferoid
   */
  /**
   * @property {Function} toArrayBuffer
   *           Create a new ArrayBuffer with arguments.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toInt8Array
   *           Create a new Int8Array with arguments.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toUint8Array
   *           Create a new Uint8Array with arguments.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toUint8ClampedArray
   *           Create a new Uint8ClampedArray with arguments.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toInt16Array
   *           Create a new Int16Array with arguments.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toUint16Array
   *           Create a new Uint16Array with arguments.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toInt32Array
   *           Create a new Int32Array with arguments.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toUint32Array
   *           Create a new Uint32Array with arguments.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toFloat32Array
   *           Create a new Float32Array with arguments.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toFloat64Array
   *           Create a new Float64Array with arguments.
   *           If Typed Array not supported will returns Array.
   */
  ArrayBufferoid['to' + name] = function() {
    return createArrayBuffer(n, arguments);
  };
});

ArrayBufferoid.fn = ArrayBufferoid.prototype = {
  /**
   * @lends Pot.ArrayBufferoid.prototype
   */
  /**
   * @ignore
   */
  constructor : ArrayBufferoid,
  /**
   * @private
   * @ignore
   */
  id : PotInternal.getMagicNumber(),
  /**
   * A unique strings.
   *
   * @type  String
   * @const
   */
  serial : null,
  /**
   * @private
   * @ignore
   * @const
   */
  NAME : 'ArrayBufferoid',
  /**
   * isArrayBufferoid.
   *
   * @type Function
   * @function
   * @public
   */
  isArrayBufferoid : isArrayBufferoid,
  /**
   * length.
   *
   * @type Number
   * @ignore
   */
  length : 0,
  /**
   * offset (byteOffset).
   *
   * @type Number
   * @public
   */
  offset : 0,
  /**
   * Initialize properties.
   *
   * @private
   * @ignore
   */
  init : function(args) {
    if (!this.serial) {
      this.serial = buildSerial(this);
    }
    this.length = 0;
    this.offset = 0;
    parseArguments(this, args);
    return this;
  },
  /**
   * Get the object length.
   *
   * @return {Number}    Max length of object.
   *
   * @type Function
   * @function
   * @public
   */
  size : function() {
    var result = sizeOfBufferoid(this, true);
    this.length = result;
    return result;
  },
  /**
   * toString like Array.prototype.toString.
   *
   * @return {String}
   */
  toString : function() {
    var array = bufferoidToArray(this);
    return ArrayProto.toString.call(array);
  },
  /**
   * join like Array.prototype.join.
   *
   * @param  {String}
   * @return {String}
   */
  join : function(separator) {
    var array = bufferoidToArray(this);
    return ArrayProto.join.apply(array, arguments);
  },
  /**
   * push like Array.prototype.push.
   *
   * @param  {...args}
   * @return {Number}
   */
  push : function() {
    var array = bufferoidToArray(this, true),
        result = push.apply(array, arguments);
    arrayToBufferoid(this, array);
    return result;
  },
  /**
   * pop like Array.prototype.pop.
   *
   * @return {*}
   */
  pop : function() {
    var array = bufferoidToArray(this, true),
        result = ArrayProto.pop.apply(array, arguments);
    arrayToBufferoid(this, array);
    return result;
  },
  /**
   * shift like Array.prototype.shift.
   *
   * @return {*}
   */
  shift : function() {
    var array = bufferoidToArray(this, true),
        result = ArrayProto.shift.apply(array, arguments);
    arrayToBufferoid(this, array);
    return result;
  },
  /**
   * unshift like Array.prototype.unshift.
   *
   * @return {Number}
   */
  unshift : function() {
    var array = bufferoidToArray(this, true),
        result = unshift.apply(array, arguments);
    arrayToBufferoid(this, array);
    return result;
  },
  /**
   * reverse like Array.prototype.reverse.
   *
   * @return {Pot.ArrayBufferoid}
   */
  reverse : function() {
    var array = bufferoidToArray(this);
    return new ArrayBufferoid(ArrayProto.reverse.apply(array, arguments));
  },
  /**
   * sort like Array.prototype.sort.
   *
   * @param  {(Function)}
   * @return {Pot.ArrayBufferoid}
   */
  sort : function() {
    var array = bufferoidToArray(this, true);
    ArrayProto.sort.apply(array, arguments);
    arrayToBufferoid(this, array);
    return new ArrayBufferoid(array);
  },
  /**
   * concat like Array.prototype.concat.
   *
   * @param  {...args}
   * @return {Pot.ArrayBufferoid}
   */
  concat : function() {
    var array = bufferoidToArray(this);
    return new ArrayBufferoid(concat.apply(array, arguments));
  },
  /**
   * slice like Array.prototype.slice.
   *
   * @param  {Number}
   * @param  {(Number)}
   * @return {Pot.ArrayBufferoid}
   */
  slice : function() {
    var array = bufferoidToArray(this);
    return new ArrayBufferoid(slice.apply(array, arguments));
  },
  /**
   * splice like Array.prototype.splice.
   *
   * @param  {Number}
   * @param  {Number}
   * @param  {...args}
   * @return {*}
   */
  splice : function() {
    var array = bufferoidToArray(this, true),
        result = new ArrayBufferoid(splice.apply(array, arguments));
    arrayToBufferoid(this, array);
    return result;
  },
  /**
   * indexOf like Array.prototype.indexOf.
   *
   * @param  {*}
   * @param  {(Number)}
   * @return {Number}
   */
  indexOf : function() {
    var args = arrayize(arguments);
    args.unshift(this);
    return Pot.indexOf.apply(null, args);
  },
  /**
   * lastIndexOf like Array.prototype.lastIndexOf.
   *
   * @param  {*}
   * @param  {(Number)}
   * @return {Number}
   */
  lastIndexOf : function() {
    var args = arrayize(arguments);
    args.unshift(this);
    return Pot.lastIndexOf.apply(null, args);
  },
  /**
   * filter like Array.prototype.filter.
   *
   * @param  {Function}
   * @return {Pot.ArrayBufferoid}
   */
  filter : function() {
    var args = arrayize(arguments);
    args.unshift(this);
    if (args[2] === void 0) {
      args[2] = this;
    }
    return new ArrayBufferoid(Pot.filter.apply(null, args));
  },
  /**
   * forEach like Array.prototype.forEach.
   *
   * @param  {Function}
   * @return {*}
   */
  forEach : function() {
    var args = arrayize(arguments);
    args.unshift(this);
    if (args[2] === void 0) {
      args[2] = this;
    }
    return Pot.forEach.apply(null, args);
  },
  /**
   * map like Array.prototype.map.
   *
   * @param  {Function}
   * @return {Pot.ArrayBufferoid}
   */
  map : function() {
    var args = arrayize(arguments);
    args.unshift(this);
    if (args[2] === void 0) {
      args[2] = this;
    }
    return new ArrayBufferoid(Pot.map.apply(null, args));
  },
  /**
   * reduce like Array.prototype.reduce.
   *
   * @param  {Function}
   * @return {*}
   */
  reduce : function() {
    var args = arrayize(arguments);
    args.unshift(this);
    if (args[3] === void 0) {
      args[3] = this;
    }
    return Pot.reduce.apply(null, args);
  },
  /**
   * every like Array.prototype.every.
   *
   * @param  {Function}
   * @return {Boolean}
   */
  every : function() {
    var args = arrayize(arguments);
    args.unshift(this);
    if (args[2] === void 0) {
      args[2] = this;
    }
    return Pot.every.apply(null, args);
  },
  /**
   * some like Array.prototype.some.
   *
   * @param  {Function}
   * @return {Boolean}
   */
  some : function() {
    var args = arrayize(arguments);
    args.unshift(this);
    if (args[2] === void 0) {
      args[2] = this;
    }
    return Pot.some.apply(null, args);
  }
};

each(ArrayBufferoidTypes, function(n, k) {
  var name = 'to' + k;
  /**
   * @lends Pot.ArrayBufferoid.prototype
   */
  /**
   * @property {Function} toArrayBuffer
   *           Create a new ArrayBuffer with buffer.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toInt8Array
   *           Create a new Int8Array with buffer.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toUint8Array
   *           Create a new Uint8Array with buffer.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toUint8ClampedArray
   *           Create a new Uint8ClampedArray with buffer.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toInt16Array
   *           Create a new Int16Array with buffer.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toUint16Array
   *           Create a new Uint16Array with buffer.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toInt32Array
   *           Create a new Int32Array with buffer.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toUint32Array
   *           Create a new Uint32Array with buffer.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toFloat32Array
   *           Create a new Float32Array with buffer.
   *           If Typed Array not supported will returns Array.
   *
   * @property {Function} toFloat64Array
   *           Create a new Float64Array with buffer.
   *           If Typed Array not supported will returns Array.
   */
  ArrayBufferoid.fn[name] = function() {
    return ArrayBufferoid[name](bufferoidToArray(this));
  };
});

// Definition of stream methods.
update(ArrayBufferoid.fn, {
  /**
   * @lends Pot.ArrayBufferoid.prototype
   */
  /**
   * Get the Array of this buffer.
   *
   * @return {Array}   Array of this buffer.
   *
   * @type Function
   * @function
   * @public
   */
  toArray : function() {
    return bufferoidToArray(this);
  },
  /**
   * Seek offset.
   *
   * @param  {Number}  offset  Seek offset.
   * @return {Number}          Current offset.
   *
   * @type Function
   * @function
   * @public
   */
  seek : function(offset) {
    this.offset = (offset - 0) || 0;
    return this.offset;
  },
  /**
   * Get the current offset.
   *
   * @return {Number} Current offset.
   *
   * @type Function
   * @function
   * @public
   */
  tell : function() {
    return this.offset;
  },
  /**
   * Read the buffer.
   *
   * @param  {Number}             size  Reading length.
   * @return {Pot.ArrayBufferoid}       A new instance of Pot.ArrayBufferoid.
   *
   * @type Function
   * @function
   * @public
   */
  read : function(size) {
    var sz = (size - 0) || 0,
        result = this.slice(this.offset, this.offset + sz);
    this.offset += sz;
    return result;
  },
  /**
   * Write the buffer.
   *
   * @param  {Array|*} data  Data to write.
   * @return {Number}        Written length.
   *
   * @type Function
   * @function
   * @public
   */
  write : function(data) {
    var result = 0, array = arrayize(data), i = 0, len = array.length;
    for (; i < len; i++) {
      this[this.offset++] = array[i];
      result++;
    }
    return result;
  }
});

// Definition of DataView interface/methods.
// http://www.khronos.org/registry/typedarray/specs/latest/#8
// based: jDataView
update(ArrayBufferoid.fn, {
  /**
   * @lends Pot.ArrayBufferoid.prototype
   */
  /**
   * Get the Int8.
   *
   * <pre>
   * byte getInt8(unsigned long byteOffset);
   * </pre>
   *
   * @param  {Number} byteOffset
   * @return {Number} byte.
   *
   * @type Function
   * @function
   * @public
   */
  getInt8 : function (byteOffset) {
    var b = this.getUint8(byteOffset);
    return (b < 0x80) ? b : b - 0x100;
  },
  /**
   * Get the Uint8.
   *
   * <pre>
   * octet getUint8(unsigned long byteOffset);
   * </pre>
   *
   * @param  {Number} byteOffset
   * @return {Number} octet.
   *
   * @type Function
   * @function
   * @public
   */
  getUint8 : function(byteOffset) {
    var c;
    if (byteOffset != null) {
      this.offset = (byteOffset - 0) || 0;
    }
    c = this[this.offset++];
    if (isString(c)) {
      c = c.charCodeAt(0);
    }
    return c & 0xFF;
  },
  /**
   * Get the Int16.
   *
   * <pre>
   * short getInt16(unsigned long byteOffset,
   *                optional boolean littleEndian);
   * </pre>
   *
   * @param  {Number}     byteOffset
   * @param  {(Boolean)} (littleEndian)
   * @return {Number} short.
   *
   * @type Function
   * @function
   * @public
   */
  getInt16 : function(byteOffset, littleEndian) {
    var b = this.getUint16(byteOffset, littleEndian);
    return (b < 0x800) ? b : b - 0x10000;
  },
  /**
   * Get the Uint16.
   *
   * <pre>
   * unsigned short getUint16(unsigned long byteOffset,
   *                          optional boolean littleEndian);
   * </pre>
   *
   * @param  {Number}     byteOffset
   * @param  {(Boolean)} (littleEndian)
   * @return {Number} unsigned short.
   *
   * @type Function
   * @function
   * @public
   */
  getUint16 : function(byteOffset, littleEndian) {
    var b = getUint8EndianizeArray(this, byteOffset, 2, littleEndian);
    return (b[0] << 8) + b[1];
  },
  /**
   * Get the Int32.
   *
   * <pre>
   * long getInt32(unsigned long byteOffset,
   *               optional boolean littleEndian);
   * </pre>
   *
   * @param  {Number}     byteOffset
   * @param  {(Boolean)} (littleEndian)
   * @return {Number} long.
   *
   * @type Function
   * @function
   * @public
   */
  getInt32 : function(byteOffset, littleEndian) {
    var b = this.getUint32(byteOffset, littleEndian);
    return (b > 0x7FFFFFFF) ? b - Math.pow(2, 32) : b;
  },
  /**
   * Get the Uint32.
   *
   * <pre>
   * unsigned long getUint32(unsigned long byteOffset,
   *                         optional boolean littleEndian);
   * </pre>
   *
   * @param  {Number}     byteOffset
   * @param  {(Boolean)} (littleEndian)
   * @return {Number} unsigned long.
   *
   * @type Function
   * @function
   * @public
   */
  getUint32 : function(byteOffset, littleEndian) {
    var b = getUint8EndianizeArray(this, byteOffset, 4, littleEndian);
    return (b[0] * 0x1000000) + (b[1] << 16) + (b[2] << 8) + b[3];
  },
  /**
   * Get the Float32.
   *
   * <pre>
   * float getFloat32(unsigned long byteOffset,
   *                  optional boolean littleEndian);
   * </pre>
   *
   * @param  {Number}     byteOffset
   * @param  {(Boolean)} (littleEndian)
   * @return {Number} float.
   *
   * @type Function
   * @function
   * @public
   */
  getFloat32 : function(byteOffset, littleEndian) {
    var b = getUint8EndianizeArray(this, byteOffset, 4, littleEndian),
        sign = 1 - (2 * (b[0] >> 7)),
        expo = (((b[0] << 1) & 0xFF) | (b[1] >> 7)) - 0x7F,
        mant = ((b[1] & 0x7F) << 16) | (b[2] << 8) | b[3];
    if (expo === 0x80) {
      return (mant === 0) ? sign * Infinity : NaN;
    } else if (expo === -127) {
      return sign * mant * Math.pow(2, -126 - 23);
    } else {
      return sign * (1 + mant * Math.pow(2, -23)) * Math.pow(2, expo);
    }
  },
  /**
   * Get the Float64.
   *
   * <pre>
   * double getFloat64(unsigned long byteOffset,
   *                   optional boolean littleEndian);
   * </pre>
   *
   * @param  {Number}     byteOffset
   * @param  {(Boolean)} (littleEndian)
   * @return {Number} double.
   *
   * @type Function
   * @function
   * @public
   */
  getFloat64 : function(byteOffset, littleEndian) {
    var b = getUint8EndianizeArray(this, byteOffset, 8, littleEndian),
        sign = 1 - (2 * (b[0] >> 7)),
        expo = ((((b[0] << 1) & 0xFF) << 3) | (b[1] >> 4)) - 0x3FF,
        mant = ((b[1] & 0x0F) * Math.pow(2, 48)) +
                (b[2] * Math.pow(2, 40)) +
                (b[3] * Math.pow(2, 32)) +
                (b[4] * 0x1000000) +
                (b[5] * 0x10000) +
                (b[6] * 0x100) + b[7];
    if (expo === 0x400) {
      return (mant === 0) ? sign * Infinity : NaN;
    } else if (expo === -1023) {
      return sign * mant * Math.pow(2, -1022 - 52);
    } else {
      return sign * (1 + mant * Math.pow(2, -52)) * Math.pow(2, expo);
    }
  }
  //XXX: implements set* methods.
});

ArrayBufferoid.fn.init.prototype = ArrayBufferoid.fn;

// Static methods.
update(ArrayBufferoid, {
  /**
   * @lends Pot.ArrayBufferoid
   */
  /**
   * Copt the ArrayBuffer/ArrayBufferoid/Array.
   *
   *
   * @example
   *   var buffer = new ArrayBuffer(10);
   *   var view1 = new Uint8Array(buffer);
   *   var view2 = new Uint8Array(buffer);
   *   view1[0] = 10;
   *   view2[1] = 20;
   *   Pot.debug(view1[0]); // 10
   *   Pot.debug(view2[0]); // 10
   *   Pot.debug(view1[1]); // 20
   *   Pot.debug(view2[1]); // 20
   *   var copy = new Uint8Array(Pot.ArrayBufferoid.copyBuffer(buffer));
   *   copy[1] = 100;
   *   Pot.debug(copy[0]);  // 10
   *   Pot.debug(copy[1]);  // 100
   *   Pot.debug(view1[0]); // 10
   *   Pot.debug(view1[1]); // 20
   *   Pot.debug(view2[0]); // 10
   *   Pot.debug(view2[1]); // 20
   *
   *
   * @param  {TypedArray|Pot.ArrayBufferoid|Array}  buffer  Target array.
   * @return {TypedArray|Pot.ArrayBufferoid|Array}          Copy.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  copyBuffer : function(buffer) {
    var result = [], a, b, i, len;
    if (buffer) {
      if (isArrayBufferoid(buffer)) {
        result = new ArrayBufferoid(buffer);
      } else {
        if (PotSystem.hasTypedArray) {
          if (PotSystem.canCopyTypedArray) {
            result = new Uint8Array(
              new Uint8Array(
                buffer.subarray && buffer.subarray(0) || buffer
              )
            ).buffer;
          } else {
            a = new Uint8Array(buffer.buffer || buffer);
            b = [];
            len = a.length;
            for (i = 0; i < len; i++) {
              b[i] = a[i];
            }
            result = new Uint8Array(b).buffer;
          }
        } else {
          result = arrayize(buffer);
        }
      }
    }
    return result;
  },
  /**
   * Convert to ArrayBuffer from raw string.
   *
   *
   * @example
   *   var string = 'abc123';
   *   var buffer = Pot.ArrayBufferoid.binaryToBuffer(string);
   *   Pot.debug(buffer); // [97, 98, 99, 49, 50, 51]
   *
   *
   * @param  {String}             string  A binary string.
   * @return {Pot.ArrayBufferoid}         A new instance of
   *                                       Pot.ArrayBufferoid.
   * @type  Function
   * @function
   * @static
   * @public
   */
  binaryToBuffer : update(function(string) {
    var buffer = new ArrayBufferoid(),
        len, i,
        s = stringify(string);
    if (s) {
      len = s.length;
      for (i = 0; i < len; i++) {
        buffer[i] = s.charCodeAt(i) & 0xFF;
        buffer.length++;
      }
    }
    return buffer;
  }, {
    /**
     * @lends Pot.ArrayBufferoid.binaryToBuffer
     */
    /**
     * Convert to ArrayBuffer from raw string with Deferred.
     *
     *
     * @example
     *   var s = 'abc123';
     *   Pot.ArrayBufferoid.binaryToBuffer.deferred(s).then(function(res) {
     *     Pot.debug(res); // [97, 98, 99, 49, 50, 51]
     *   });
     *
     *
     * @param  {String}        string  A binary string.
     * @return {Pot.Deferred} Returns an instance of Pot.Deferred that
     *               has a result of new instance of Pot.ArrayBufferoid.
     * @type  Function
     * @function
     * @static
     * @public
     */
    deferred : function(string) {
      var buffer = new ArrayBufferoid(), s = stringify(string);
      return Deferred.repeat(s.length, function(i) {
        buffer[i] = s.charCodeAt(i) & 0xFF;
        buffer.length++;
      }).then(function() {
        return buffer;
      });
    }
  }),
  /**
   * @lends Pot.ArrayBufferoid
   */
  /**
   * Convert to raw string from ArrayBuffer.
   *
   *
   * @example
   *   var view = new Uint8Array([0x61, 0x62, 0x63]);
   *   Pot.debug(Pot.ArrayBufferoid.bufferToBinary(view)); // 'abc'
   *   var buffer = new Pot.ArrayBufferoid([0x61, 0x62, 0x63]);
   *   Pot.debug(Pot.ArrayBufferoid.bufferToBinary(buffer)); // 'abc'
   *
   *
   * @param  {Pot.ArrayBufferoid|ArrayBuffer|Array} buffer An input bytes.
   * @return {String}                                      A binary string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  bufferToBinary : update(function(buffer) {
    var result = '', chars = [], i, len, array;
    if (buffer && isArrayLike(buffer)) {
      array = arrayize(buffer);
      len = array.length;
      for (i = 0; i < len; i++) {
        chars[i] = fromUnicode(array[i]);
      }
      result = chars.join('');
    }
    return result;
  }, {
    /**
     * @lends Pot.ArrayBufferoid.bufferToBinary
     */
    /**
     * Convert to raw string from ArrayBuffer with Deferred.
     *
     *
     * @example
     *   var view = new Uint8Array([0x61, 0x62, 0x63]);
     *   var buffer = new Pot.ArrayBufferoid([0x61, 0x62, 0x63]);
     *   Pot.ArrayBufferoid.bufferToBinary.deferred(view)
     *                                    .then(function(res) {
     *     Pot.debug(res); // 'abc'
     *     return Pot.ArrayBufferoid.bufferToBinary.deferred(buffer).
     *                                              then(function(res) {
     *       Pot.debug(res); // 'abc'
     *     });
     *   });
     *
     *
     * @param  {Pot.ArrayBufferoid|ArrayBuffer|Array} buffer An input buffer.
     * @return {Pot.Deferred} Returns an instance of Pot.Deferred that has a
     *                          binary string result.
     * @type  Function
     * @function
     * @static
     * @public
     */
    deferred : function(buffer) {
      var b, fl, d = new Deferred();
      if (buffer && PotSystem.hasFileReader && PotSystem.createBlob) {
        fl = new FileReader();
        if (isArrayBufferoid(buffer)) {
          b = buffer.toArrayBuffer();
        } else {
          b = buffer.buffer || buffer;
        }
        /**@ignore*/
        fl.onload = function(ev) {
          if (ev && ev.target) {
            d.begin(ev.target.result);
          } else {
            d.raise(ev);
          }
        };
        /**@ignore*/
        fl.onerror = function(er) {
          d.raise(er);
        };
        fl.readAsBinaryString(Pot.createBlob(b));
      } else {
        d.begin(ArrayBufferoid.bufferToBinary(buffer));
      }
      return d;
    }
  }),
  /**
   * @lends Pot.ArrayBufferoid
   */
  /**
   * Convert to UTF-8 ArrayBuffer from UTF-16 string.
   *
   *
   * @example
   *   var s = 'hogeほげ';
   *   var buffer = Pot.ArrayBufferoid.stringToBuffer(s);
   *   var string = Pot.ArrayBufferoid.bufferToString(buffer);
   *   Pot.debug(buffer);
   *   // buffer:
   *   //   [104, 111, 103, 101, 227, 129, 187, 227, 129, 146]
   *   Pot.debug(s === string); // true
   *
   *
   * @param  {String}             string  UTF-16 string.
   * @return {Pot.ArrayBufferoid}         A new instance of
   *                                       Pot.ArrayBufferoid that
   *                                       UTF-8 ArrayBuffer.
   * @type  Function
   * @function
   * @static
   * @public
   */
  stringToBuffer : (function() {
    /**@ignore*/
    var add = function(b, c) {
      if (c < 0x80) {
        b[b.length++] = c;
      } else if (c < 0x800) {
        b[b.length++] = 0xC0 | ((c >>  6) & 0x1F);
        b[b.length++] = 0x80 | ((c >>  0) & 0x3F);
      } else if (c < 0x10000) {
        b[b.length++] = 0xE0 | ((c >> 12) & 0x0F);
        b[b.length++] = 0x80 | ((c >>  6) & 0x3F);
        b[b.length++] = 0x80 | ((c >>  0) & 0x3F);
      } else {
        b[b.length++] = 0xF0 | ((c >> 18) & 0x0F);
        b[b.length++] = 0x80 | ((c >> 12) & 0x3F);
        b[b.length++] = 0x80 | ((c >>  6) & 0x3F);
        b[b.length++] = 0x80 | ((c >>  0) & 0x3F);
      }
    };
    return function(string) {
      var buffer = new ArrayBufferoid(),
          len, i, j, ch, c2,
          s = stringify(string);
      if (s) {
        len = s.length;
        for (i = 0; i < len; i++) {
          ch = s.charCodeAt(i);
          if (0xD800 <= ch && ch <= 0xD8FF) {
            j = i + 1;
            if (j < len) {
              c2 = s.charCodeAt(j);
              if (0xDC00 <= c2 && c2 <= 0xDFFF) {
                ch = ((ch & 0x3FF) << 10) + (c2 & 0x3FF) + 0x10000;
                i = j;
              }
            }
          }
          add(buffer, ch);
        }
      }
      return buffer;
    };
  }()),
  /**
   * Convert to UTF-16 string from UTF-8 ArrayBuffer.
   *
   *
   * @example
   *   var s = 'hogeほげ';
   *   var buffer = Pot.ArrayBufferoid.stringToBuffer(s);
   *   var string = Pot.ArrayBufferoid.bufferToString(buffer);
   *   Pot.debug(buffer);
   *   // buffer:
   *   //   [104, 111, 103, 101, 227, 129, 187, 227, 129, 146]
   *   Pot.debug(s === string); // true
   *
   *
   * @param  {Pot.ArrayBufferoid|ArrayBuffer|Array} buffer UTF-8 ArrayBuffer.
   * @return {String}                                      UTF-16 string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  bufferToString : function(buffer) {
    var result = '', chars = [], i = 0, len,
        n, c, c2, c3, c4, code, sc, array;
    if (buffer && isArrayLike(buffer)) {
      sc = fromUnicode;
      array = arrayize(buffer);
      len = array.length;
      while (i < len) {
        c = array[i++];
        n = (c >> 4);
        if (0 <= n && n <= 7) {
          chars[chars.length] = sc(c);
        } else if (12 <= n && n <= 13) {
          c2 = array[i++];
          chars[chars.length] = sc(((c & 0x1F) << 6) | (c2 & 0x3F));
        } else if (n === 14) {
          c2 = array[i++];
          c3 = array[i++];
          chars[chars.length] = sc(((c  & 0x0F) << 12) |
                                   ((c2 & 0x3F) <<  6) |
                                   ((c3 & 0x3F) <<  0));
        } else if (i + 2 < len) {
          c2 = array[i++];
          c3 = array[i++];
          c4 = array[i++];
          code = (((c  & 0x07) << 18) |
                  ((c2 & 0x3F) << 12) |
                  ((c3 & 0x3F) <<  6) |
                  ((c4 & 0x3F) <<  0));
          if (code <= 0xFFFF) {
            chars[chars.length] = sc(code);
          } else {
            chars[chars.length] = fromCharCode(
              (code >> 10)   + 0xD7C0,
              (code & 0x3FF) + 0xDC00
            );
          }
        }
      }
      result = chars.join('');
    }
    return result;
  }
});

/**
 * @private
 * @ignore
 */
function createArrayBuffer(type, args) {
  var types = ArrayBufferoidTypes, len = args.length, val;
  if (PotSystem.hasTypedArray) {
    switch (true) {
      case ((type & types.ArrayBuffer) === type):
          return newTypedArray(Uint8Array, args).buffer;
      case ((type & types.Uint8Array) === type):
          return newTypedArray(Uint8Array, args);
      case ((type & types.Uint16Array) === type):
          return newTypedArray(Uint16Array, args);
      case ((type & types.Uint32Array) === type):
          return newTypedArray(Uint32Array, args);
      case ((type & types.Int8Array) === type):
          return newTypedArray(Int8Array, args);
      case ((type & types.Int16Array) === type):
          return newTypedArray(Int16Array, args);
      case ((type & types.Int32Array) === type):
          return newTypedArray(Int32Array, args);
      case ((type & types.Float32Array) === type):
          return newTypedArray(Float32Array, args);
      case ((type & types.Float64Array) === type):
          return newTypedArray(Float64Array, args);
      case ((type & types.Uint8ClampedArray) === type):
          if (PotSystem.hasUint8ClampedArray) {
            return newTypedArray(Uint8ClampedArray, args);
          }
    }
  }
  if (len) {
    if (len === 1) {
      val = args[0];
      if (isNumber(val)) {
        return new Array(val);
      } else if (isArrayLike(val)) {
        return arrayize(val);
      } else {
        return [val];
      }
    } else {
      return arrayize(args);
    }
  }
  return [];
}

/**
 * @private
 * @ignore
 */
function newTypedArray(co, args) {
  var a, i, len;
  switch (args.length) {
    case 0:
        return new co();
    case 1:
        return new co(args[0]);
    case 2:
        return new co(args[0], args[1]);
    case 3:
        return new co(args[0], args[1], args[2]);
    default:
        a = [];
        len = args.length;
        for (i = 0; i < len; i++) {
          a[i] = 'a[' + i + ']';
        }
        return (new Function(
          'a,c',
          Pot.format('return new c(#1);', a.join(','))
        ))(args, co);
  }
}

/**
 * @private
 * @ignore
 */
function bufferoidToArray(buffer, clear) {
  var r = [], i = 0, len = buffer.size();
  for (; i < len; i++) {
    r[i] = buffer[i];
    if (clear) {
      delete buffer[i];
    }
  }
  if (clear) {
    buffer.length = 0;
  }
  return r;
}

/**
 * @private
 * @ignore
 */
function arrayToBufferoid(buffer, array) {
  var i = 0, len = array.length;
  for (; i < len; i++) {
    buffer[i] = array[i];
  }
  buffer.length = len;
}

/**
 * @private
 * @ignore
 */
function sizeOfBufferoid(buffer, all) {
  var max = -1, keys, i = 0, k, p, len;
  if (all) {
    keys = [];
    for (p in buffer) {
      if (+p >= 0) {
        keys[keys.length] = p;
      }
    }
  } else {
    keys = Pot.keys(buffer);
  }
  len = keys.length;
  for (; i < len; i++) {
    k = +keys[i];
    if (k > max) {
      max = k;
    }
  }
  if (max >= 0) {
    max++;
  } else {
    max = 0;
  }
  buffer.length = max;
  return max;
}

/**
 * @private
 * @ignore
 */
function parseArguments(buffer, args) {
  var argn = args.length, val, i, len, a;
  switch (argn) {
    case 0:
        buffer.length = 0;
        break;
    case 1:
        val = args[0];
        if (!val) {
          buffer.length = 0;
        } else if (isNumber(val)) {
          len = val;
          for (i = 0; i < len; i++) {
            buffer[i] = void 0;
          }
          buffer.length = len;
        } else if (isArrayLike(val)) {
          
          if (isTypedArray(val)) {
            if (isArrayBuffer(val) &&
                val.byteLength != null && val[0] === void 0) {
              a = new Uint8Array(val);
            } else {
              a = val;
            }
          } else {
            a = arrayize(val);
          }
          len = a.length;
          for (i = 0; i < len; i++) {
            buffer[i] = a[i];
          }
          buffer.length = len;
        } else {
          buffer[0] = val;
          buffer.length = 1;
        }
        break;
    default:
        len = args.length;
        for (i = 0; i < len; i++) {
          buffer[i] = args[i];
        }
        buffer.length = len;
  }
}

/**
 * @private
 * @ignore
 */
function getUint8EndianizeArray(buffer, byteOffset, size, littleEndian) {
  var r = [], i = 0;
  for (; i < size; i++) {
    r[i] = buffer.getUint8(
      endianize(buffer, byteOffset, i, size, littleEndian)
    );
  }
  return r;
}

/**
 * @private
 * @ignore
 */
function endianize(buffer, byteOffset, pos, size, littleEndian) {
  var le = (littleEndian == null) ? true : littleEndian;
  if (byteOffset != null) {
    buffer.offset = (byteOffset - 0) || 0;
  }
  return buffer.offset + (le ? size - pos - 1 : pos);
}

}());

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Web Worker.
(function() {
var WorkerServer,
    WorkerChild,
    PREFIX = '.',
    RE = {
      URI  : /^(?:[\w.*=+-]+:+|)[-.!~\w\/\\?@&=+$%#^]+$/i,
      FUNC : /^[\s();]*(?:new|)[\s();]*|[\s();]*$/g,
      FUNF : /^[\s();]*(?:new|)[\s();]{0,}/,
      FUNT : /[\s();]*$/,
      HEAD : /^(?:(?![(]?[)]{0}function)[\s\S])*([(]?[)]{0}function)\b/,
      DEFF : /^[\s;{}()]*(?:new|)[\s;{}()]*function\b/,
      DEFT : /[^{]*[}][\s;]*$/,
      PREF : /^([\s;{}()]*(?:new|)[\s;{}()]*function\b[^{]+?[{])(?=[^}]*[}])/,
      ARGS : /^function\s*[^()]*?[(]\s*(?:\S[^()]*?)\s*[)]/,
      LOAD : /complete|loaded/i,
      DATA : new RegExp(
          '^' +
            'data:' +
            '((?:[\\w.*+-]+/[\\w.*+-]+|[*]|)(?=[;,])|)' +
            '(;?charset=["\']?[\\w.=*+-]+[\'"]?(?=[;,])|)' +
            '(;?base64(?=,)|)' +
            ',' +
            '([\\s\\S]*)' +
          '$',
        'i'
      ),
      MSG  : new RegExp(
              '(?:^|\\b)(?:\\[["\']|)onmessage(?:[\'"]\\]|)\\s*=' +
        '|' + '(?:^|\\b)addEventListener\\s*[(]\\s*' +
              '["\'](?:[Oo][Nn]|)[Mm][Ee][Ss][Ss][Aa][Gg][Ee][\'"]' +
              '[\\s\\S]*?[)]'
      )
    };

/**@ignore*/
WorkerServer = function(js) {
  return new WorkerServer.fn.init(js);
};

WorkerServer.fn = WorkerServer.prototype = update(WorkerServer.prototype, {
  /**
   * @ignore
   */
  constructor : WorkerServer,
  /**
   * @private
   * @ignore
   */
  child : null,
  /**
   * @private
   * @ignore
   */
  queues : [],
  /**
   * @private
   * @ignore
   */
  fired : false,
  /**
   * @private
   * @ignore
   */
  callback : null,
  /**
   * @private
   * @ignore
   */
  init : function(js) {
    this.queues = [];
    this.child = new WorkerChild(this, js);
    return this;
  },
  /**
   * @param {String} data message
   * @ignore
   */
  postMessage : function(data) {
    var that = this, child = this.child;
    this.queues.push(data);
    Deferred.till(function() {
      return child.isReady();
    }).then(function() {
      var items = arrayize(that.queues.splice(0, that.queues.length));
      return Deferred.forEach(items, function(item) {
        return Deferred.flush(function() {
          var err;
          try {
            if (child.nativeWorker) {
              child.nativeWorker.postMessage(item);
            } else {
              child.onmessage({data : item});
            }
          } catch (e) {
            err = e;
            if (!isStopIter(err)) {
              throw err;
            }
          } finally {
            that.fired = true;
          }
        });
      });
    });
  },
  /**
   * @ignore
   */
  terminate : function() {
    var child = this.child;
    if (child) {
      if (child.nativeWorker) {
        child.nativeWorker.terminate();
      }
      if (child.context && child.stopId && child.stopId in child.context) {
        child.context[child.stopId] = true;
        if (child.elem) {
          // When removes iframe in asynchronous processing will be warnings.
          Deferred.till(function() {
            return child.context[child.isStoppedId] === true;
          }).wait(1).then(function() {
            try {
              child.elem.parentNode.removeChild(child.elem);
            } catch (e) {}
            child.elem = null;
          }).ensure(function() {
            // ignore error.
          });
        }
      }
    }
  },
  /**
   * @ignore
   */
  addEventListener : function(type, func/*[, useCapture]*/) {
    if (isFunction(func)) {
      switch (stringify(type).toLowerCase()) {
        case 'message':
            this.onmessage = func;
            break;
        case 'error':
            this.onerror = func;
      }
    }
  },
  /**
   * @ignore
   */
  removeEventListener : function(type/*, func[, useCapture]*/) {
    switch (stringify(type).toLowerCase()) {
      case 'message':
          this.onmessage = null;
          break;
      case 'error':
          this.onerror = null;
    }
  }
});
WorkerServer.fn.init.prototype = WorkerServer.fn;

/**@ignore*/
WorkerChild = function(server, js) {
  return new WorkerChild.fn.init(server, js);
};

WorkerChild.fn = WorkerChild.prototype = update(WorkerChild.prototype, {
  /**
   * @ignore
   */
  constructor : WorkerChild,
  /**
   * @private
   * @ignore
   */
  server : null,
  /**
   * @private
   * @ignore
   */
  queues : [],
  /**
   * @private
   * @ignore
   */
  loaded : false,
  /**
   * @private
   * @ignore
   */
  context : {},
  /**
   * @private
   * @ignore
   */
  elem : null,
  /**
   * @private
   * @ignore
   */
  nativeWorker : null,
  /**
   * @private
   * @ignore
   */
  stopId : null,
  /**
   * @private
   * @ignore
   */
  isStoppedId : null,
  /**
   * @private
   * @ignore
   */
  usePot : false,
  /**
   * @private
   * @ignore
   */
  init : function(server, js) {
    var that = this;
    this.queues = [];
    this.server = server;
    this.context = update({}, {
      postMessage         : bind(this.postMessage, this),
      importScripts       : bind(this.importScripts, this),
      addEventListener    : bind(this.addEventListener, this),
      removeEventListener : bind(this.removeEventListener, this),
      onmessage           : null,
      onerror             : null
    });
    each({
      stopId      : ['stop',    false],
      isStoppedId : ['stopped', false]
    }, function(v, k) {
      that[k] = buildSerial(Pot, v[0]);
      that.context[that[k]] = v[1];
    });
    Deferred.flush(function() {
      that.runScript(js);
    });
    return this;
  },
  /**
   * @private
   * @ignore
   */
  compriseScript : function(script, isFunc) {
    var result = '', tokens, code, hasWorker;
    if ((PotSystem.hasWorker &&
         (PotSystem.canWorkerDataURI || PotSystem.canWorkerBlobURI)) ||
        (PotSystem.hasChromeWorker &&
         (PotSystem.canChromeWorkerDataURI || PotSystem.canChromeWorkerBlobURI))
    ) {
      hasWorker = true;
    }
    if (script) {
      if (isFunc) {
        code = Pot.getFunctionCode(script).replace(RE.FUNC, '');
      } else {
        code = stringify(script, true);
      }
      tokens = Pot.tokenize(code);
      code = Pot.joinTokens(tokens);
      this.usePot = this.isPotUsing(tokens);
      if (this.usePot && PotSystem.isMozillaBlobBuilder) {
        //XXX: Fix setTimeout and scope in Firefox's Worker thread.
        hasWorker = false;
      }
      if (RE.MSG.test(code)) {
        // STATE: has onmessage settings: onmessage = function(ev) {...}
        if (hasWorker) {
          result = this.insertProvision(tokens, isFunc);
        } else {
          if (RE.DEFF.test(code)) {
            code = Pot.format(
              '(#1).call(this);',
              code.replace(RE.HEAD, '$1').replace(RE.FUNC, '')
            );
            result = this.insertStepStatements(Pot.tokenize(code));
          } else {
            result = this.insertStepStatements(tokens);
          }
        }
      } else {
        if (RE.DEFF.test(code)) {
          code = Pot.format(
            '(#1).call(' +
              'this,' +
              '(!event||typeof event.data==="undefined")?void 0:event.data,' +
              'event' +
            ');',
            code.replace(RE.HEAD, '$1').replace(RE.FUNC, '')
          );
        }
        if (hasWorker) {
          result = this.providePot(code);
        } else {
          code = this.insertStepStatements(Pot.tokenize(code));
          result = 'onmessage=(function(){' +
            'var self=this;' +
            'return function(){' +
              'var event=arguments[0];' +
              'return(function(){' +
                code +
              '}).call(self);' +
            '};' +
          '}).call(' +
            '(typeof self!=="undefined"&&self&&' +
             'self.postMessage)?self:this' +
          ');';
        }
      }
    }
    return result;
  },
  /**
   * @private
   * @ignore
   */
  isPotUsing : function(tokens) {
    var result = false, i, j, k, len, token, next, next2;
    if (tokens) {
      len = tokens.length;
      for (i = 0; i < len; i++) {
        token = tokens[i];
        next = '';
        for (j = i + 1; j < len; j++) {
          next = tokens[j];
          if (Pot.isNL(next)) {
            continue;
          } else {
            break;
          }
        }
        next2 = '';
        for (k = j + 1; k < len; k++) {
          next2 = tokens[k];
          if (Pot.isNL(next2)) {
            continue;
          } else {
            break;
          }
        }
        switch (token) {
          case 'Pot':
              if (next === '.' ||
                  (next === '[' && next2 !== ']')) {
                result = true;
              }
        }
        if (result) {
          break;
        }
      }
    }
    return result;
  },
  /**
   * @private
   * @ignore
   */
  insertStepStatements : function(tokens) {
    var results = [],
        token, i, j, k, len, prev, next, next2, add,
        id = buildSerial(Pot, '$this$scope'),
        statements = {
          pre  : Pot.format(
            'var #1=this;' +
            'Pot.Deferred.forEver(function(){(function(){',
            id
          ),
          suf  : Pot.format(
            '}).call(#1);throw Pot.StopIteration;}).then(function(){' +
              '#2=true;' +
            '});',
            id, this.isStoppedId
          ),
          step : Pot.format(
            'if(#1){throw Pot.StopIteration;}',
            this.stopId
          )
        };
    len = tokens.length;
    for (i = 0; i < len; i++) {
      add = false;
      token = tokens[i];
      next = '';
      for (j = i + 1; j < len; j++) {
        next = tokens[j];
        if (Pot.isNL(next)) {
          continue;
        } else {
          break;
        }
      }
      next2 = '';
      for (k = j + 1; k < len; k++) {
        next2 = tokens[k];
        if (Pot.isNL(next2)) {
          continue;
        } else {
          break;
        }
      }
      switch (token) {
        case '{':
            if (prev === ')'    && next !== '}' &&
                next !== 'case' && next !== 'default' &&
                next2 !== ':') {
              add = true;
            }
      }
      if (!Pot.isNL(token)) {
        prev = token;
      }
      results[results.length] = token;
      if (add) {
        results[results.length] = statements.step;
      }
    }
    results.unshift(statements.pre + statements.step);
    results.push(statements.suf);
    return Pot.joinTokens(results);
  },
  /**
   * @private
   * @ignore
   */
  providePot : function(code) {
    var result,
        scope = buildSerial({NAME : 'scope'}, '$'),
        script = this.getPotScript();
    result = Pot.format(
      'var #1=this;' +
      'onmessage=(function(){' +
        'var self=this;' +
        'return function(){' +
          'var event=arguments[0];' +
          'if(typeof Pot==="undefined"){' +
            '(#2)(#1||{});' +
          '}' +
          'return(function(){' +
            '#3' +
          '}).call(self);' +
        '};' +
      '}).call(' +
        '(typeof self!=="undefined"&&self&&' +
         'self.postMessage)?self:this' +
      ');',
      scope,
      script,
      code
    );
    return result;
  },
  /**
   * @private
   * @ignore
   */
  insertProvision : function(tokens, isFunc) {
    var result, code, parts,
        names = {},
        script = this.getPotScript();
    each(['scope', 'script', 'func'], function(name) {
      names[name] = buildSerial({NAME : name}, '$');
    });
    parts = this.parseScript(tokens);
    code = Pot.format(
      '(function(){' +
        'var self=this;' +
        'return function(){' +
          'return(function(){' +
            'if(typeof Pot==="undefined"){' +
              '(#1)(#2||{});' +
            '}' +
            'var #3=#4;' +
            'return #3.apply(this,arguments);' +
          '}).apply(self,arguments);' +
        '};' +
      '}).call(' +
        '(typeof self!=="undefined"&&self&&' +
         'self.postMessage)?self:this' +
      ')\n',
      script,
      names.scope,
      names.func,
      parts.func
    );
    if (isFunc ||
        (RE.DEFF.test(parts.pre) && RE.DEFT.test(parts.suf))) {
      result = Pot.format(
        'var #1=this;(#2#3#4).call(this);',
        names.scope,
        parts.pre.replace(RE.FUNF, ''),
        code,
        parts.suf.replace(RE.FUNT, '')
      );
    } else {
      result = Pot.format(
        'var #1=this;#2#3#4',
        names.scope,
        parts.pre,
        code,
        parts.suf
      );
    }
    return result;
  },
  /**
   * @private
   * @ignore
   */
  getPotScript : function() {
    var script = Pot.getFunctionCode(
      PotInternal.ScriptImplementation
    ).replace(RE.FUNC, '');
    return script;
  },
  /**
   * @private
   * @ignore
   */
  parseScript : function(tokens) {
    var pres = [], sufs = [], parts = [],
        i, j, len = tokens && tokens.length,
        token, next, first, last,
        prepared, unwrap, inListener, inFunc, inPrefunc,
        level, startLevel,
        depth, startDepth,
        skip, endScope;
    for (i = 0; i < len; i++) {
      token = tokens[i];
      if (skip) {
        sufs[sufs.length] = token;
        continue;
      }
      next = '';
      for (j = i + 1; j < len; j++) {
        next = tokens[j];
        if (Pot.isNL(next)) {
          continue;
        } else {
          break;
        }
      }
      switch (token) {
        case 'onmessage':
            inListener = false;
            if (next === '=' && !inFunc && !endScope) {
              inPrefunc = true;
            }
            break;
        case 'function':
            inListener = false;
            if (prepared) {
              inFunc = true;
            }
            break;
        case 'addEventListener':
            inListener = true;
            break;
        case '=':
            if (inPrefunc && !inFunc && !endScope) {
              first = true;
              inPrefunc = false;
            }
            break;
        case '{':
            if (prepared && inFunc && !endScope) {
              startLevel = level = 1;
              prepared = false;
            } else if (inFunc && !endScope) {
              level++;
            }
            break;
        case '}':
            if (inFunc && !endScope) {
              if (level-- === startLevel) {
                endScope = true;
                if (next === '(' || next === ')' || next === '.') {
                  break;
                }
                inFunc = false;
                last = true;
              }
            }
            break;
        case '(':
            if (endScope && inFunc && startDepth == null) {
              startDepth = depth = 1;
            } else if (inFunc) {
              depth++;
            }
            break;
        case ')':
            if (endScope && inFunc) {
              if (startDepth == null) {
                if (next === '(' || next === ')' || next === '.') {
                  break;
                }
                inFunc = false;
                last = true;
              } else {
                depth--;
                if (next === '(' || next === ')' || next === '.') {
                  break;
                }
                if (depth === startDepth - 1) {
                  inFunc = false;
                  last = true;
                }
              }
            }
            break;
        case ',':
            if (inListener && inPrefunc && !inFunc && !endScope) {
              first = true;
              inPrefunc = false;
            }
            break;
        default:
            if (inListener && next === ',' &&
                ((token.charAt(0) === '"' && token.slice(-1) === '"') ||
                 (token.charAt(0) === "'" && token.slice(-1) === "'"))
            ) {
              unwrap = token.slice(1, -1).toLowerCase();
              if (unwrap === 'message') {
                inPrefunc = true;
                break;
              }
            }
            if (inListener && Pot.isWords(token)) {
              inListener = false;
            }
      }
      if (prepared || inFunc || last) {
        parts[parts.length] = token;
        if (last) {
          last = false;
          skip = true;
        }
      } else {
        pres[pres.length] = token;
        if (first) {
          prepared = true;
          first = false;
        }
      }
    }
    return {
      pre  : Pot.joinTokens(pres),
      suf  : Pot.joinTokens(sufs),
      func : Pot.joinTokens(parts)
    };
  },
  /**
   * @private
   * @ignore
   */
  loadScript : function(js, recursive) {
    var that = this, result, code,
        hasWorker, canWorkerDataURI, canWorkerBlobURI;
    if (isChromeWorkerAvailable()) {
      hasWorker = PotSystem.hasChromeWorker;
      canWorkerDataURI = hasWorker && PotSystem.canChromeWorkerDataURI;
      canWorkerBlobURI = hasWorker && PotSystem.canChromeWorkerBlobURI;
    } else {
      hasWorker = PotSystem.hasWorker;
      canWorkerDataURI = hasWorker && PotSystem.canWorkerDataURI;
      canWorkerBlobURI = hasWorker && PotSystem.canWorkerBlobURI;
    }
    if (js) {
      if (isFunction(js)) {
        code = this.compriseScript(js, true);
        if (PotSystem.isMozillaBlobBuilder && this.usePot) {
          result = [code, false];
        } else if (canWorkerBlobURI) {
          result = [toBlobURI(code), true];
        } else if (canWorkerDataURI) {
          result = [toDataURI(code), true];
        } else {
          result = [code, false];
        }
      } else {
        code = stringify(js, true);
        if (isURI(code)) {
          if (isJavaScriptScheme(code)) {
            code = this.compriseScript(fromJavaScriptScheme(code));
            if (PotSystem.isMozillaBlobBuilder && this.usePot) {
              result = [code, false];
            } else if (canWorkerBlobURI) {
              result = [toBlobURI(code), true];
            } else if (canWorkerDataURI) {
              result = [toDataURI(code), true];
            } else {
              result = [code, false];
            }
          } else if (isDataURI(code)) {
            code = this.compriseScript(fromDataURI(code));
            if (PotSystem.isMozillaBlobBuilder && this.usePot) {
              result = [code, false];
            } else if (canWorkerDataURI) {
              result = [toDataURI(code), true];
            } else if (canWorkerBlobURI) {
              result = [toBlobURI(code), true];
            } else {
              result = [code, false];
            }
          } else {
            if (recursive) {
              result = this.compriseScript(code);
            } else {
              result = getScript(code, true).then(function(res) {
                return that.loadScript(res, true);
              });
            }
          }
        } else {
          code = this.compriseScript(code);
          if (PotSystem.isMozillaBlobBuilder && this.usePot) {
            result = [code, false];
          } else if (canWorkerBlobURI) {
            result = [toBlobURI(code), true];
          } else if (canWorkerDataURI) {
            result = [toDataURI(code), true];
          } else {
            result = [code, false];
          }
        }
      }
    }
    return Deferred.maybeDeferred(result);
  },
  /**
   * @private
   * @ignore
   */
  runScript : function(js) {
    var that = this;
    return this.loadScript(js).then(function(code, useNative) {
      var elem;
      if (code) {
        if (useNative) {
          that.nativeWorker = createWorker(code);
          that.loaded = true;
        } else {
          if (PotSystem.isWebBrowser && PotSystem.isNotExtension) {
            elem = runWithFrame(code, that.context, that);
          }
          if (elem) {
            that.elem = elem;
            Deferred.till(function() {
              return isFrameLoaded(elem);
            }).then(function() {
              that.loaded = true;
            });
          } else {
            runWithFunction(code, that.context);
            that.loaded = true;
          }
        }
      }
    });
  },
  /**
   * @private
   * @ignore
   */
  isReady : function() {
    this.referEvents();
    return this.loaded && (
      (this.nativeWorker && this.nativeWorker.onmessage) ||
      (isFunction(this.server.onmessage) && isFunction(this.onmessage))
    );
  },
  /**
   * @private
   * @ignore
   */
  referEvents : function() {
    if (this.nativeWorker) {
      if (this.server.onmessage) {
        this.nativeWorker.onmessage = this.server.onmessage;
      }
      if (this.server.onerror) {
        this.nativeWorker.onerror = this.server.onerror;
      }
    } else if (this.context) {
      if (this.context.onmessage) {
        this.onmessage = this.context.onmessage;
      }
      if (this.context.onerror) {
        this.onerror = this.context.onerror;
      }
    }
  },
  /**
   * @private
   * @ignore
   */
  postMessage : function(data) {
    var that = this;
    this.queues.push(data);
    return Deferred.till(function() {
      return that.isReady() && that.server.fired;
    }).then(function() {
      var items = arrayize(that.queues.splice(0, that.queues.length));
      return Deferred.forEach(items, function(item) {
        return Deferred.flush(function() {
          var err;
          try {
            that.server.onmessage({data : item});
          } catch (e) {
            err = e;
            if (!isStopIter(err)) {
              throw err;
            }
          }
        });
      });
    });
  },
  /**
   * @private
   * @ignore
   */
  importScripts : function() {
    var that = this, i, args = arguments, len = args.length, js;
    for (i = 0; i < len; i++) {
      js = stringify(args[i]);
      if (js) {
        getScript(js, true).then(function(code) {
          if (that.elem) {
            runSubScriptWithFrame(code, that.elem, that.context);
          } else {
            Pot.globalEval(code);
          }
        });
      }
    }
  },
  /**
   * @private
   * @ignore
   */
  addEventListener : function(type, func/*[, useCapture]*/) {
    if (isFunction(func)) {
      switch (stringify(type).toLowerCase()) {
        case 'message':
            this.onmessage = func;
            break;
        case 'error':
            this.onerror = func;
      }
    }
  },
  /**
   * @private
   * @ignore
   */
  removeEventListener : function(type/*, func[, useCapture]*/) {
    switch (stringify(type).toLowerCase()) {
      case 'message':
          this.onmessage = null;
          break;
      case 'error':
          this.onerror = null;
    }
  }
});
WorkerChild.fn.init.prototype = WorkerChild.fn;

// Definition of Pot.Workeroid.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Pot.Workeroid implements an API for running scripts in the background
   *  independently of any user interface scripts that is inherited from the
   *  native Worker.
   * Pot.Workeroid emulates native Worker API if user environment not has
   *  Web Worker.
   * This allows for background tasks for long-running scripts or
   *  heavy-weight processing that are not interrupted by scripts that
   *  respond to user interactions.
   *
   *
   * @example
   *   var worker = new Pot.Workeroid(function(data) {
   *     // This function scope is a child Worker's "onmessage" that
   *     //  will be other process or thread.
   *     switch (data) {
   *       case 'foo':
   *           postMessage('foo!');
   *           break;
   *       case 'bar':
   *           postMessage('bar!');
   *           break;
   *       default:
   *           postMessage('hello!');
   *           break;
   *     }
   *   });
   *   // You can coding like same usage of native Worker.
   *   worker.onmessage = function(data) {
   *     Pot.debug(data);
   *   };
   *   worker.onerror = function(err) {
   *     Pot.debug(err);
   *   };
   *   // Sends data and starts Worker thread.
   *   worker.postMessage('foo');
   *   // -- results --
   *   //  This will be received a message "foo!" from a child Worker.
   *   //
   *
   *
   * @param  {String|Function|Object|*} script Script that will runs in
   *                                             child processing.
   * @return {Pot.Workeroid}                   Returns an instance of
   *                                             Pot.Workeroid.
   *
   * @name  Pot.Workeroid
   * @class
   * @constructor
   * @public
   */
  Workeroid : function(script) {
    return isWorkeroid(this) ? this.init(script)
                             : new Workeroid.fn.init(script);
  }
});

// Refer the Pot properties/functions.
Workeroid = Pot.Workeroid;

Workeroid.fn = Workeroid.prototype = update(Workeroid.prototype, {
  /**
   * @lends Pot.Workeroid.prototype
   */
  /**
   * @ignore
   */
  constructor : Workeroid,
  /**
   * @private
   * @ignore
   */
  id : PotInternal.getMagicNumber(),
  /**
   * A unique strings.
   *
   * @type  String
   * @const
   */
  serial : null,
  /**
   * @private
   * @ignore
   * @const
   */
  NAME : 'Workeroid',
  /**
   * toString.
   *
   * @return  Return formatted string of object.
   * @type Function
   * @function
   * @public
   */
  toString : PotToString,
  /**
   * isWorkeroid.
   *
   * @type Function
   * @function
   * @public
   */
  isWorkeroid : isWorkeroid,
  /**
   * @private
   * @ignore
   */
  workers : {},
  /**
   * @private
   * @ignore
   */
  workerLength : 0,
  /**
   * @private
   * @ignore
   */
  singleKey : null,
  /**
   * Initialize properties
   *
   * @private
   * @ignore
   */
  init : function(script) {
    var that = this;
    if (!this.serial) {
      this.serial = buildSerial(this);
    }
    clearWorkers.call(this);
    if (script) {
      if (isObject(script)) {
        this.singleKey = null;
        each(script, function(val, name) {
          addWorker.call(that, name, val);
        });
      } else {
        this.singleKey = buildSerial(this);
        addWorker.call(this, this.singleKey, script);
      }
    }
    return this;
  },
  /**
   * Post a message.
   *
   * @param  {String}         data   Message.
   * @return {Pot.Workeroid}         Returns an instance of Pot.Workeroid.
   *
   * @type Function
   * @function
   * @public
   */
  postMessage : function(/*[name,] data*/) {
    var that = this, args = arguments,
        data = {}, i, len = args.length;
    switch (len) {
      case 0:
          if (this.singleKey) {
            data[this.singleKey] = void 0;
          }
          break;
      case 1:
          if (isObject(args[0])) {
            data = args[0];
          } else {
            data[this.singleKey] = args[0];
          }
          break;
      case 2:
          data[args[0]] = args[1];
          break;
      default:
          i = 0;
          do {
            data[args[i++]] = args[i++];
          } while (i < len);
    }
    referWorkerEvents.call(this);
    each(data, function(val, name) {
      var msg = val, worker = getWorker.call(that, name);
      if (msg == null) {
        msg = null;
      }
      if (worker && worker.postMessage) {
        worker.postMessage(msg);
      }
    });
    return this;
  },
  /**
   * Terminate process.
   *
   * @return {Pot.Workeroid}  Returns an instance of Pot.Workeroid.
   *
   * @type Function
   * @function
   * @public
   */
  terminate : function(/*[name]*/) {
    var that = this, args = arguments, len = args.length, names;
    switch (len) {
      case 0:
          clearWorkers.call(this);
          break;
      case 1:
          names = arrayize(args[0]);
          break;
      default:
          names = arrayize(args);
    }
    if (names) {
      each(names, function(name) {
        removeWorker.call(that, name);
      });
    }
    return this;
  },
  /**
   * Add an event.
   *
   * @param  {String}        type  Event type. ('message' or 'error').
   * @param  {Function}      func  Event callback function.
   * @return {Pot.Workeroid}       Returns an instance of Pot.Workeroid.
   *
   * @type Function
   * @function
   * @public
   */
  addEventListener : function(type, func/*[, useCapture]*/) {
    if (isFunction(func)) {
      switch (stringify(type).toLowerCase()) {
        case 'message':
            this.onmessage = func;
            break;
        case 'error':
            this.onerror = func;
      }
    }
    return this;
  },
  /**
   * Remove an event.
   *
   * @param  {String}        type  Event type. ('message' or 'error').
   * @return {Pot.Workeroid}       Returns an instance of Pot.Workeroid.
   *
   * @type Function
   * @function
   * @public
   */
  removeEventListener : function(type/*, func[, useCapture]*/) {
    switch (stringify(type).toLowerCase()) {
      case 'message':
          this.onmessage = null;
          break;
      case 'error':
          this.onerror = null;
    }
    return this;
  }
});

// ----- helper functions -----
/**
 * @private
 * @ignore
 */
function referWorkerEvents() {
  var that = this;
  each(this.workers, function(worker) {
    if (worker) {
      if (isFunction(that.onmessage)) {
        /**@ignore*/
        worker.onmessage = function(ev) {
          that.onmessage.call(that, ev && ev.data, ev);
          worker.callback && worker.callback(ev && ev.data);
        };
      }
      if (that.onerror) {
        worker.onerror = that.onerror;
      }
    }
  });
}

/**
 * @private
 * @ignore
 */
function toWorkerKey(name) {
  return PREFIX + name;
}

/**
 * @private
 * @ignore
 */
function newWorker(script) {
  return new WorkerServer(script);
}

/**
 * @private
 * @ignore
 */
function hasWorkerByName(name) {
  return (toWorkerKey(name) in this.workers);
}

/**
 * @private
 * @ignore
 */
function addWorker(name, script) {
  var key = toWorkerKey(name);
  if (hasWorkerByName.call(this)) {
    removeWorker.call(this, name);
  }
  this.workers[key] = newWorker(script);
  this.workerLength++;
}

/**
 * @private
 * @ignore
 */
function getWorker(name) {
  return this.workers[toWorkerKey(name)];
}

/**
 * @private
 * @ignore
 */
function removeWorker(name) {
  var key = toWorkerKey(name),
      worker = this.workers[key];
  if (worker) {
    if (worker.terminate) {
      worker.terminate();
    }
    this.workers[key] = worker = null;
    delete this.workers[key];
    this.workerLength--;
  }
}

/**
 * @private
 * @ignore
 */
function clearWorkers() {
  var that = this;
  if (this.workers) {
    each(this.workers, function(worker, key) {
      if (key && key.charAt && key.charAt(0) === PREFIX) {
        removeWorker.call(that, key.substring(1));
      }
    });
  }
  this.workers = {};
  this.workerLength = 0;
}

// ----- utilities -----
/**
 * @private
 * @ignore
 */
function bind(func, context) {
  var that = context || null;
  return function() {
    return func.apply(that, arguments);
  };
}

/**
 * @private
 * @ignore
 */
function mergeObjects(context) {
  var locations = {};
  if (typeof location !== 'undefined' && !!location) {
    each([
      'href', 'protocol', 'host', 'hostname',
      'port', 'pathname', 'search', 'hash'
    ], function(key) {
      try {
        locations[key] = stringify(location[key]);
      } catch (e) {}
    });
  }
  each(['window', 'document', 'navigator'], function(v) {
    context[v] = void 0;
  });
  context['location'] = locations;
  context['self'] = context;
  context['Pot'] = Pot;
}

/**
 * @private
 * @ignore
 */
function runWithFunction(code, context) {
  mergeObjects(context);
  return (new Function('with(this){' + code + '}')).call(context);
}

/**
 * @private
 * @ignore
 */
function runWithFrame(code, context, child) {
  var result = false, win, doc, iframe, id, childWin, style, ie, version;
  win = Pot.currentWindow();
  doc = Pot.currentDocument();
  if (win && doc && win.document === doc && doc.body) {
    ie = !!(PotBrowser.msie && PotSystem.hasActiveXObject);
    if (ie) {
      version = parseInt(PotBrowser.msie.version, 10);
    }
    do {
      id = buildSerial({NAME : 'potiframeworker'}, '');
    } while ((id in win) || doc.getElementById(id));
    if (ie && version <= 7) {
      iframe = doc.createElement('<iframe name="' + id + '">');
    } else {
      iframe = doc.createElement('iframe');
    }
    child.elem = iframe;
    iframe.name = iframe.id = id;
    iframe.frameBorder = 0;
    if (ie && version < 7) {
      iframe.src = 'javascript:[]+[]';
    }
    style = iframe.style;
    style.zIndex = -1;
    style.visibility = style.overflow = 'hidden';
    style.border = style.outline = style.margin = style.padding = '0';
    style.minWidth = style.minHeight = '0px';
    style.width = style.height = style.maxWidth = style.maxHeight = '10px';
    if (PotBrowser.webkit) {
      // Safari 2.0.* bug: iframe's absolute position and src set.
      style.marginTop = style.marginLeft = '-10px';
    } else {
      style.position = 'absolute';
      style.top = style.left = '-20px';
    }
    doc.body.appendChild(iframe);
    childWin = iframe.contentWindow || (win.frames && win.frames[id]);
    doc = detectFrameDocument(iframe);
    if (!doc || !childWin || !doc.write) {
      try {
        iframe.parentNode.removeChild(iframe);
      } catch (e) {}
      child.elem = null;
    } else {
      doc.open();
      each(context, function(v, k) {
        childWin[k] = v;
      });
      mergeObjects(context);
      do {
        id = buildSerial(Pot, '$');
      } while (id in childWin);
      childWin[id] = context;
      doc.write(
        '<!doctype html><html><head>' +
        wrapScript(Pot.format(
          '(function(){with(#1){' +
            '#2' +
          '}}).call(#1);',
          id, code
        )) +
        '</head><body><br></body></html>'
      );
      doc.close();
      result = iframe;
    }
  }
  return result;
}

/**
 * @private
 * @ignore
 */
function runSubScriptWithFrame(js, iframe, context) {
  var pwin, win, doc, head, script, done, func, code, id, val = 'val';
  pwin = Pot.currentWindow();
  win = iframe.contentWindow ||
        (pwin && pwin.frames && pwin.frames[iframe.id]);
  if (win) {
    doc = detectFrameDocument(iframe);
    do {
      id = buildSerial(Pot, '$');
    } while (id in win);
    win[id] = context;
    code = 'with(' + id + '){' + js + '}';
    if (doc) {
      head = doc.getElementsByTagName('head');
      if (head && head[0]) {
        head = head[0];
      } else {
        head = doc.head || doc.body || doc.documentElement;
      }
      if (head) {
        script = doc.createElement('script');
        script.type = 'text/javascript';
        script.defer = script.async = false;
        if (PotSystem.hasActiveXObject && 'text' in script) {
          script.text = code;
        } else {
          script.appendChild(doc.createTextNode(code));
        }
        head.appendChild(script);
        head.removeChild(script);
        done = true;
      }
    }
    if (!done) {
      func = ['e'] + val;
      if (win[func]) {
        if (win[func].call && win[func].apply) {
          win[func].call(win, code);
        } else {
          win[func](code);
        }
        done = true;
      }
    }
  }
  return done;
}

/**
 * @private
 * @ignore
 */
function isFrameLoaded(frame) {
  var result = false, doc;
  try {
    if (frame) {
      if (PotSystem.hasActiveXObject && RE.LOAD.test(frame.readyState)) {
        result = true;
      } else {
        doc = detectFrameDocument(frame);
        if (doc) {
          result = !!(doc.body && doc.body.firstChild);
        }
      }
    }
  } catch (e) {}
  return result;
}

/**
 * @private
 * @ignore
 */
function detectFrameDocument(frame) {
  var isWin = isWindow, isDoc = isDocument;
  if (frame == null) {
    return null;
  }
  if (isWin(frame.contentWindow) && isDoc(frame.contentWindow.document)) {
    return frame.contentWindow.document;
  }
  if (isDoc(frame.contentDocument)) {
    return frame.contentDocument;
  }
  if (isDoc(frame.document)) {
    return frame.document;
  }
  return null;
}

/**
 * @private
 * @ignore
 */
function isDataURI(uri) {
  return stringify(uri).slice(0, 5).toLowerCase() === 'data:';
}

/**
 * @private
 * @ignore
 */
function isJavaScriptScheme(uri) {
  return stringify(uri).slice(0, 11).toLowerCase() === 'javascript:';
}

/**
 * @private
 * @ignore
 */
function isURI(src) {
  return RE.URI.test(stringify(src));
}

/**
 * @private
 * @ignore
 */
function fromJavaScriptScheme(uri) {
  var data = '';
  if (isJavaScriptScheme(uri)) {
    data = stringify(uri).substring(11);
  }
  return data;
}

/**
 * @private
 * @ignore
 */
function toDataURI(code) {
  return 'data:application/javascript,' + Pot.URI.urlEncode(code);
}

/**
 * @private
 * @ignore
 */
function fromDataURI(uri) {
  var data = '', m;
  if (isDataURI(uri)) {
    RE.DATA.lastIndex = 0;
    m = RE.DATA.match(uri);
    if (m && m[4]) {
      data = m[4];
      if (m[3]) {
        data = fromBase64(data);
      } else {
        data = Pot.URI.urlDecode(data);
      }
    }
  }
  return data;
}

/**
 * @private
 * @ignore
 */
function toBlobURI(code) {
  return PotSystem.BlobURI.createObjectURL(Pot.createBlob(code));
}

/**
 * @private
 * @ignore
 */
function fromBase64(string) {
  if (Pot.Base64) {
    return Pot.Base64.decode(string);
  }
  if (!fromBase64.decode) {
    /**@ignore*/
    fromBase64.decode = (function() {
      var maps = UPPER_ALPHAS + LOWER_ALPHAS + DIGITS + '+/=',
          /**@ignore*/
          utf8decode = function(s) {
            if (Pot.UTF8) {
              return Pot.UTF8.decode(s);
            }
            try {
              return Pot.URI.urlDecode(escape(s));
            } catch (e) {
              try {
                return decodeURIComponent(escape(s));
              } catch (ex) {
                return s;
              }
            }
          };
      return function(data) {
        var t = '', p = -8, a = 0, c, d, i = 0,
            s = stringify(data), len = s.length;
        for (; i < len; i++) {
          c = maps.indexOf(s.charAt(i));
          if (c >= 0) {
            a = (a << 6) | (c & 63);
            if ((p += 6) >= 0) {
              d = a >> p & 255;
              if (c !== 64) {
                t += fromUnicode(d);
              }
              a &= 63;
              p -= 8;
            }
          }
        }
        return utf8decode(t);
      };
    }());
  }
  return fromBase64.decode(string);
}

/**
 * @private
 * @ignore
 */
function createWorker(js) {
  return isChromeWorkerAvailable() ? new ChromeWorker(js) : new Worker(js);
}

/**
 * @private
 * @ignore
 */
function isChromeWorkerAvailable() {
  var cw = 0, w = 0;
  if (PotSystem.hasChromeWorker) {
    cw++;
    if (PotSystem.canChromeWorkerDataURI) {
      cw++;
    }
    if (PotSystem.canChromeWorkerBlobURI) {
      cw++;
    }
  }
  if (PotSystem.hasWorker) {
    w++;
    if (PotSystem.canWorkerDataURI) {
      w++;
    }
    if (PotSystem.canWorkerBlobURI) {
      w++;
    }
  }
  return cw >= w;
}

/**
 * @private
 * @ignore
 */
function wrapScript(code) {
  return ['<script>' + code + '</'] + ['script>'];
}

/**
 * @private
 * @ignore
 */
function getScript(url, sync) {
  var type = 'application/javascript';
  return Pot.Net.request(url, {
    sync     : sync,
    mimeType : type,
    headers  : {
      'Content-Type' : type
    }
  }).then(function(res) {
    return stringify(res && res.responseText);
  });
}

}());

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Serializer.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Serializer.
   *
   * Provides the JSON.stringify and the JSON.parse methods.
   * If JSON object is in Built-in then will use native method.
   *
   * @name  Pot.Serializer
   * @type  Object
   * @class
   * @public
   * @static
   */
  Serializer : {}
});

(function() {
  var NULL, JSONSerializer;
  if (typeof JSON === 'object' &&
      Pot.isBuiltinMethod(JSON.stringify) &&
      Pot.isBuiltinMethod(JSON.parse)
  ) {
    update(Pot.Serializer, {
      /**@ignore*/
      serializeToJSON : function() {
        return JSON.stringify.apply(null, arguments);
      },
      /**@ignore*/
      parseFromJSON : function() {
        return JSON.parse.apply(null, arguments);
      }
    });
    return;
  }
  NULL = 'null';
  JSONSerializer = update(function() {}, {
    /**@ignore*/
    charsCache : {
      '\"'   : '\\"',
      '\\'   : '\\\\',
      '/'    : '\\/',
      '\b'   : '\\b',
      '\f'   : '\\f',
      '\n'   : '\\n',
      '\r'   : '\\r',
      '\t'   : '\\t',
      '\x0B' : '\\u000B'
    },
    /**@ignore*/
    replaceTo : /\uFFFF/.test('\uFFFF')      ?
                /[\\\"\x00-\x1F\x7F-\uFFFF]/g :
                /[\\\"\x00-\x1F\x7F-\xFF]/g
  });
  /**
   * @private
   * @ignore
   */
  JSONSerializer.prototype = update(JSONSerializer.prototype, {
    /**
     * @private
     * @ignore
     */
    serialize : function(object) {
      var json = [];
      this.serializeAll(object, json);
      return json.join('');
    },
    /**
     * @private
     * @ignore
     */
    serializeAll : function(object, json) {
      if (object == null) {
        json[json.length] = NULL;
      } else {
        switch (typeOf(object)) {
          case 'string':
              this.serializeString(object, json);
              break;
          case 'number':
              this.serializeNumber(object, json);
              break;
          case 'boolean':
              json[json.length] = (object == true) ? 'true' : 'false';
              break;
          case 'array':
              this.serializeArray(object, json);
              break;
          case 'object':
          case 'error':
              this.serializeObject(object, json);
              break;
          case 'date':
              this.serializeDate(object, json);
              break;
          case 'regexp':
              this.serializeString(object.toString(), json);
              break;
          case 'function':
              break;
          default:
              json[json.length] = NULL;
        }
      }
    },
    /**
     * @private
     * @ignore
     */
    padZero : function(n) {
      return (n < 10) ? '0' + n : n;
    },
    /**
     * @private
     * @ignore
     */
    serializeDate : function(d, json) {
      var pad = this.padZero;
      result = isFinite(d.valueOf())   ? '"' +
              d.getUTCFullYear()       + '-' +
              pad(d.getUTCMonth() + 1) + '-' +
              pad(d.getUTCDate())      + 'T' +
              pad(d.getUTCHours())     + ':' +
              pad(d.getUTCMinutes())   + ':' +
              pad(d.getUTCSeconds())   + 'Z' + '"' : NULL;
      json[json.length] = result;
    },
    /**
     * @private
     * @ignore
     */
    serializeString : function(s, json) {
      var cs = s.replace(JSONSerializer.replaceTo, function(c) {
        var cc, rv;
        if (c in JSONSerializer.charsCache) {
          return JSONSerializer.charsCache[c];
        }
        cc = c.charCodeAt(0);
        rv = '\\u';
        if (cc < 16) {
          rv += '000';
        } else if (cc < 256) {
          rv += '00';
        } else if (cc < 4096) {
          rv += '0';
        }
        rv = rv + cc.toString(16);
        JSONSerializer.charsCache[c] = rv;
        return rv;
      });
      json[json.length] = '"' + cs + '"';
    },
    /**
     * @private
     * @ignore
     */
    serializeNumber : function(n, json) {
      json[json.length] = (isFinite(n) && !isNaN(n)) ? n : NULL;
    },
    /**
     * @private
     * @ignore
     */
    serializeArray : function(a, json) {
      var len, sep = '', i, ok, val;
      len = a && a.length;
      json[json.length] = '[';
      for (i = 0; i < len; i++) {
        ok = true;
        try {
          val = a[i];
        } catch (e) {
          ok = false;
        }
        if (ok) {
          json[json.length] = sep;
          this.serializeAll(val, json);
          sep = ',';
        }
      }
      json[json.length] = ']';
    },
    /**
     * @private
     * @ignore
     */
    serializeObject : function(o, json) {
      var sep = '', key, ok, value;
      json[json.length] = '{';
      for (key in o) {
        ok = true;
        if (hasOwnProperty.call(o, key)) {
          try {
            value = o[key];
            if (isFunction(value)) {
              throw value;
            }
          } catch (e) {
            ok = false;
          }
          if (ok) {
            json[json.length] = sep;
            this.serializeString(key, json);
            json[json.length] = ':';
            this.serializeAll(value, json);
            sep = ',';
          }
        }
      }
      json[json.length] = '}';
    }
  });
  update(Pot.Serializer, {
    /**
     * @lends Pot.Serializer
     */
    /**
     * `serializeToJSON` will convert any object to a stringify JSON.
     *
     * Arguments `replacer` and `space` are unimplemented.
     *
     *
     * @example
     *   debug(serializeToJSON(100));
     *   // @results "100"
     *   debug(serializeToJSON('100'));
     *   // @results "\"100\""
     *   debug(serializeToJSON('hoge'));
     *   // @results "\"hoge\""
     *   debug(serializeToJSON(null));
     *   // @results "null"
     *   debug(serializeToJSON(true));
     *   // @results "true"
     *   debug(serializeToJSON(false));
     *   // @results "false"
     *   debug(serializeToJSON('Hello\nWorld!\n'));
     *   // @results "\"Hello\\nWorld!\\n\""
     *   debug(serializeToJSON([1, 2, 3]));
     *   // @results "[1,2,3]"
     *   debug(serializeToJSON([1E1, '(///"v"///)']));
     *   // @results "[10,\"(///\\\"v\\\"///)\"]"
     *   debug(serializeToJSON({'Hello\nWorld!': [1, {a: '{ABC}'}]}));
     *   // @results "{\"Hello\\nWorld!\":[1,{\"a\":\"{ABC}\"}]}"
     *   debug(serializeToJSON({key1: function() {}, key2: new Date()}));
     *   // @results "{\"key2\":\"2011-08-30T16:32:28Z\"}"
     *
     *
     * @param  {*}              value      A target object.
     * @param  {Function}      (replacer)  (Optional) Unimplemented.
     * @param  {Number|String} (space)     (Optional) Indent.
     * @return {String}                    Return a JSON object as string.
     * @type   Function
     * @function
     * @static
     * @public
     */
    serializeToJSON : function(value/*[, replacer[, space]]*/) {
      return (new JSONSerializer()).serialize(value);
    },
    /**
     * `parseFromJSON` will parse a JSON object and convert to any object.
     *
     * Argument `reviver` is unimplemented.
     *
     *
     * @example
     *   debug(parseFromJSON('"hoge"'));
     *   // @results 'hoge'
     *   debug(parseFromJSON('null'));
     *   // @results null
     *   debug(parseFromJSON('true'));
     *   // @results true
     *   debug(parseFromJSON('false'));
     *   // @results false
     *   debug(parseFromJSON('"Hello\\u000aWorld!\\u000a"'));
     *   // @results 'Hello\nWorld!\n'
     *   debug(parseFromJSON('[1,2,3]'));
     *   // @results [1,2,3]
     *   debug(parseFromJSON('[1E1,"(///\\"v\\"///)"]'));
     *   // @results [10,'(///"v"///)']
     *   debug(parseFromJSON('{"Hello\\u000aWorld!":[1,{"a":"{ABC}"}]}'));
     *   // @results {'Hello\nWorld!':[1,{a:'{ABC}'}]}
     *   debug(parseFromJSON('{"key1":"12345","key2":null}'));
     *   // @results {key1:'12345',key2:null}
     *
     *
     * @param  {String}    text      A target JSON string object.
     * @param  {*}        (reviver)  (Optional) Unimplemented.
     * @return {*}                   Return the parsed object.
     * @type   Function
     * @function
     * @static
     * @public
     */
    parseFromJSON : update(function(text/*[, reviver]*/) {
      var me = Pot.Serializer.parseFromJSON, o;
      o = String(text).replace(me.PATTERNS.CLEAN, '');
      if (me.isValid(me, o)) {
        return Pot.localEval('(' + o + ')');
      } else {
        throw new Error('Invalid JSON string: ' + o);
      }
    }, {
      /**
       * @ignore
       */
      PATTERNS : {
        META      : /\\["\\\/bfnrtu]/g,
        STRING    : /"[^"\\\n\r\u2028\u2029\x00-\x08\x10-\x1F\x80-\x9F]*"/g,
        EXPRS     : /true|false|null|[+-]?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?/g,
        BRACKETS  : /(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,
        REMAINDER : /^[\],:{}\s\u2028\u2029]*$/,
        SPACE     : /^\s*$/,
        CLEAN     : /^(?:[{[(']{0}[')\]}]+|)[;\s\u00A0]*|[;\s\u00A0]*$/g
      },
      /**
       * @ignore
       */
      isValid : function(that, s) {
        var at = '@', bracket = '[]'.charAt(1), re = that.PATTERNS;
        if (re.SPACE.test(s)) {
          return false;
        }
        return re.REMAINDER.test(
          s.replace(re.META,     at)
           .replace(re.STRING,   bracket)
           .replace(re.EXPRS,    bracket)
           .replace(re.BRACKETS, '')
        );
      }
    })
  });
}());

update(Pot.Serializer, {
  /**
   * @lends Pot.Serializer
   */
  /**
   * Serializes an key-value object to query-string format string.
   *
   *
   * @example
   *   var query = {foo: 1, bar: 'bar2', baz: null};
   *   debug(serializeToQueryString(query));
   *   // @results 'foo=1&bar=bar2&baz='
   *
   *
   * @example
   *   // Example of the items() format.
   *   var query = [['prototype', 'value1'], ['__iterator__', 'value2']];
   *   debug(serializeToQueryString(query));
   *   // @results 'prototype=value1&__iterator__=value2'
   *
   *
   * @example
   *   // Example of needless key.
   *   var query = {'': 'http://www.example.com/'};
   *   debug(serializeToQueryString(query));
   *   // @results 'http%3A%2F%2Fwww.example.com%2F'
   *
   *
   * @example
   *   var query = 'a=value1&b=value2';
   *   debug(serializeToQueryString(query));
   *   // @results 'a=value1&b=value2'
   *
   *
   * @example
   *   var query = {foo: 'bar', baz: ['qux', 'quux'], corge: ''};
   *   debug(serializeToQueryString(query));
   *   // @results 'foo=bar&baz[]=qux&baz[]=quux&corge='
   *
   *
   * @param  {Object|Array|*}  params    The target object.
   * @return {String}                    The query-string of builded result.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  serializeToQueryString : function(params) {
    var queries = [], encode, objectLike;
    if (!params || params == false) {
      return '';
    }
    if (typeof Buffer !== 'undefined' && params.constructor === Buffer) {
      return params;
    }
    if (isString(params)) {
      return stringify(params);
    }
    objectLike = isObject(params);
    if (objectLike || isArrayLike(params)) {
      encode = Pot.URI.urlEncode;
      each(params, function(v, k) {
        var item, key, val, sep, count = 0, ok = true;
        if (objectLike) {
          item = [k, v];
        } else {
          item = v;
        }
        try {
          key = stringify(item[0], false);
          val = item[1];
        } catch (e) {
          ok = false;
        }
        if (ok && (key || val)) {
          if (!objectLike) {
            each(params, function(items) {
              if (items) {
                try {
                  if (stringify(items[0], false) === key) {
                    count++;
                  }
                } catch (e) {}
              }
            });
          }
          if (count > 1 || isArray(val)) {
            sep = '=';
            key = stringify(key, true) + '[]';
          } else {
            sep = key ? '=' : '';
          }
          each(arrayize(val), function(t) {
            queries[queries.length] = encode(key) + sep +
                                      encode(stringify(t, false));
          });
        }
      });
    }
    return queries.join('&');
  },
  /**
   * Parse the query-string to the items() format array
   *   or the key-value object.
   * The default result will be the items() format array.
   *
   *
   * @example
   *   // Default is the items() format.
   *   var query = 'foo=1&bar=bar2&baz=';
   *   debug(parseFromQueryString(query));
   *   // @results [['foo', '1'], ['bar', 'bar2'], ['baz', '']]
   *
   *
   * @example
   *   // Specify "toObject".
   *   var query = 'key1=value1&key2=value2';
   *   debug(parseFromQueryString(query, true));
   *   // @results {key1: 'value1', key2: 'value2'}
   *
   *
   * @example
   *   // Invalid key names.
   *   var query = 'prototype=value1&__iterator__=value2';
   *   debug(parseFromQueryString(query));
   *   // @results [['prototype', 'value1'], ['__iterator__', 'value2']]
   *
   *
   * @example
   *   // Example of needless key.
   *   var query = 'http%3A%2F%2Fwww.example.com%2F';
   *   debug(parseFromQueryString(query));
   *   // @results [['', 'http://www.example.com/']]
   *
   *
   * @example
   *   var query = '%40A=16%5E2%262&%40B=(2%2B3%3E%3D1)';
   *   debug(parseFromQueryString(query, true));
   *   // @results {'@A': '16^2&2', '@B': '(2+3>=1)'}
   *
   *
   * @example
   *   var query = 'foo=bar&baz[]=qux&baz[]=quux&corge=';
   *   debug(parseFromQueryString(query, true));
   *   // @results {foo: 'bar', baz: ['qux', 'quux'], corge: ''}
   *
   *
   * @param  {String}   queryString   The query-string to parse.
   * @param  {Boolean}  (toObject)    Whether to return as
   *                                    an key-value object.
   *                                  Note that if invalid key name
   *                                    included then an object will
   *                                    be broken.
   *                                    (e.g., "__iterator__" or
   *                                           "prototype",
   *                                           "hasOwnProperty" etc.).
   * @return {Array|Object}           The parsed array or object.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  parseFromQueryString : function(queryString, toObject) {
    var result = [], decode, query, re;
    if (isObject(queryString) || isArray(queryString)) {
      return queryString;
    }
    if (toObject) {
      result = {};
    }
    query = stringify(queryString, true);
    if (query) {
      decode = Pot.URI.urlDecode;
      re = /&(?:(?:amp|#(?:0*38|[xX]0*26));|)/;
      while (query.charAt(0) === '?') {
        query = query.substring(1);
      }
      each(query.split(re), function(q) {
        var key, val, pair, k;
        pair = q.split('=');
        switch (pair.length) {
          case 0:
              break;
          case 1:
              val = pair[0];
              break;
          default:
              key = pair[0];
              val = pair[1];
              break;
        }
        if (key || val) {
          key = stringify(decode(key));
          val = stringify(decode(val));
          if (key.slice(-2) === '[]') {
            k = key.slice(0, -2);
            if (toObject) {
              if (hasOwnProperty.call(result, k)) {
                result[k] = concat.call(
                  [],
                  arrayize(result[k]),
                  arrayize(val)
                );
              } else {
                result[k] = [val];
              }
            } else {
              result[result.length] = [k, val];
            }
          } else {
            if (toObject) {
              result[key] = val;
            } else {
              result[result.length] = [key, val];
            }
          }
        }
      });
    }
    return result;
  }
});

// Update for Pot object.
Pot.update({
  serializeToJSON        : Pot.Serializer.serializeToJSON,
  parseFromJSON          : Pot.Serializer.parseFromJSON,
  serializeToQueryString : Pot.Serializer.serializeToQueryString,
  parseFromQueryString   : Pot.Serializer.parseFromQueryString
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of URI.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * URI utilities.
   *
   * @name Pot.URI
   * @type Object
   * @class
   * @static
   * @public
   */
  URI : {}
});

update(Pot.URI, {
  /**
   * @lends Pot.URI
   */
  /**
   * Encode the URI string.
   *
   * @param  {String}  string  The subject string.
   * @return {String}          The encoded string.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  urlEncode : update(function(string) {
    var result = '', me = Pot.URI.urlEncode, s;
    s = stringify(string, true);
    if (s) {
      if (Pot.isPercentEncoded(s)) {
        result = s;
      } else {
        try {
          result = me.encoder.component(s);
        } catch (e) {
          result = me.encoder.encode(s);
        }
      }
    }
    return stringify(result, true);
  }, {
    /**
     * @ignore
     */
    encoder : {
      /**
       * @ignore
       */
      component : function(string) {
        return encodeURIComponent(string);
      },
      /**
       * Simple URL encode for Surrogate Pair (URIError).
       *
       * @private
       * @ignore
       */
      encode : function(string) {
        var result = '', s, re, rep, per;
        s = stringify(string, true);
        if (s) {
          re = /[^!'-*.0-9A-Z_a-z~-]/g;
          per = '%';
          /**@ignore*/
          rep = function(s) {
            var r, c = s.charCodeAt(0);
            if (c < 0x10) {
              r = per + '0' + c.toString(16);
            } else if (c < 0x80) {
              r = per + c.toString(16);
            } else if (c < 0x800) {
              r = per + (c >> 0x06 | 0xC0).toString(16) +
                  per + (c  & 0x3F | 0x80).toString(16);
            } else {
              r = per + (c >> 0x0C | 0xE0).toString(16) +
                  per + (c >> 0x06 & 0x3F | 0x80).toString(16) +
                  per + (c  & 0x3F | 0x80).toString(16);
            }
            return r.toUpperCase();
          };
          result = s.replace(re, rep);
        }
        return result;
      }
    }
  }),
  /**
   * @lends Pot.URI
   */
  /**
   * Decode the URI string.
   *
   * @param  {String}  string  The subject string.
   * @return {String}          The decoded string.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  urlDecode : update(function(string) {
    var result = '', me = Pot.URI.urlDecode, s;
    s = stringify(string, true);
    if (s) {
      s = s.replace(me.decoder.reSpace.from, me.decoder.reSpace.to);
      try {
        result = me.decoder.component(s);
      } catch (e) {
        result = me.decoder.decode(s);
      }
    }
    return stringify(result, true);
  }, {
    /**
     * @ignore
     */
    decoder : {
      /**
       * @ignore
       */
      reSpace : {
        from  : /[+]/g,
        to    : ' '
      },
      /**
       * @ignore
       */
      component : function(string) {
        return decodeURIComponent(string);
      },
      /**
       * Simple URL decode for Surrogate Pair (URIError).
       *
       * @private
       * @ignore
       */
      decode : function(string) {
        var result = '', s, re, rep;
        s = stringify(string, true);
        if (s) {
          re = new RegExp(
            '%' + '(?:' + 'E' + '(?:' + '0%[AB]' +
                                  '|' + '[1-CEF]%[89AB]' +
                                  '|' + 'D%[89]' +
                                 ')'  + '[0-9A-F]' +
                    '|' + 'C[2-9A-F]' +
                    '|' + 'D[0-9A-F]' +
                  ')' +   '%[89AB][0-9A-F]' +
            '|' +         '%[0-7][0-9A-F]',
            'gi'
          );
          /**@ignore*/
          rep = function(s) {
            var r, c = parseInt(s.substring(1), 16);
            if (c < 0x80) {
              r = c;
            } else if (c < 0xE0) {
              r = ((c & 0x1F) << 6 | parseInt(s.substring(4), 16) & 0x3F);
            } else {
              r = (((c & 0x0F) << 6 | parseInt(s.substring(4), 16) & 0x3F)
                               << 6 | parseInt(s.substring(7), 16) & 0x3F);
            }
            return fromUnicode(r);
          };
          result = s.replace(re, rep);
        }
        return result;
      }
    }
  }),
  /**
   * @lends Pot.URI
   */
  /**
   * Parse the URI string to an object that has keys like "location" object.
   *
   * @desc
   * <pre>
   * from: RFC 3986
   *
   *     URI Generic Syntax
   *     Parsing a URI Reference with a Regular Expression
   *
   * As the "first-match-wins" algorithm is identical to the "greedy"
   * disambiguation method used by POSIX regular expressions, it is
   * natural and commonplace to use a regular expression for parsing the
   * potential five components of a URI reference.
   *
   * The following line is the regular expression for breaking-down a
   * well-formed URI reference into its components.
   *
   *     ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
   *      12            3  4          5       6  7        8 9
   *
   * The numbers in the second line above are only to assist readability;
   * they indicate the reference points for each subexpression (i.e., each
   * paired parenthesis).  We refer to the value matched for subexpression
   * <n> as $<n>.  For example, matching the above expression to
   *
   *     http://www.ics.uci.edu/pub/ietf/uri/#Related
   *
   * results in the following subexpression matches:
   *
   *     $1 = http:
   *     $2 = http
   *     $3 = //www.ics.uci.edu
   *     $4 = www.ics.uci.edu
   *     $5 = /pub/ietf/uri/
   *     $6 = <undefined>
   *     $7 = <undefined>
   *     $8 = #Related
   *     $9 = Related
   *
   * where <undefined> indicates that the component is not present, as is
   * the case for the query component in the above example.  Therefore, we
   * can determine the value of the five components as
   *
   *     scheme    = $2
   *     authority = $4
   *     path      = $5
   *     query     = $7
   *     fragment  = $9
   *
   * Going in the opposite direction, we can recreate a URI reference from
   * its components by using the algorithm of Section 5.3.
   * </pre>
   *
   *
   * @example
   *   //
   *   // This results contains all the keys and values.
   *   //
   *   var uri, result;
   *   uri = 'http://user:pass@host:8000/path/to/file.ext?arg=value#fragment';
   *   result = parseURI(uri);
   *   debug(result);
   *   // @results
   *   //   {
   *   //     protocol  : 'http:',
   *   //     scheme    : 'http',
   *   //     userinfo  : 'user:pass',
   *   //     username  : 'user',
   *   //     password  : 'pass',
   *   //     host      : 'host:8000',
   *   //     hostname  : 'host',
   *   //     port      : '8000',
   *   //     pathname  : '/path/to/file.ext',
   *   //     dirname   : '/path/to',
   *   //     filename  : 'file.ext',
   *   //     extension : 'ext',
   *   //     search    : '?arg=value',
   *   //     query     : 'arg=value',
   *   //     hash      : '#fragment',
   *   //     fragment  : 'fragment'
   *   //   }
   *
   *
   * @example
   *   var uri = 'file:///C:/foo/bar/baz.js';
   *   var result = parseURI(uri);
   *   debug(result);
   *   // @results
   *   //   {
   *   //     protocol  : 'file:',
   *   //     scheme    : 'file',
   *   //     userinfo  : '',
   *   //     username  : '',
   *   //     password  : '',
   *   //     host      : '',
   *   //     hostname  : '',
   *   //     port      : '',
   *   //     pathname  : 'C:/foo/bar/baz.js',
   *   //     dirname   : 'C:/foo/bar',
   *   //     filename  : 'baz.js',
   *   //     extension : 'js',
   *   //     search    : '',
   *   //     query     : '',
   *   //     hash      : '',
   *   //     fragment  : ''
   *   //   }
   *
   *
   * @param  {String}  uri  The target URI string.
   * @return {Object}       Object of parsing result.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  parseURI : update(function(uri) {
    var result = {}, me = Pot.URI.parseURI, p,
        parts = stringify(uri, true).match(me.parser.pattern) || [];
    for (p in me.parser.capture) {
      result[p] = stringify(parts[me.parser.capture[p]]);
    }
    return result;
  }, {
    /**
     * @private
     * @ignore
     */
    parser : {
      /**
       * @private
       * @ignore
       */
      pattern : new RegExp(
        '^' +
        '(?:' +
          '(' +                               //  1. protocol
            '([^:/\\\\?#.]+)' +               //  2. scheme
            ':+|' +
          ')' +
          '(?://|[\\\\]+|)' +
        ')' +
        '(?:' +
          '(' +                               //  3. userinfo
                '([^/\\\\?#:]*)' +            //  4. username
                ':' +
                '([^/\\\\?#]*)' +             //  5. password
          '|' + '[^/\\\\?#]*?' +
          ')@|' +
        ')' +
        '(?:[/\\\\]|' +
          '(' +                               //  6. host
            '([-\\w\\d\\u0100-\\uFFFF.%]*)' + //  7. hostname  - domain
            '(?::([0-9]+)|)|' +               //  8. port
          ')' +
        ')' +
        '(' +                                 //  9. pathname  - path
          '(?:([^?#]*)[/\\\\]|)' +            // 10. dirname
          '(' +                               // 11. filename
            '[^/\\\\?#]*?' +
            '(?:[.]([^.?#]*)|)|' +            // 12. extension
          ')' +
          '|[^?#]+|' +
        ')' +
        '([?]' +                              // 13. search
          '([^#]*)|' +                        // 14. query     - queryString
        ')' +
        '(#' +                                // 15. hash
          '(.*)|' +                           // 16. fragment
        ')' +
        '$'
      ),
      /**
       * @private
       * @ignore
       */
      capture : {
        protocol  : 1,
        scheme    : 2,
        userinfo  : 3,
        username  : 4,
        password  : 5,
        host      : 6,
        hostname  : 7,
        port      : 8,
        pathname  : 9,
        dirname   : 10,
        filename  : 11,
        extension : 12,
        search    : 13,
        query     : 14,
        hash      : 15,
        fragment  : 16
      }
    }
  }),
  /**
   * @lends Pot.URI
   */
  /**
   * Build to the URI from a string or an object with query-string.
   * Object key names can treat like "window.location" object keys.
   * Query-string will encode by percent-encoding.
   *
   *
   * @example
   *   var url = 'http://www.example.com/';
   *   var params = {
   *     foo : '{foo}',
   *     bar : '{bar}'
   *   };
   *   var result = Pot.buildURI(url, params);
   *   debug(result);
   *   // @results 'http://www.example.com/?foo=%7Bfoo%7D&bar=%7Bbar%7D'
   *
   *
   * @example
   *   var url = 'http://www.example.com/test?a=1';
   *   var params = [
   *     ['prototype',    '{foo}'],
   *     ['__iterator__', '{bar}'],
   *   ];
   *   var result = Pot.buildURI(url, params);
   *   debug(result);
   *   // @results
   *   // 'http://www.example.com/test?' +
   *   //   'a=1&prototype=%7Bfoo%7D&__iterator__=%7Bbar%7D'
   *
   *
   * @example
   *   var url = 'http://www.example.com/test?a=1';
   *   var params = 'b=2&c=3';
   *   var result = Pot.buildURI(url, params);
   *   debug(result);
   *   // @results 'http://www.example.com/test?a=1&b=2&c=3'
   *
   *
   * @example
   *   var parts = {
   *     protocol : 'http:',
   *     username : 'user',
   *     password : 'pass',
   *     hostname : 'www.example.com',
   *     port     : 8000,
   *     pathname : '/path/to/file.ext',
   *     query    : {
   *       arg1   : 'v1',
   *       arg2   : 'v#2'
   *     },
   *     hash     : 'a'
   *   };
   *   var result = Pot.buildURI(parts);
   *   debug(result);
   *   // @results
   *   // 'http://user:pass@www.example.com:8000/path/to/file.ext' +
   *   //   '?arg1=v1&arg2=v%232#a'
   *
   *
   * @example
   *   var uri = 'http://user:pass@host:8000/path/to/file.ext?' +
   *               'arg=value#fragment';
   *   var parts = parseURI(uri);
   *   var result = Pot.buildURI(parts);
   *   debug(result);
   *   // @results
   *   // 'http://user:pass@host:8000/path/to/file.ext?arg=value#fragment'
   *
   *
   * @example
   *   var parts = {
   *     protocol : 'file:',
   *     pathname : 'C:\\path\\to\\file.ext',
   *     query    : {
   *       arg1   : 'value#1',
   *       arg2   : 'value#2'
   *     },
   *     hash     : '#fragment'
   *   };
   *   var result = Pot.buildURI(parts);
   *   debug(result);
   *   // @results
   *   // 'file:///C:\\path\\to\\file.ext?' +
   *   //   'arg1=value%231&arg2=value%232#fragment'
   *
   *
   * @param  {String|Object}         url     Base URI string or
   *                                           parts as Object.
   * @param  {Object|Array|String}  (query)  (Optional) queryString.
   * @return {String}                        Return a builded URI string.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  buildURI : (function() {
    var
    RE_SCHEME = /^[^:]+:\/{0,}/,
    // URI list from RFC 1738: http://tools.ietf.org/html/rfc1738
    RE_PROTOCOL = new RegExp(
      '[st]?' +
      '(?:' +
        'http|ws|ftp|rsync|wais|telnet|nntp|' +
        'gopher|prospero|ssh|svn|scp|ldap|git' +
      ')' +
      '(?:[+]ssh)?' +
      's?',
      'i'
    );
    return function(url/*[, query]*/) {
      var uri, args = arguments, c, s, index, query,
          queryString = args[1],
          encode = Pot.URI.urlEncode,
          serialize = Pot.Serializer.serializeToQueryString,
          protocol, userinfo, host, pathname, search, hash;
      if (isObject(url)) {
        protocol = stringify(url.protocol);
        if (!protocol) {
          protocol = stringify(url.scheme);
          if (!protocol) {
            protocol = 'http:';
          }
        }
        c = protocol.slice(-1);
        if (c !== ':' && c !== '/') {
          protocol += ':';
        }
        userinfo = stringify(url.userinfo);
        if (!userinfo && url.username != null && url.password != null) {
          userinfo = [encode(url.username), encode(url.password)].join(':');
          if (userinfo === ':') {
            userinfo = '';
          }
        }
        if (userinfo && userinfo.slice(-1) !== '@') {
          userinfo += '@';
        }
        host = stringify(url.host);
        if (!host) {
          if (url.hostname != null) {
            host = stringify(url.hostname);
          }
          if (isNumeric(url.port)) {
            host += ':' + (+url.port);
          }
        }
        pathname = stringify(url.pathname);
        if (!pathname) {
          if (url.dirname != null && url.filename != null) {
            pathname = stringify(url.dirname) + stringify(url.filename);
          }
        }
        c = pathname.charAt(0);
        if (c !== '/' && c !== '\\') {
          pathname = '/' + pathname;
        }
        if (isObject(url.search) || isArrayLike(url.search)) {
          search = stringify(serialize(url.search));
        } else {
          search = stringify(url.search);
        }
        if (!search) {
          if (url.query != null) {
            if (isObject(url.query) || isArrayLike(url.query)) {
              search = stringify(serialize(url.query));
            } else {
              search = stringify(url.query);
            }
          } else if (queryString != null) {
            if (isObject(queryString) || isArrayLike(queryString)) {
              search = stringify(serialize(queryString));
            } else {
              search = stringify(queryString);
            }
          }
        }
        while (search.charAt(0) === '?') {
          search = search.substring(1);
        }
        if (search) {
          search = '?' + search;
        }
        hash = stringify(url.hash);
        if (!hash) {
          hash = stringify(url.fragment);
        }
        while (hash.charAt(0) === '#') {
          hash = hash.substring(1);
        }
        if (hash) {
          hash = '#' + hash;
        }
        uri = protocol + userinfo + host + pathname;
        c = (~uri.indexOf('?')) ? '&' : '?';
        while (search.charAt(0) === c) {
          search = search.substring(1);
        }
        if (search) {
          uri += c + search;
        }
        uri += hash;
      } else {
        uri = stringify(url);
        query = '';
        if (queryString != null) {
          if (isObject(queryString) || isArrayLike(queryString)) {
            query = stringify(serialize(queryString));
          } else {
            query = stringify(queryString);
          }
        }
        c = (~uri.indexOf('?')) ? '&' : '?';
        while (query.charAt(0) === c) {
          query = query.substring(1);
        }
        if (query) {
          uri += c + query;
        }
      }
      index = uri.indexOf(':');
      if (!~index) {
        protocol = 'http';
      } else {
        protocol = uri.substr(0, index).toLowerCase();
      }
      s = '';
      if (protocol === 'file') {
        s = '///';
      } else if (RE_PROTOCOL.test(protocol)) {
        s = '//';
      }
      protocol += ':' + s;
      if (uri.indexOf(s) !== 0) {
        uri = uri.replace(RE_SCHEME, protocol);
      }
      return uri;
    };
  }()),
  /**
   * @lends Pot.URI
   */
  /**
   * Resolves the incomplete URI.
   * Then, fix the invalid symbols for ".." and "./" etc hierarchies.
   *
   *
   * @example
   *   var uri = 'C:/path/to/foo/bar/../hoge.ext';
   *   var result = resolveRelativeURI(uri);
   *   debug(result);
   *   // @results 'C:/path/to/foo/hoge.ext'
   *
   *
   * @example
   *   var uri = 'C:/path/to/../../hoge.ext';
   *   var result = resolveRelativeURI(uri);
   *   debug(result);
   *   // @results 'C:/hoge.ext'
   *
   *
   * @example
   *   var uri = 'C:/path/to/../../../../././../../hoge.ext';
   *   var result = resolveRelativeURI(uri);
   *   debug(result);
   *   // @results 'C:/hoge.ext'
   *
   *
   * @example
   *   var uri = '/////path/to/////hoge.ext';
   *   var context = document;
   *   var result = resolveRelativeURI(uri, context);
   *   debug(result);
   *   // @results  e.g., 'http://www.example.com/path/to/hoge.ext'
   *
   *
   * @example
   *   var uri = './hoge.png';
   *   var context = document.getElementById('image1');
   *   var result = resolveRelativeURI(uri, context);
   *   debug(result);
   *   // @results  e.g., 'http://www.example.com/dir1/dir2/hoge.png'
   *
   *
   * @example
   *   var uri = '/usr/local/bin/../././hoge.ext';
   *   var result = resolveRelativeURI(uri);
   *   debug(result);
   *   // @results '/usr/local/hoge.ext'
   *
   *
   * @param  {String}   uri      The target URI.
   * @param  {Object}  (context) The completion object that
   *                               is able to reference absolute URI.
   *                               (i.e., document).
   * @return {String}            The result string that has absolute URI.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  resolveRelativeURI : update(function(uri, context) {
    var result = '', me = Pot.URI.resolveRelativeURI,
        sep, cur = '', path, pos, parts, part, subs, len, protocol;
    if (context) {
      cur = context.document || context.ownerDocument;
      if (cur) {
        cur = cur.documentURI || cur.URL ||
              (cur.location && cur.location.href) || '';
      }
    }
    cur = stringify(cur);
    path = trim(trim(uri && (uri.href || uri.path) || uri) || cur);
    if (!path) {
      result = cur;
    } else {
      sep = '/';
      pos = path.indexOf(sep);
      if (PotOS.win && !~pos && !~cur.indexOf(sep)) {
        sep = '\\';
      }
      if (cur) {
        if (pos === 0 && me.PATTERNS.PROTOCOL.test(cur)) {
          cur = cur.replace(me.PATTERNS.HOSTS, '$1');
        }
        if (!me.PATTERNS.PROTOCOL.test(path)) {
          path = cur.replace(me.PATTERNS.UNHOSTS, '$1') + path;
        }
      }
      protocol = '';
      if (me.PATTERNS.PROTOCOL.test(path)) {
        path = path.replace(me.PATTERNS.PROTOCOL, function(m) {
          protocol = m;
          return '';
        });
      }
      parts = path.split(me.PATTERNS.SEPARATOR);
      len = parts.length;
      subs = [];
      while (--len >= 0) {
        part = parts.shift();
        if (!part || part.indexOf('.') === 0) {
          if (part === '..') {
            subs.pop();
          }
          continue;
        }
        subs.push(part);
      }
      result = protocol + subs.join(sep);
      // UNIX Path
      if (!me.PATTERNS.PROTOCOL.test(result)) {
        result = sep + result;
      }
    }
    return stringify(result);
  }, {
    /**
     * @private
     * @ignore
     * @const
     */
    PATTERNS : {
      PROTOCOL  : /^([a-zA-Z]\w*:[\/\\]*)/,
      SEPARATOR : /[\/\\]/,
      HOSTS     : /^(\w+:[\/\\]*[^\/\\]*[\/\\]).*$/,
      UNHOSTS   : /([\/\\])[^\/\\]*$/g
    }
  }),
  /**
   * @lends Pot.URI
   */
  /**
   * Get the file extension name.
   * This method enabled for URI or URL string etc.
   *
   *
   * @example
   *   var fileName = 'foo.html';
   *   var result = getExt(fileName);
   *   debug(result);
   *   // @results 'html'
   *
   *
   * @example
   *   var fileName = 'C:\\foo\\bar\\baz.tmp.txt';
   *   var result = getExt(fileName);
   *   debug(result);
   *   // @results 'txt'
   *
   *
   * @example
   *   var uri = 'http://www.example.com/file.html?q=hoge.js';
   *   var result = getExt(uri);
   *   debug(result);
   *   // @results 'html'
   *
   *
   * @example
   *   var uri = 'http://www.example.com/?output=hoge.xml#fuga.piyo';
   *   var result = getExt(uri);
   *   debug(result);
   *   // @results 'xml'
   *
   *
   * @example
   *   var uri = 'http://www.example.com/?q=hoge';
   *   var result = getExt(uri);
   *   debug(result);
   *   // @results ''
   *
   *
   * @example
   *   var uri, result;
   *   uri = 'http://www.example.com/http%3A%2F%2Fwww.example.com%2Ffoo%2Ejs';
   *   result = getExt(uri);
   *   debug(result);
   *   // @results 'js'
   *
   *
   * @param  {String}  path  The target filename or URI.
   * @return {String}        The file extension name that
   *                           was excluded dot(.).
   * @type  Function
   * @function
   * @static
   * @public
   */
  getExt : update(function(path) {
    var
    result = '',
    me = Pot.URI.getExt,
    re = me.PATTERNS,
    decode = Pot.URI.urlDecode,
    uri = stringify(
      (path && (path.href || path.path)) || path,
      true
    ).replace(re.STRIP, '');
    if (uri && ~uri.indexOf('.')) {
      try {
        result = uri.replace(re.CLEAN, '').match(re.EXT)[1];
      } catch (e) {}
      if (!result) {
        try {
          result = decode(uri.replace(re.HASH, '')).match(re.EXT)[1];
        } catch (e) {}
        if (!result) {
          try {
            result = decode(uri).match(re.EXT)[1];
          } catch (e) {}
          if (!result) {
            try {
              result = decode(uri).match(re.EXTF)[1];
            } catch (e) {}
          }
        }
      }
    }
    return stringify(result);
  }, {
    /**
     * @private
     * @ignore
     * @const
     */
    PATTERNS : {
      EXT   : /[.](\w{1,24})$/,
      EXTF  : /[.]([^.:;*&=#?!\/\\]*)$/,
      HASH  : /#.*$/g,
      CLEAN : /[?#].*$/g,
      STRIP : /[\s\u00A0\u3000]+/g
    }
  }),
  /**
   * @lends Pot.URI
   */
  /**
   * Create Data Scheme (data:...).
   *
   * <pre>
   * RFC 2397 - The "data" URL scheme
   * @link http://tools.ietf.org/html/rfc2397
   *
   * data:[<mime type>][;charset=<charset>][;base64],<encoded data>
   * </pre>
   *
   *
   * @example
   *   debug(
   *     toDataURI('Hello World!', 'text/plain', false, 'UTF-8', false)
   *   );
   *   // @results  'data:text/plain;charset=UTF-8,Hello%20World!'
   *
   *
   * @example
   *   debug(
   *     toDataURI('Hello World!', 'text/plain', true, 'UTF-8', false)
   *   );
   *   // @results  'data:text/plain;charset=UTF-8;base64,SGVsbG8gV29ybGQh'
   *
   *
   * @example
   *   debug(
   *     toDataURI({
   *       data     : 'Hello World!',
   *       mimeType : 'html',
   *       base64   : true
   *     })
   *   );
   *   // @results  'data:text/html;base64,SGVsbG8gV29ybGQh'
   *
   *
   * @example
   *   debug(
   *     toDataURI({
   *       data     : 'SGVsbG8gV29ybGQh',
   *       mimeType : 'txt',
   *       base64   : true,
   *       encoded  : true
   *     })
   *   );
   *   // @results  'data:text/plain;base64,SGVsbG8gV29ybGQh'
   *
   *
   * @param  {String|Object}   data     The target data string, or Object.
   *                                      <pre>
   *                                      When specify Object:
   *                                        - data     : {String}
   *                                            Data string.
   *                                        - mimeType : {String}
   *                                            MIMEType or Extension.
   *                                            e.g. 'image/png', 'png' etc.
   *                                        - base64   : {Boolean}
   *                                            True if encode base64.
   *                                        - charset  : {String}
   *                                            Character Encoding.
   *                                        - encoded  : {Boolean}
   *                                            True if already encoded data.
   *                                      </pre>
   * @param  {String}        (mimeType) MIME Type (e.g. 'image/png').
   * @param  {Boolean}       (base64)   Whether the `data` is base64 format.
   * @param  {String}        (charset)  The character code if needed.
   * @return {String}                   The result Data URI.
   *
   * @type Function
   * @function
   * @static
   * @public
   */
  toDataURI : function(data/*[, mimeType
                             [, base64
                             [, charset
                             [, encoded   ]]]]*/) {
    var uri = '', args = arguments, o = {}, p, lp, s,
        URI      = Pot.URI,
        MimeType = Pot.MimeType,
        Base64   = Pot.Base64,
        isTwo    = isObject(args[1]);
    if (data) {
      if (args.length <= 2 && (isObject(data) || isTwo)) {
        if (isTwo) {
          data = update({}, args[1], {data : data});
        }
        for (p in data) {
          lp = String(p).toLowerCase();
          if (o.type == null && ~lp.indexOf('mime')) {
            o.type = data[p];
          } else if (o.encoded == null && ~lp.indexOf('enc')) {
            o.encoded = data[p];
          } else if (o.base64 == null && ~lp.indexOf('64')) {
            o.base64 = data[p];
          } else if (o.charset == null && ~lp.indexOf('char')) {
            o.charset = data[p];
          } else if (o.data == null && ~lp.indexOf('data')) {
            o.data = data[p];
          }
        }
      } else {
        o.data    = data;
        o.type    = args[1];
        o.base64  = args[2];
        o.charset = args[3];
        o.encoded = args[4];
      }
      o.type = trim(o.type).toLowerCase();
      if (MimeType && o.type && !~o.type.indexOf('/')) {
        o.type = MimeType.getMimeTypeByExt(o.type);
      }
      if (!o.type) {
        o.type = '*/*';
      }
      if (o.charset) {
        o.charset = ';charset=' + stringify(o.charset, true);
      }
      if (o.base64) {
        o.base64 = ';base64';
      }
      s = stringify(o.data, true);
      if (!o.encoded) {
        if (o.base64) {
          if (Base64) {
            s = Base64.encode(s);
          } else {
            o.base64 = false;
            s = URI.urlEncode(s);
          }
        } else {
          s = URI.urlEncode(s);
        }
      }
    }
    uri = [
      'data:',
      o.type,
      stringify(o.charset, true),
      stringify(o.base64, true),
      ',',
      stringify(s, true)
    ].join('');
    return uri;
  }
});

// Update Pot object.
Pot.update({
  urlEncode          : Pot.URI.urlEncode,
  urlDecode          : Pot.URI.urlDecode,
  parseURI           : Pot.URI.parseURI,
  buildURI           : Pot.URI.buildURI,
  resolveRelativeURI : Pot.URI.resolveRelativeURI,
  getExt             : Pot.URI.getExt,
  toDataURI          : Pot.URI.toDataURI
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Crypt.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Crypt and Hash utilities.
   *
   * @name Pot.Crypt
   * @type Object
   * @class
   * @static
   * @public
   */
  Crypt : {}
});

update(Pot.Crypt, {
  /**
   * @lends Pot.Crypt
   */
  /**
   * String hash function similar to java.lang.String.hashCode().
   *   The hash code for a string is computed as
   *   s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
   *   where s[i] is the ith character of the string and n is the length of
   *   the string.
   * We mod the result to make it between 0 (inclusive) and 2^32 (exclusive).
   *
   *
   * @example
   *   Pot.debug( Pot.hashCode('abc') ); // 96354
   *   Pot.debug( Pot.hashCode([0x61, 0x62, 0x63]) ); // 96354
   *
   *
   * @param  {String|Array|*}  data   A target data.
   * @return {Number}                 Hash value for `string`,
   *                                    between 0 (inclusive)
   *                                    and 2^32 (exclusive).
   *                                  The empty string returns 0.
   * @based goog.string.hashCode
   * @type Function
   * @function
   * @public
   * @static
   */
  hashCode : function(data) {
    var result = 0, s, i, len,
        max = 0x100000000, // 2^32
        arrayLike = false;
    if (data == null) {
      s = String(data);
    } else if (isArrayLike(data)) {
      s = arrayize(data);
      arrayLike = true;
    } else {
      s = data.toString ? data.toString() : String(data);
    }
    len = s.length;
    for (i = 0; i < len; ++i) {
      result = 31 * result + (arrayLike ? s[i] : s.charCodeAt(i));
      result %= max;
    }
    return result;
  },
  /**
   * Calculate the MD5 hash of a string.
   *
   * RFC 1321 - The MD5 Message-Digest Algorithm
   * @link http://www.faqs.org/rfcs/rfc1321
   *
   *
   * @example
   *   debug(md5('apple'));
   *   // @results '1f3870be274f6c49b3e31a0c6728957f'
   *
   *
   * @param  {String|Array}  data  The target data.
   * @return {String}              The result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  md5 : (function() {
    /**@ignore*/
    function rl(v, sb) {
      return (v << sb) | (v >>> (32 - sb));
    }
    /**@ignore*/
    function au(x, y) {
      var x4, y4, x8, y8, rv;
      x8 = (x & 0x80000000);
      y8 = (y & 0x80000000);
      x4 = (x & 0x40000000);
      y4 = (y & 0x40000000);
      rv = (x & 0x3FFFFFFF) + (y & 0x3FFFFFFF);
      if (x4 & y4) {
        return (rv ^ 0x80000000 ^ x8 ^ y8);
      }
      if (x4 | y4) {
        if (rv & 0x40000000) {
          return (rv ^ 0xC0000000 ^ x8 ^ y8);
        } else {
          return (rv ^ 0x40000000 ^ x8 ^ y8);
        }
      } else {
        return (rv ^ x8 ^ y8);
      }
    }
    /**@ignore*/
    function f5(x, y, z) { return (x & y) | ((~x) & z); }
    /**@ignore*/
    function g5(x, y, z) { return (x & z) | (y & (~z)); }
    /**@ignore*/
    function i5(x, y, z) { return (y ^ (x | (~z))); }
    /**@ignore*/
    function h5(x, y, z) { return (x ^ y ^ z); }
    /**@ignore*/
    function ff5(a, b, c, d, x, s, ac) {
      a = au(a, au(au(f5(b, c, d), x), ac));
      return au(rl(a, s), b);
    }
    /**@ignore*/
    function gg5(a, b, c, d, x, s, ac) {
      a = au(a, au(au(g5(b, c, d), x), ac));
      return au(rl(a, s), b);
    }
    /**@ignore*/
    function hh5(a, b, c, d, x, s, ac) {
      a = au(a, au(au(h5(b, c, d), x), ac));
      return au(rl(a, s), b);
    }
    /**@ignore*/
    function ii5(a, b, c, d, x, s, ac) {
      a = au(a, au(au(i5(b, c, d), x), ac));
      return au(rl(a, s), b);
    }
    /**@ignore*/
    function convertToWordArray(s, arrayLike) {
      var wc, ml = s.length, t1 = ml + 8,
          t2 = (t1 - (t1 % 64)) / 64,
          nw = (t2 + 1) * 16,
          wa = new Array(nw - 1),
          bp = 0, bc = 0;
      while (bc < ml) {
        wc = (bc - (bc % 4)) / 4;
        bp = (bc % 4) * 8;
        wa[wc] = (wa[wc] | ((arrayLike ? s[bc] : s.charCodeAt(bc)) << bp));
        bc++;
      }
      wc = (bc - (bc % 4)) / 4;
      bp = (bc % 4) * 8;
      wa[wc] = wa[wc] | (0x80 << bp);
      wa[nw - 2] = ml << 3;
      wa[nw - 1] = ml >>> 29;
      return wa;
    }
    /**@ignore*/
    function wordToHex(v) {
      var whv = '', whvt = '', bt, c;
      for (c = 0; c <= 3; c++) {
        bt = (v >>> (c * 8)) & 255;
        whvt = '0' + bt.toString(16);
        whv = whv + whvt.substr(whvt.length - 2, 2);
      }
      return whv;
    }
    /**@ignore*/
    function hex(a, b, c, d) {
      return [
        wordToHex(a), wordToHex(b), wordToHex(c), wordToHex(d)
      ].join('').toLowerCase();
    }
    /**@ignore*/
    function calc(s) {
      var
      S11 = 7,
      S12 = 12, S13 = 17, S14 = 22, S21 = 5,  S22 = 9,
      S23 = 14, S24 = 20, S31 = 4,  S32 = 11, S33 = 16,
      S34 = 23, S41 = 6,  S42 = 10, S43 = 15, S44 = 21,
      a = 0x67452301,
      b = 0xEFCDAB89,
      c = 0x98BADCFE,
      d = 0x10325476,
      AA, BB, CC, DD,
      k,
      /**@ignore*/
      calculate = function() {
        AA = a;
        BB = b;
        CC = c;
        DD = d;
        a = ff5(a, b, c, d, x[k +  0], S11, 0xD76AA478);
        d = ff5(d, a, b, c, x[k +  1], S12, 0xE8C7B756);
        c = ff5(c, d, a, b, x[k +  2], S13, 0x242070DB);
        b = ff5(b, c, d, a, x[k +  3], S14, 0xC1BDCEEE);
        a = ff5(a, b, c, d, x[k +  4], S11, 0xF57C0FAF);
        d = ff5(d, a, b, c, x[k +  5], S12, 0x4787C62A);
        c = ff5(c, d, a, b, x[k +  6], S13, 0xA8304613);
        b = ff5(b, c, d, a, x[k +  7], S14, 0xFD469501);
        a = ff5(a, b, c, d, x[k +  8], S11, 0x698098D8);
        d = ff5(d, a, b, c, x[k +  9], S12, 0x8B44F7AF);
        c = ff5(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
        b = ff5(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
        a = ff5(a, b, c, d, x[k + 12], S11, 0x6B901122);
        d = ff5(d, a, b, c, x[k + 13], S12, 0xFD987193);
        c = ff5(c, d, a, b, x[k + 14], S13, 0xA679438E);
        b = ff5(b, c, d, a, x[k + 15], S14, 0x49B40821);
        a = gg5(a, b, c, d, x[k +  1], S21, 0xF61E2562);
        d = gg5(d, a, b, c, x[k +  6], S22, 0xC040B340);
        c = gg5(c, d, a, b, x[k + 11], S23, 0x265E5A51);
        b = gg5(b, c, d, a, x[k +  0], S24, 0xE9B6C7AA);
        a = gg5(a, b, c, d, x[k +  5], S21, 0xD62F105D);
        d = gg5(d, a, b, c, x[k + 10], S22, 0x2441453);
        c = gg5(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
        b = gg5(b, c, d, a, x[k +  4], S24, 0xE7D3FBC8);
        a = gg5(a, b, c, d, x[k +  9], S21, 0x21E1CDE6);
        d = gg5(d, a, b, c, x[k + 14], S22, 0xC33707D6);
        c = gg5(c, d, a, b, x[k +  3], S23, 0xF4D50D87);
        b = gg5(b, c, d, a, x[k +  8], S24, 0x455A14ED);
        a = gg5(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
        d = gg5(d, a, b, c, x[k +  2], S22, 0xFCEFA3F8);
        c = gg5(c, d, a, b, x[k +  7], S23, 0x676F02D9);
        b = gg5(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
        a = hh5(a, b, c, d, x[k +  5], S31, 0xFFFA3942);
        d = hh5(d, a, b, c, x[k +  8], S32, 0x8771F681);
        c = hh5(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
        b = hh5(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
        a = hh5(a, b, c, d, x[k +  1], S31, 0xA4BEEA44);
        d = hh5(d, a, b, c, x[k +  4], S32, 0x4BDECFA9);
        c = hh5(c, d, a, b, x[k +  7], S33, 0xF6BB4B60);
        b = hh5(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
        a = hh5(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
        d = hh5(d, a, b, c, x[k +  0], S32, 0xEAA127FA);
        c = hh5(c, d, a, b, x[k +  3], S33, 0xD4EF3085);
        b = hh5(b, c, d, a, x[k +  6], S34, 0x4881D05);
        a = hh5(a, b, c, d, x[k +  9], S31, 0xD9D4D039);
        d = hh5(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
        c = hh5(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
        b = hh5(b, c, d, a, x[k +  2], S34, 0xC4AC5665);
        a = ii5(a, b, c, d, x[k +  0], S41, 0xF4292244);
        d = ii5(d, a, b, c, x[k +  7], S42, 0x432AFF97);
        c = ii5(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
        b = ii5(b, c, d, a, x[k +  5], S44, 0xFC93A039);
        a = ii5(a, b, c, d, x[k + 12], S41, 0x655B59C3);
        d = ii5(d, a, b, c, x[k +  3], S42, 0x8F0CCC92);
        c = ii5(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
        b = ii5(b, c, d, a, x[k +  1], S44, 0x85845DD1);
        a = ii5(a, b, c, d, x[k +  8], S41, 0x6FA87E4F);
        d = ii5(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
        c = ii5(c, d, a, b, x[k +  6], S43, 0xA3014314);
        b = ii5(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
        a = ii5(a, b, c, d, x[k +  4], S41, 0xF7537E82);
        d = ii5(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
        c = ii5(c, d, a, b, x[k +  2], S43, 0x2AD7D2BB);
        b = ii5(b, c, d, a, x[k +  9], S44, 0xEB86D391);
        a = au(a, AA);
        b = au(b, BB);
        c = au(c, CC);
        d = au(d, DD);
      },
      x, xl;
      if (isArrayLike(s)) {
        x = convertToWordArray(arrayize(s), true);
      } else {
        x = convertToWordArray(Pot.UTF8.encode(stringify(s, true)));
      }
      xl = x.length;
      return {
        /**@ignore*/
        sync : function() {
          for (k = 0; k < xl; k += 16) {
            calculate();
          }
          return hex(a, b, c, d);
        },
        /**@ignore*/
        async : function(speed) {
          k = 0;
          return Deferred.forEver[speed](function() {
            if (k < xl) {
              calculate();
            } else {
              throw PotStopIteration;
            }
            k += 16;
          }).then(function() {
            return hex(a, b, c, d);
          });
        }
      };
    }
    /**@ignore*/
    return update(function(data) {
      return calc(data).sync();
    }, {
      /**
       * @lends Pot.Crypt.md5
       */
      /**
       * Calculate the MD5 hash of a string with Deferred.
       *
       * RFC 1321 - The MD5 Message-Digest Algorithm
       * @link http://www.faqs.org/rfcs/rfc1321
       *
       *
       * @example
       *   md5.deferred('apple').then(function(res) {
       *     debug(res);
       *     // @results '1f3870be274f6c49b3e31a0c6728957f'
       *   });
       *
       *
       * @param  {String|Array}   data   The target data.
       * @return {Pot.Deferred}          Return new instance of Pot.Deferred
       *                                   with a result string.
       * @type  Function
       * @function
       * @static
       * @public
       *
       * @property {Function} limp   Run with slowest speed.
       * @property {Function} doze   Run with slower speed.
       * @property {Function} slow   Run with slow speed.
       * @property {Function} normal Run with default speed.
       * @property {Function} fast   Run with fast speed.
       * @property {Function} rapid  Run with faster speed.
       * @property {Function} ninja  Run fastest speed.
       */
      deferred : PotInternal.defineDeferrater(function(speed) {
        return function(data) {
          return calc(data).async(speed);
        };
      })
    });
  }()),
  /**
   * @lends Pot.Crypt
   */
  /**
   * Calculate the 32-bit CRC (cyclic redundancy checksum) checksum.
   *
   *
   * @example
   *   debug(crc32('abc123'));
   *   // @results  -821904548
   *
   *
   * @param  {String|Array}  data   Data.
   * @return {Number}               CRC checksum.
   * @type  Function
   * @function
   * @static
   * @public
   */
  crc32 : (function() {
    var CRC32MAPS = [
      0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,
      0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,
      0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,0x1DB71064,0x6AB020F2,
      0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,
      0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,
      0xFA0F3D63,0x8D080DF5,0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,
      0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,
      0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
      0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,
      0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,
      0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,0x76DC4190,0x01DB7106,
      0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,
      0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,
      0x91646C97,0xE6635C01,0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,
      0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,
      0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
      0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,
      0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,
      0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,0x5005713C,0x270241AA,
      0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,
      0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,
      0xB7BD5C3B,0xC0BA6CAD,0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,
      0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,
      0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
      0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,
      0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,
      0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,0xD6D6A3E8,0xA1D1937E,
      0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,
      0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,
      0x316E8EEF,0x4669BE79,0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,
      0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,
      0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
      0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,
      0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,
      0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,0x86D3D2D4,0xF1D4E242,
      0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,
      0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,
      0x616BFFD3,0x166CCF45,0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,
      0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,
      0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
      0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,
      0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,
      0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D
    ];
    /**@ignore*/
    return function(data) {
      var s, crc = 0, i, n, len, arrayLike = false;
      if (isArrayLike(data)) {
        s = arrayize(data);
        arrayLike = true;
      } else {
        s = Pot.UTF8.encode(stringify(data, true));
      }
      len = s.length;
      crc = crc ^ -1;
      for (i = 0; i < len; i++) {
        n = (crc ^ (arrayLike ? s[i] : s.charCodeAt(i))) & 0xFF;
        crc = (crc >>> 8) ^ CRC32MAPS[n];
      }
      return crc ^ -1;
    };
  }()),
  /**
   * @lends Pot.Crypt
   */
  /**
   * Calculate the SHA1 hash of a string.
   *
   * RFC 3174 - US Secure Hash Algorithm 1 (SHA1)
   * @link http://www.faqs.org/rfcs/rfc3174
   *
   *
   * @example
   *   debug(sha1('apple'));
   *   // @results 'd0be2dc421be4fcd0172e5afceea3970e2f3d940'
   *
   *
   * @param  {String|Array}  data  The input data.
   * @return {String}              Returns the sha1 hash as a string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  sha1 : (function() {
    /**@ignore*/
    function rl(n, s) {
      var t4 = (n << s) | (n >>> (32 - s));
      return t4;
    }
    /**@ignore*/
    function hex(val) {
      var s = '', i, v;
      for (i = 7; i >= 0; i--) {
        v = (val >>> (i * 4)) & 0x0F;
        s += v.toString(16);
      }
      return s;
    }
    /**@ignore*/
    function hexLower(a, b, c, d, e) {
      return (hex(a) + hex(b) + hex(c) + hex(d) + hex(e)).toLowerCase();
    }
    /**@ignore*/
    function calc(data) {
      var
      bs, i, j,
      A, B, C, D, E, W = new Array(80),
      H0 = 0x67452301,
      H1 = 0xEFCDAB89,
      H2 = 0x98BADCFE,
      H3 = 0x10325476,
      H4 = 0xC3D2E1F0,
      wa = [],
      wal,
      tp,
      /**@ignore*/
      calculate = function() {
        for (i = 0; i < 16; i++) {
          W[i] = wa[bs + i];
        }
        for (i = 16; i <= 79; i++) {
          W[i] = rl(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        }
        A = H0;
        B = H1;
        C = H2;
        D = H3;
        E = H4;
        for (i = 0; i <= 19; i++) {
          tp = (rl(A, 5) + ((B & C) |
                  (~B & D)) + E + W[i] + 0x5A827999) & 0x0FFFFFFFF;
          E = D;
          D = C;
          C = rl(B, 30);
          B = A;
          A = tp;
        }
        for (i = 20; i <= 39; i++) {
          tp = (rl(A, 5) + (B ^ C ^ D) +
                  E + W[i] + 0x6ED9EBA1) & 0x0FFFFFFFF;
          E = D;
          D = C;
          C = rl(B, 30);
          B = A;
          A = tp;
        }
        for (i = 40; i <= 59; i++) {
          tp = (rl(A, 5) + ((B & C) |
                  (B & D) | (C & D)) +
                  E + W[i] + 0x8F1BBCDC) & 0x0FFFFFFFF;
          E = D;
          D = C;
          C = rl(B, 30);
          B = A;
          A = tp;
        }
        for (i = 60; i <= 79; i++) {
          tp = (rl(A, 5) + (B ^ C ^ D) +
                  E + W[i] + 0xCA62C1D6) & 0x0FFFFFFFF;
          E = D;
          D = C;
          C = rl(B, 30);
          B = A;
          A = tp;
        }
        H0 = (H0 + A) & 0x0FFFFFFFF;
        H1 = (H1 + B) & 0x0FFFFFFFF;
        H2 = (H2 + C) & 0x0FFFFFFFF;
        H3 = (H3 + D) & 0x0FFFFFFFF;
        H4 = (H4 + E) & 0x0FFFFFFFF;
      },
      /**@ignore*/
      codeAt = function(idx) {
        return arrayLike ? s[idx] : s.charCodeAt(idx);
      },
      s, sl, arrayLike = false;
      if (isArrayLike(data)) {
        s = arrayize(data);
        arrayLike = true;
      } else {
        s = Pot.UTF8.encode(stringify(data, true));
      }
      sl = s.length;
      for (i = 0; i < sl - 3; i += 4) {
        j = codeAt(i)     << 24 |
            codeAt(i + 1) << 16 |
            codeAt(i + 2) <<  8 |
            codeAt(i + 3);
        wa[wa.length] = j;
      }
      switch (sl % 4) {
        case 0:
            i = 0x080000000;
            break;
        case 1:
            i = codeAt(sl - 1) << 24 | 0x0800000;
            break;
        case 2:
            i = codeAt(sl - 2) << 24 |
                codeAt(sl - 1) << 16 | 0x08000;
            break;
        case 3:
            i = codeAt(sl - 3) << 24 |
                codeAt(sl - 2) << 16 |
                codeAt(sl - 1) <<  8 | 0x80;
      }
      wa[wa.length] = i;
      while ((wa.length % 16) != 14) {
        wa[wa.length] = 0;
      }
      wa[wa.length] = (sl >>> 29);
      wa[wa.length] = ((sl << 3) & 0x0FFFFFFFF);
      wal = wa.length;
      return {
        /**@ignore*/
        sync : function() {
          for (bs = 0; bs < wal; bs += 16) {
            calculate();
          }
          return hexLower(H0, H1, H2, H3, H4);
        },
        /**@ignore*/
        async : function(speed) {
          bs = 0;
          return Deferred.forEver[speed](function() {
            if (bs < wal) {
              calculate();
            } else {
              throw PotStopIteration;
            }
            bs += 16;
          }).then(function() {
            return hexLower(H0, H1, H2, H3, H4);
          });
        }
      };
    }
    /**@ignore*/
    return update(function(data) {
      return calc(data).sync();
    }, {
      /**
       * @lends Pot.Crypt.sha1
       */
      /**
       * Calculate the SHA1 hash of a string with Deferred.
       *
       * RFC 3174 - US Secure Hash Algorithm 1 (SHA1)
       * @link http://www.faqs.org/rfcs/rfc3174
       *
       *
       * @example
       *   sha1.deferred('apple').then(function(res) {
       *     debug(res);
       *     // @results 'd0be2dc421be4fcd0172e5afceea3970e2f3d940'
       *   });
       *
       *
       * @param  {String|Array}   data   The input data.
       * @return {Pot.Deferred}          Returns new instance of Pot.Deferred
       *                                   with the sha1 hash as a string.
       * @type  Function
       * @function
       * @static
       * @public
       *
       * @property {Function} limp   Run with slowest speed.
       * @property {Function} doze   Run with slower speed.
       * @property {Function} slow   Run with slow speed.
       * @property {Function} normal Run with default speed.
       * @property {Function} fast   Run with fast speed.
       * @property {Function} rapid  Run with faster speed.
       * @property {Function} ninja  Run fastest speed.
       */
      deferred : PotInternal.defineDeferrater(function(speed) {
        return function(data) {
          return calc(data).async(speed);
        };
      })
    });
  }()),
  /**
   * @lends Pot.Crypt
   */
  /**
   * ARC4 symmetric cipher encryption/decryption.
   *
   * Original algorithm:
   * {@link http://www.mozilla.org/projects/security/pki/nss/
   *         draft-kaukonen-cipher-arcfour-03.txt}
   *
   *
   * @example
   *   var arc4 = new Pot.Crypt.Arc4();
   *   arc4.setKey('hoge');
   *   var cipherText = arc4.encrypt('Hello World!');
   *   debug('cipherText = ' + cipherText);
   *   // @results 'cipherText = (...cipherText)'
   *   var origText = arc4.decrypt(cipherText);
   *   debug('origText = ' + origText);
   *   // @results 'origText = Hello World!'
   *
   *
   * @param  {String}  (key)  Secret key for encryption.
   * @return {Object}         The instance of Arc4 object.
   *
   * @name Pot.Crypt.Arc4
   * @type Function
   * @constructor
   * @function
   * @public
   */
  Arc4 : (function() {
    /**
     * Emit ciphertext.
     *
     * @internal
     * @ignore
     */
    function arc4Crypt(text, key, table) {
      var
      r = [],
      a = arrayize(table),
      i, j = 0, x, y,
      t = stringify(text, true),
      k = stringify(key, true),
      n = k.length,
      /**@ignore*/
      calculate = function() {
        i = (i + 1) % 256;
        j = (j + a[i]) % 256;
        x = a[i];
        a[i] = a[j];
        a[j] = x;
        r[r.length] = fromUnicode(t.charCodeAt(y) ^ a[(a[i] + a[j]) % 256]);
      };
      for (i = 0; i < 256; i++) {
        j = (j + a[i] + k.charCodeAt(i % n)) % 256;
        x = a[i];
        a[i] = a[j];
        a[j] = x;
      }
      i = j = 0;
      n = t.length;
      return {
        /**@ignore*/
        sync : function() {
          for (y = 0; y < n; y++) {
            calculate();
          }
          return r.join('');
        },
        /**@ignore*/
        async : function(speed) {
          y = 0;
          return Deferred.forEver[speed](function() {
            if (y < n) {
              calculate();
            } else {
              throw PotStopIteration;
            }
            y++;
          }).then(function() {
            return r.join('');
          });
        }
      };
    }
    /**
     * Arc4 constructor.
     *
     * @param  {String}  (key)  Secret key for encryption.
     * @return {Object}         The instance of Arc4 object.
     * @ignore
     */
    function arc4(key) {
      return new arc4.prototype.init(key);
    }
    arc4.prototype = update(arc4.prototype, {
      /**
       * @lends Pot.Crypt.Arc4
       */
      /**
       * @internal
       * @ignore
       */
      constructor : arc4,
      /**
       * @private
       * @ignore
       */
      table : [],
      /**
       * @private
       * @ignore
       */
      key : null,
      /**
       * Initialize.
       *
       * @param  {String}  key  Secret key for encryption.
       * @return {Object}       The instance of Arc4 object.
       * @ignore
       */
      init : function(key) {
        var that = this, ed, dd;
        if (key != null) {
          this.setKey(key);
        }
        this.initTable();
        ed = this.encrypt.deferred;
        dd = this.decrypt.deferred;
        ed.instance = dd.instance = this;
        each(PotInternalLightIterator.speeds, function(v, k) {
          ed[k].instance = dd[k].instance = that;
        });
        return this;
      },
      /**
       * @internal
       * @private
       * @ignore
       */
      initTable : function() {
        var i;
        this.table = [];
        for (i = 0; i < 256; i++) {
          this.table[i] = i;
        }
      },
      /**
       * Set the secret key string for encryption.
       *
       *
       * @example
       *   var arc4 = new Pot.Crypt.Arc4();
       *   arc4.setKey('hoge');
       *   var cipherText = arc4.encrypt('Hello World!');
       *   debug('cipherText = ' + cipherText);
       *   // @results 'cipherText = (...cipherText)'
       *   var origText = arc4.decrypt(cipherText);
       *   debug('origText = ' + origText);
       *   // @results 'origText = Hello World!'
       *
       *
       * @param  {String}  key  Secret key for encryption.
       * @return {Object}       The instance of Arc4 object.
       * @public
       */
      setKey : function(key) {
        this.key = Pot.UTF8.encode(key);
        return this;
      },
      /**
       * Encrypt given plain text using the key with RC4 algorithm.
       * All parameters and return value are in binary format.
       *
       *
       * @example
       *   var arc4 = new Pot.Crypt.Arc4();
       *   arc4.setKey('hoge');
       *   var cipherText = arc4.encrypt('Hello World!');
       *   debug('cipherText = ' + cipherText);
       *   // @results 'cipherText = (...cipherText)'
       *   var origText = arc4.decrypt(cipherText);
       *   debug('origText = ' + origText);
       *   // @results 'origText = Hello World!'
       *
       *
       * @param  {String}  text  Plain text to be encrypted.
       * @return {String}        The encrypted string.
       * @type Function
       * @public
       */
      encrypt : update(function(text) {
        return arc4Crypt(
          Pot.UTF8.encode(text),
          this.key,
          this.table
        ).sync();
      }, {
        /**
         * @lends Pot.Crypt.Arc4.encrypt
         */
        /**
         * Encrypt given plain text using the key with RC4 algorithm.
         * All parameters and return value are in binary format.
         * Encrypt with asynchronous,
         *  and returns new instance of Pot.Deferred.
         *
         *
         * @example
         *   var arc4 = new Pot.Crypt.Arc4();
         *   arc4.setKey('hoge');
         *   arc4.encrypt.deferred('Hello World!')
         *               .then(function(cipherText) {
         *     debug('cipherText = ' + cipherText);
         *     // @results 'cipherText = (...cipherText)'
         *     return arc4.decrypt.deferred(cipherText)
         *                        .then(function(origText) {
         *       debug('origText = ' + origText);
         *       // @results 'origText = Hello World!'
         *     });
         *   });
         *
         *
         * @param  {String}        string  Plain text to be encrypted.
         * @return {Pot.Deferred}          Returns new instance of
         *                                   Pot.Deferred with the
         *                                   encrypted string.
         * @type  Function
         * @public
         *
         * @property {Function} limp   Run with slowest speed.
         * @property {Function} doze   Run with slower speed.
         * @property {Function} slow   Run with slow speed.
         * @property {Function} normal Run with default speed.
         * @property {Function} fast   Run with fast speed.
         * @property {Function} rapid  Run with faster speed.
         * @property {Function} ninja  Run fastest speed.
         */
        deferred : PotInternal.defineDeferrater(function(speed) {
          /**@ignore*/
          var func = function(text) {
            var that = func.instance;
            return arc4Crypt(
              Pot.UTF8.encode(text),
              that.key,
              that.table
            ).async(speed);
          };
          return func;
        })
      }),
      /**
       * @lends Pot.Crypt.Arc4
       */
      /**
       * Decrypt given cipher text using the key with RC4 algorithm.
       * All parameters and return value are in binary format.
       *
       *
       * @example
       *   var arc4 = new Pot.Crypt.Arc4();
       *   arc4.setKey('hoge');
       *   var cipherText = arc4.encrypt('Hello World!');
       *   debug('cipherText = ' + cipherText);
       *   // @results 'cipherText = (...cipherText)'
       *   var origText = arc4.decrypt(cipherText);
       *   debug('origText = ' + origText);
       *   // @results 'origText = Hello World!'
       *
       *
       * @param  {String}  text  Cipher text to be decrypted.
       * @return {String}        The decrypted string.
       *
       * @type Function
       * @public
       */
      decrypt : update(function(text) {
        return Pot.UTF8.decode(
          arc4Crypt(
            text,
            this.key,
            this.table
          ).sync()
        );
      }, {
        /**
         * @lends Pot.Crypt.Arc4.decrypt
         */
        /**
         * Decrypt given cipher text using the key with RC4 algorithm.
         * All parameters and return value are in binary format.
         * Decrypt with asynchronous,
         *  and returns new instance of Pot.Deferred.
         *
         *
         * @example
         *   var arc4 = new Pot.Crypt.Arc4();
         *   arc4.setKey('hoge');
         *   arc4.encrypt.deferred('Hello World!')
         *               .then(function(cipherText) {
         *     debug('cipherText = ' + cipherText);
         *     // @results 'cipherText = (...cipherText)'
         *     return arc4.decrypt.deferred(cipherText)
         *                        .then(function(origText) {
         *       debug('origText = ' + origText);
         *       // @results 'origText = Hello World!'
         *     });
         *   });
         *
         *
         * @param  {String}        string  Cipher text to be decrypted.
         * @return {Pot.Deferred}          Returns new instance of
         *                                   Pot.Deferred with the
         *                                   decrypted string.
         * @type  Function
         * @public
         *
         * @property {Function} limp   Run with slowest speed.
         * @property {Function} doze   Run with slower speed.
         * @property {Function} slow   Run with slow speed.
         * @property {Function} normal Run with default speed.
         * @property {Function} fast   Run with fast speed.
         * @property {Function} rapid  Run with faster speed.
         * @property {Function} ninja  Run fastest speed.
         */
        deferred : PotInternal.defineDeferrater(function(speed) {
          var func = function(text) {
            var that = func.instance;
            return arc4Crypt(
              text,
              that.key,
              that.table
            ).async(speed).then(function(res) {
              return Pot.UTF8.decode(res);
            });
          };
          return func;
        })
      })
    });
    arc4.prototype.init.prototype = arc4.prototype;
    return arc4;
  }())
});

// Update methods for reference.
Pot.update({
  hashCode : Pot.Crypt.hashCode,
  md5      : Pot.Crypt.md5,
  crc32    : Pot.Crypt.crc32,
  sha1     : Pot.Crypt.sha1,
  Arc4     : Pot.Crypt.Arc4
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Net.
(function() {

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Net utilities.
   *
   * @name Pot.Net
   * @type Object
   * @class
   * @static
   * @public
   */
  Net : {}
});

update(Pot.Net, {
  /**
   * @lends Pot.Net
   */
  /**
   * Send HTTP request.
   *
   *
   * @example
   *   Pot.Net.request('/data.cgi', {
   *     method : 'POST',
   *     sendContent : {
   *       query  : 'Book OR Media',
   *       start  : 0,
   *       length : 15,
   *       format : 'json'
   *     },
   *     mimeType : 'application/json',
   *     headers : {
   *       'Content-Type' : 'text/javascript'
   *     }
   *   }).then(function(res) {
   *     debug(res.responseText);
   *   }, function(err) {
   *     debug('Error!');
   *     debug(err);
   *   });
   *
   *
   * @param  {String}     url      The request URL.
   * @param  {Object}   (options)  Request options.
   *                                 <pre>
   *                                 +----------------------------------
   *                                 | Available options:
   *                                 +----------------------------------
   *                                 - method       : {String}    'GET'
   *                                 - sendContent  : {Object}    null
   *                                 - queryString  : {Object}    null
   *                                 - username     : {String}    null
   *                                 - password     : {String}    null
   *                                 - headers      : {Object}    null
   *                                 - mimeType     : {String}    null
   *                                 - cache        : {Boolean}   true
   *                                 - sync         : {Boolean}   false
   *                                 - responseType : {String}    null
   *                                 - binary       : {Boolean}   false
   *                                 - cookie       : {Boolean}   false
   *                                 - crossDomain  : {Boolean}   false
   *                                 </pre>
   * @return {Deferred}            Return the instance of Pot.Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  request : function(url, options) {
    if (PotSystem.isGreasemonkey) {
      return Pot.Net.requestByGreasemonkey(url, options);
    } else if (PotSystem.isNodeJS) {
      return Pot.Net.requestByNodeJS(url, options);
    } else {
      return Pot.Net.XHR.request(url, options);
    }
  },
  /**
   * The XMLHttpRequest handler object.
   *
   * @type Object
   * @class
   * @public
   * @static
   */
  XHR : {
    /**
     * @lends Pot.Net.XHR
     */
    /**
     * Status constants for XMLHTTP:
     *
     * {@link http://msdn.microsoft.com/library/default.asp?url=/library/
     *         en-us/xmlsdk/html/0e6a34e4-f90c-489d-acff-cb44242fafc6.asp }
     *
     * @enum {Number}
     * @type Object
     * @const
     * @static
     */
    ReadyState : {
      UNINITIALIZED : 0,
      LOADING       : 1,
      LOADED        : 2,
      INTERACTIVE   : 3,
      COMPLETE      : 4
    },
    /**
     * XMLHttpRequest factory.
     *
     * @return {Object}     The XMLHttpRequest object.
     * @type Function
     * @function
     * @public
     * @static
     */
    factory : function() {
      var x;
      try {
        x = new XMLHttpRequest();
      } catch (e) {}
      if (!x && PotSystem.hasActiveXObject) {
        each([
          'MSXML2.XMLHTTP.6.0',
          'MSXML2.XMLHTTP.3.0',
          'MSXML2.XMLHTTP',
          'Microsoft.XMLHTTP',
          'Msxml2.XMLHTTP.4.0'
        ], function(prog) {
          try {
            x = new ActiveXObject(prog);
          } catch (e) {}
          if (x) {
            throw PotStopIteration;
          }
        });
      }
      return x;
    },
    /**
     * Send HTTP request with the XMLHttpRequest.
     *
     *
     * @example
     *   Pot.Net.XHR.request('/data.cgi', {
     *     method : 'POST',
     *     sendContent : {
     *       query  : 'Book OR Media',
     *       start  : 0,
     *       length : 15,
     *       format : 'json'
     *     },
     *     headers : {
     *       'Content-Type' : 'text/javascript'
     *     }
     *   }).then(function(res) {
     *     debug(res.responseText);
     *   }, function(err) {
     *     debug('Error!');
     *     debug(err);
     *   });
     *
     *
     * @param  {String}     url      The request URL.
     * @param  {Object}   (options)  Request options.
     *                                 <pre>
     *                                 +----------------------------------
     *                                 | Available options:
     *                                 +----------------------------------
     *                                 - method       : {String}    'GET'
     *                                 - sendContent  : {Object}    null
     *                                 - queryString  : {Object}    null
     *                                 - username     : {String}    null
     *                                 - password     : {String}    null
     *                                 - headers      : {Object}    null
     *                                 - mimeType     : {String}    null
     *                                 - cache        : {Boolean}   true
     *                                 - sync         : {Boolean}   false
     *                                 - responseType : {String}    null
     *                                 - binary       : {Boolean}   false
     *                                 - cookie       : {Boolean}   false
     *                                 - crossDomain  : {Boolean}   false
     *                                 </pre>
     * @return {Deferred}            Return the instance of Pot.Deferred.
     * @type Function
     * @function
     * @public
     * @static
     */
    request : (function() {
      /**@ignore*/
      var Request = function(url, options) {
        return new Request.prototype.doit(url, options);
      },
      PATTERNS = {
        URI : /^([^:]+)(?::+\/{0,}((?:[^@]+@|)[^\/\\?&#:;]*)(?::(\d+)|)|)/
      },
      CURRENT_URIS = PATTERNS.URI.exec(Pot.currentURI().toLowerCase()) || [];
      Request.prototype = update(Request.prototype, {
        /**
         * @ignore
         */
        xhr : null,
        /**
         * @ignore
         */
        url : null,
        /**
         * @ignore
         */
        options : {},
        /**
         * @ignore
         */
        deferred : null,
        /**
         * @private
         * @ignore
         */
        doit : function(url, options) {
          var that = this;
          this.url = stringify(url, true);
          this.deferred = new Deferred({
            /**@ignore*/
            canceller : function() {
              try {
                that.cancel(true);
              } catch (e) {}
            }
          });
          if (this.url) {
            try {
              this.setOptions(options);
              if (this.factory()) {
                this.open();
                this.setHeaders();
                this.setReadyStateChange();
                this.send();
              }
            } catch (e) {
              try {
                this.cancel(true);
              } catch (ex) {}
              this.deferred.raise(e);
            }
          }
          return this;
        },
        /**
         * @private
         * @ignore
         */
        factory : function() {
          this.xhr = Pot.Net.XHR.factory();
          if (!this.xhr) {
            this.deferred.raise('Failed to create XMLHttpRequest');
            return false;
          } else {
            return true;
          }
        },
        /**
         * @private
         * @ignore
         */
        setOptions : function(options) {
          var opts, parts, defaults = {
            method       : 'GET',
            sendContent  : null,
            queryString  : null,
            callback     : null,
            username     : null,
            password     : null,
            mimeType     : null,
            responseType : null,
            binary       : false,
            cache        : true,
            sync         : false,
            cookie       : false,
            crossDomain  : null,
            headers      : {
              'Accept'           : ['*/'] + ['*'], //XXX: Check MimeType.
              'X-Requested-With' : 'XMLHttpRequest'
            }
          };
          if (isObject(options)) {
            opts = update({}, options);
          } else {
            opts = {};
          }
          this.options = update({}, defaults, opts || {});
          this.method = trim(this.options.method).toUpperCase();
          if (!this.method) {
            this.method = defaults.method;
          }
          this.url = buildURL(this.url, this.options.queryString);
          this.options.sendContent = stringify(
            Pot.Serializer.serializeToQueryString(this.options.sendContent),
            true
          );
          if ((this.options.method === 'GET' ||
               this.options.method === defaults.method) &&
              (this.options.sendContent)) {
            this.options.method = 'POST';
          }
          if (!this.options.cache &&
              (this.options.method === 'GET' ||
               this.options.method === 'HEAD')) {
            this.url = addNoCache(this.url);
          }
          if (this.options.crossDomain == null) {
            PATTERNS.URI.lastIndex = 0;
            parts = PATTERNS.URI.exec(Pot.currentURI().toLowerCase());
            this.options.crossDomain = !!(parts &&
              (parts[1] !== CURRENT_URIS[1] ||
               parts[2] !== CURRENT_URIS[2] ||
               parts[3] !== CURRENT_URIS[3])
            );
          }
          if (this.options.binary && !this.options.mimeType) {
            this.options.mimeType = 'text/plain; charset=x-user-defined';
          }
          if (this.options.sync) {
            this.deferred.async(false);
          }
        },
        /**
         * @private
         * @ignore
         */
        open : function() {
          var async = this.options.sync ? false : true;
          if (this.options.username != null) {
            this.xhr.open(
              this.options.method,
              this.url,
              async,
              stringify(this.options.username, true),
              stringify(this.options.password, true)
            );
          } else {
            this.xhr.open(this.options.method, this.url, async);
          }
        },
        /**
         * @private
         * @ignore
         */
        setHeaders : function() {
          var that = this, contentType;
          try {
            if (this.options.responseType) {
              try {
                this.xhr.responseType = this.options.responseType;
              } catch (e) {}
            }
            if (this.options.cookie) {
              try {
                // https://developer.mozilla.org/en/HTTP_access_control
                this.xhr.withCredentials = 'true';
              } catch (e) {}
            }
            try {
              if (this.xhr.overrideMimeType &&
                  this.options.mimeType != null) {
                this.xhr.overrideMimeType(this.options.mimeType);
              }
            } catch (e) {}
            if (this.options.contentType != null) {
              contentType = this.options.contentType;
            }
            if (this.options.headers != null) {
              each(this.options.headers, function(value, name) {
                if (!contentType && /^Content-?Type/i.test(name)) {
                  contentType = value;
                } else {
                  that.xhr.setRequestHeader(name, value);
                }
              });
            }
            if (!contentType &&
                this.options.method === 'POST') {
              contentType =
                'application/x-www-form-urlencoded; charset=UTF-8';
            }
            if (contentType) {
              this.xhr.setRequestHeader('Content-Type', contentType);
            }
          } catch (e) {}
        },
        /**
         * @private
         * @ignore
         */
        setReadyStateChange : function() {
          var that = this, flush;
          if (this.options.sync) {
            /**@ignore*/
            flush = function(f) {
              var d = new Deferred({async : false});
              return d.then(f).begin();
            };
          } else {
            flush = Deferred.flush;
          }
          /**@ignore*/
          this.xhr.onreadystatechange = function() {
            var status = null, text;
            if (that.xhr.readyState == Pot.Net.XHR.ReadyState.COMPLETE) {
              that.cancel();
              try {
                status = parseInt(that.xhr.status, 10);
                text = that.xhr.responseText;
                if (!status && text) {
                  // 0 or undefined seems to mean cached or local
                  status = 304;
                }
              } catch (e) {}
              // 1223 is apparently a bug in IE
              if ((status >= 200 && status < 300) ||
                  status === 304 || status === 1223) {
                that.assignResponseText();
                if (isFunction(that.options.callback)) {
                  flush(function() {
                    that.options.callback.call(
                      that.xhr, text, that.xhr
                    );
                  }).ensure(function(res) {
                    that.deferred.begin(that.xhr);
                  });
                } else {
                  that.deferred.begin(that.xhr);
                }
              } else {
                that.deferred.raise(update({}, that.xhr));
                try {
                  that.cancel(true);
                } catch (e) {}
              }
            }
          };
        },
        /**
         * @private
         * @ignore
         */
        assignResponseText : function() {
          var i, len, bytes, chars, c, s;
          if (this.options.binary) {
            bytes = [];
            chars = [];
            try {
              // IE will throws exception when Text is binary data.
              s = this.xhr.responseText || '';
            } catch (e) {
              s = '';
            }
            len = s.length;
            for (i = 0; i < len; i++) {
              c = s.charCodeAt(i) & 0xFF;
              bytes[i] = c;
              chars[i] = fromUnicode(c);
            }
            try {
              this.xhr.originalText  = s;
              this.xhr.responseBytes = bytes;
              this.xhr.responseText  = chars.join('');
            } catch (e) {
              try {
                this.xhr = update(this.xhr, {
                  originalText  : s,
                  responseBytes : bytes,
                  responseText  : chars.join('')
                });
              } catch (ex) {}
            }
          }
        },
        /**
         * @private
         * @ignore
         */
        cancel : function(isAbort) {
          // IE SUCKS
          try {
            this.xhr.onreadystatechange = null;
          } catch (e) {
            try {
              this.xhr.onreadystatechange = PotNoop;
            } catch (e) {}
          }
          if (isAbort) {
            try {
              this.xhr.abort();
            } catch (e) {}
          }
        },
        /**
         * @private
         * @ignore
         */
        send : function() {
          this.xhr.send(this.options.sendContent);
          this.deferred.data({
            request : this.xhr
          });
        }
      });
      Request.prototype.doit.prototype = Request.prototype;
      return function(url, options) {
        return (new Request(url, options)).deferred;
      };
    }())
  },
  /**
   * @lends Pot.Net
   */
  /**
   * Send request by Greasemonkey.
   *
   * @internal
   * @private
   * @ignore
   */
  requestByGreasemonkey : function(url, options) {
    var d = new Deferred(), type, lazy,
        opts = update({cache : true}, options || {}),
        maps = {
          sendContent : 'data',
          mimeType    : 'overrideMimeType',
          username    : 'user',
          sync        : 'synchronous'
        };
    each(maps, function(gm, org) {
      if (org in opts) {
        opts[gm] = opts[org];
      }
    });
    opts.method = trim(opts.method).toUpperCase() || 'GET';
    opts.url = buildURL(url, opts.queryString);
    if (opts.data) {
      opts.data = Pot.Serializer.serializeToQueryString(opts.data);
    }
    if (opts.data && opts.method === 'GET') {
      opts.method = 'POST';
    }
    if (!opts.cache &&
        (opts.method === 'GET' || opts.method === 'HEAD')) {
      opts.url = addNoCache(opts.url);
    }
    type = opts.contentType;
    if (opts.headers) {
      each(opts.headers, function(v, k) {
        if (!type && /^Content-?Type/i.test(k)) {
          type = v;
          throw PotStopIteration;
        }
      });
    }
    if (!type && opts.method === 'POST') {
      type = 'application/x-www-form-urlencoded';
    }
    if (type) {
      opts.headers = update(opts.headers || {}, {
        'Content-Type' : type
      });
    }
    if (opts.sync) {
      d.async(false);
      /**@ignore*/
      lazy = function(f) {
        f();
      };
    } else {
      /**@ignore*/
      lazy = Deferred.callLazy;
    }
    if (opts.onload) {
      d.then(opts.onload);
    }
    if (opts.onerror) {
      d.rescue(opts.onerror);
    }
    update(opts, {
      /**@ignore*/
      onload : function() {
        d.begin.apply(d, arguments);
      },
      /**@ignore*/
      onerror : function() {
        d.raise.apply(d, arguments);
      }
    });
    lazy(function() {
      var req = GM_xmlhttpRequest(opts);
      d.data({
        request : req
      });
      d.canceller(function() {
        try {
          req.abort();
        } catch (e) {}
      });
    });
    return d;
  },
  /**
   * Send request by Node.js::http(s).
   *
   * @internal
   * @private
   * @ignore
   */
  requestByNodeJS : (function() {
    /**
     * @ignore
     */
    function SimpleRequestByNode(options) {
      return new SimpleRequestByNode.prototype.doit(options);
    }
    /**
     * @ignore
     */
    function SimpleResponseByNode(res) {
      return new SimpleResponseByNode.prototype.init(res);
    }
    // Definition of prototype.
    SimpleResponseByNode.prototype = update(SimpleResponseByNode.prototype, {
      /**
       * @private
       * @ignore
       */
      responseText : '',
      /**
       * @private
       * @ignore
       */
      responseXML : '',
      /**
       * @private
       * @ignore
       */
      status : null,
      /**
       * @private
       * @ignore
       */
      statusText : null,
      /**
       * @private
       * @ignore
       */
      init : function(response) {
        var res = response || {};
        update(this, res, {
          getResponseHeader     : this.getResponseHeader,
          getAllResponseHeaders : this.getAllResponseHeaders,
          responseText          : res.responseText,
          responseXML           : res.responseXML,
          status                : res.status,
          statusText            : res.statusText
        });
        return this;
      },
      /**
       * @private
       * @ignore
       */
      getResponseHeader : function(name) {
        var result = null, key;
        key = stringify(name);
        lkey = key.toLowerCase();
        if (this.headers) {
          if (lkey in this.headers) {
            result = this.headers[lkey];
          } else if (key in this.headers) {
            result = this.headers[key];
          }
        }
        return result;
      },
      /**
       * @private
       * @ignore
       */
      getAllResponseHeaders : function() {
        var results = [], key;
        if (this.headers) {
          for (key in this.headers) {
            results.push(key + ': ' + this.headers[key]);
          }
        }
        return results.join('\r\n');
      }
    });
    // Definition of prototype.
    SimpleRequestByNode.prototype = update(SimpleRequestByNode.prototype, {
      /**
       * @private
       * @ignore
       */
      deferred : null,
      /**
       * @private
       * @ignore
       */
      request : null,
      /**
       * @private
       * @ignore
       */
      response : null,
      /**
       * @private
       * @ignore
       */
      headers : {},
      /**
       * @private
       * @ignore
       */
      requestOptions : {},
      /**
       * @private
       * @ignore
       */
      defaultHeaders : {
        'Accept'     : ['*/'] + ['*'],
        'User-Agent' : [
          'Pot.js/' + Pot.VERSION,
          Pot.TYPE,
          '(Node.js; *)'
        ].join(' ')
      },
      /**
       * @private
       * @ignore
       */
      doit : function(options) {
        var that = this;
        this.deferred = new Deferred({
          /**@ignore*/
          canceller : function() {
            try {
              that.abort();
            } catch (e) {}
          }
        });
        this.setOptions(options);
        this.send();
        return this;
      },
      /**
       * @private
       * @ignore
       */
      setOptions : function(options) {
        var opts, method, ssl, uri, host, port, path, auth, data;
        opts = update({
          cache : true,
          sync  : false
        }, options || {});
        method = trim(opts.method).toUpperCase() || 'GET';
        ssl = false;
        uri = require('url').parse(opts.url);
        switch (uri.protocol) {
          case 'https:':
              ssl = true;
          case 'http:':
              host = uri.hostname;
              break;
          default:
              throw new Error('Not supported protocol: ' + uri.protocol);
        }
        port = uri.port || (ssl ? 443 : 80);
        path = uri.pathname + (uri.search ? uri.search : '');
        this.headers = update({}, this.defaultHeaders, opts.headers || {});
        this.headers['Host'] = host;
        if (opts.username != null) {
          auth = new Buffer([
            stringify(opts.username, true),
            stringify(opts.password, true)
          ].join(':'));
          this.headers['Authorization'] = 'Basic ' + auth.toString('base64');
        }
        data = opts.sendContent || opts.queryString;
        if (method === 'GET' || method === 'HEAD') {
          path = buildURL(path, data);
          if (!opts.cache) {
            path = addNoCache(path);
          }
          data = null;
        } else {
          data = Pot.Serializer.serializeToQueryString(data);
          if (data) {
            this.headers['Content-Length'] = Buffer.byteLength(data);
            if (!this.headers['Content-Type']) {
              this.headers['Content-Type'] =
                'application/x-www-form-urlencoded';
            }
          }
        }
        if (opts.sync) {
          this.deferred.async(false);
        }
        this.requestOptions = {
          data : data,
          ssl  : ssl,
          sync : opts.sync,
          settings  : {
            host    : host,
            port    : port,
            path    : path,
            method  : method,
            headers : this.headers
          }
        };
      },
      /**
       * @private
       * @ignore
       */
      send : function() {
        var that = this, doRequest, waiting = true;
        if (this.requestOptions.ssl) {
          doRequest = require('https').request;
        } else {
          doRequest = require('http').request;
        }
        this.request = doRequest(this.requestOptions.settings, function(res) {
          that.response = new SimpleResponseByNode(res);
          that.response.responseText = '';
          that.response.responseXML  = '';
          that.response.setEncoding('utf8');
          that.response.status = that.response.statusCode;
          if (that.response.status == 200 && !that.response.statusText) {
            that.response.statusText = 'OK';
          }
          that.response.on('data', function(chunk) {
            if (chunk) {
              that.response.responseText += stringify(chunk, true);
            }
          });
          that.response.on('end', function() {
            waiting = false;
            that.deferred.begin(that.response);
          });
          that.response.on('error', function(err) {
            waiting = false;
            that.handleError(err);
          });
        }).on('error', function(err) {
          waiting = false;
          that.handleError(err);
        });
        if (this.requestOptions.data) {
          this.request.write(this.requestOptions.data);
        }
        this.request.end();
        if (this.requestOptions.sync) {
          while (waiting) {}
        }
      },
      /**
       * @private
       * @ignore
       */
      handleError : function(error) {
        this.response.status = 503;
        this.response.statusText = error;
        this.response.responseText = error && error.stack;
        this.deferred.raise(this.response);
      },
      /**
       * @private
       * @ignore
       */
      abort : function() {
        if (this.response) {
          this.response.responseText = '';
          this.response.responseXML  = '';
        }
        try {
          if (this.request && this.request.abort) {
            this.request.abort();
          }
        } catch (e) {}
      }
    });
    SimpleRequestByNode.prototype.doit.prototype =
      SimpleRequestByNode.prototype;
    SimpleResponseByNode.prototype.init.prototype =
      SimpleResponseByNode.prototype;
    /**@ignore*/
    return function(url, options) {
      var opts = update({}, options || {}, {
        url : url
      });
      return (new SimpleRequestByNode(opts)).deferred;
    };
  }()),
  /**
   * @lends Pot.Net
   */
  /**
   * Send request by JSONP.
   *
   *
   * @example
   *   // Same as jQuery.jsonp usage.
   *   var url = 'http://www.example.com/jsonpTest?callback=?';
   *   Pot.Net.requestByJSONP(url, {
   *     queryString : {
   *       q : 'JavaScript OR ECMAScript'
   *     }
   *   }).then(function(data) {
   *     debug(data.results[0].text);
   *   });
   *
   *
   * @param  {String}     url      The request URL.
   * @param  {Object}   (options)  Request options.
   *                                 <pre>
   *                                 +------------------------------------
   *                                 | Available options:
   *                                 +------------------------------------
   *                                 - queryString : {Object}   null
   *                                 - cache       : {Boolean}  false
   *                                 - sync        : {Boolean}  false
   *                                 - callback    : {String}   'callback'
   *                                 </pre>
   * @return {Deferred}            Return the instance of Pot.Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  requestByJSONP : (function() {
    /**@ignore*/
    var PATTERNS = {
      KEY  : /json|call/i,
      DONE : /loaded|complete/
    };
    return function(url, options) {
      var d, opts, context, id, callback, key,
          doc, uri, head, script, done, defaults;
      defaults = 'callback';
      d = new Deferred();
      opts    = update({
        cache : false,
        sync  : false
      }, options || {});
      context = globals || PotGlobal;
      doc     = PotSystem.currentDocument;
      head    = getHead();
      if (!context || !doc || !head || !url) {
        return d.raise(context || url || head || doc);
      }
      try {
        if (opts.callback) {
          if (isString(opts.callback)) {
            id = opts.callback;
          } else if (isFunction(opts.callback)) {
            callback = opts.callback;
          } else if (isObject(opts.callback)) {
            for (key in opts.callback) {
              defaults = key;
              if (isString(opts.callback[key])) {
                id = opts.callback[key];
              } else if (isFunction(opts.callback[key])) {
                callback = opts.callback[key];
              }
              break;
            }
          }
        } else {
          each(opts, function(v, k) {
            if (PATTERNS.KEY.test(k)) {
              defaults = k;
              if (isString(v)) {
                id = v;
              } else if (isFunction(v)) {
                callback = v;
              }
              throw PotStopIteration;
            }
          });
        }
        if (!id) {
          do {
            id = buildSerial(Pot, '');
          } while (id in context);
        }
        uri = buildURL(
          insertId(url, id, defaults),
          opts.queryString || opts.sendContent
        );
        if (!opts.cache) {
          uri = addNoCache(uri);
        }
        if (PotSystem.isGreasemonkey) {
          return Pot.Net.requestByGreasemonkey(uri, {
            method : 'GET',
            sync   : opts.sync
          }).then(function(res) {
            var code = trim(res && res.responseText);
            code = code.replace(/^[^{]*|[^}]*$/g, '');
            return Pot.Serializer.parseFromJSON(code);
          });
        }
        script = doc.createElement('script');
        if (opts.sync) {
          d.async(false);
        } else {
          script.async = 'async';
        }
        if (opts.type) {
          script.type = opts.type;
        }
        if (opts.charset) {
          script.charset = opts.charset;
        }
        /**@ignore*/
        context[id] = function() {
          var args = arguments;
          try {
            delete context[id];
          } catch (e) {
            try {
              context[id] = null;
            } catch (e) {}
          }
          try {
            if (script) {
              script.parentNode.removeChild(script);
            }
            script = void 0;
          } catch (e) {}
          if (isFunction(callback)) {
            callback.apply(callback, args);
          }
          d.begin.apply(d, args);
        };
        script.src = uri;
        /**@ignore*/
        script.onload =
        /**@ignore*/
        script.onreadystatechange = function(a, isAbort) {
          if (!done && script &&
              (isAbort === 1 || !script.readyState ||
               PATTERNS.DONE.test(script.readyState))
          ) {
            done = true;
            try {
              script.onload = script.onreadystatechange = null;
            } catch (e) {}
            if (head && script && script.parentNode) {
              try {
                head.removeChild(script);
              } catch (e) {}
            }
            script = void 0;
          }
        };
        d.canceller(function() {
          try {
            if (script) {
              script.onload(0, 1);
            }
          } catch (e) {}
        });
        head.insertBefore(script, head.firstChild);
      } catch (e) {
        d.raise(e);
      }
      return d;
    };
  }()),
  /**
   * @lends Pot.Net
   */
  /**
   * Get the JSON data by HTTP GET request.
   *
   *
   * @example
   *   var url = 'http://www.example.com/hoge.json';
   *   getJSON(url).then(function(data) {
   *     debug(data.results[0].text);
   *   });
   *
   *
   * @param  {String}     url      The request URL.
   * @param  {Object}   (options)  Request options. (@see Pot.Net.request)
   * @return {Deferred}            Return the instance of Pot.Deferred.
   * @type Function
   * @function
   * @public
   * @static
   */
  getJSON : (function() {
    var fixJson = /^[^{]*|[^}]*$/g,
        type = 'application/json';
    return function(url, options) {
      return Pot.Net.request(url, update({
        mimeType : type,
        headers  : {
          'Content-Type' : type
        }
      }, options || {})).then(function(res) {
        var data = trim(res && res.responseText).replace(fixJson, '');
        return Pot.Serializer.parseFromJSON(data);
      });
    };
  }()),
  /**
   * @lends Pot.Net
   */
  /**
   * Non-blocking script loader.
   *
   * @param  {String}             url        The script URL or URI.
   * @param  {Object|Function}   (options)   The loading options.
   * @return {Deferred}                      Return the Deferred.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  loadScript : (function() {
    var PATTERNS;
    if (PotSystem.isNonBrowser || !PotSystem.isNotExtension) {
      return function(url, options) {
        return Pot.Net.request(url, update({
          method   : 'GET',
          mimeType : 'application/javascript',
          headers  : {
            'Content-Type' : 'application/javascript'
          }
        }, {
          cache : false,
          sync  : false
        }, options || {})).then(function(res) {
          return Pot.globalEval(res.responseText);
        });
      };
    }
    /**@ignore*/
    PATTERNS = {
      DONE     : /loaded|complete/,
      CALLBACK : /^callback|(?:on|)(?:load(?:ed|)|ready)/i
    };
    return function(url, options) {
      var d, script, opts, doc, head, uri, callback, done;
      d = new Deferred();
      try {
        if (isFunction(options)) {
          opts = {callback : opts};
          callback = opts.callback;
        } else {
          opts = update({}, options || {});
          each(opts, function(v, k) {
            if (isFunction(v)) {
              callback = v;
              if (PATTERNS.CALLBACK.test(k)) {
                throw PotStopIteration;
              }
            }
          });
        }
        if (callback) {
          d.then(function() {
            return callback.apply(this, arguments);
          });
        }
        uri = buildURL(url, opts.queryString || opts.sendContent);
        if (!opts.cache) {
          uri = addNoCache(uri);
        }
        doc = PotSystem.currentDocument;
        head = getHead();
        if (!doc || !head || !uri) {
          return d.raise(uri || head || doc);
        }
        script = doc.createElement('script');
        if (opts.sync) {
          d.async(false);
        } else {
          script.async = 'async';
        }
        script.type = opts.type || 'text/javascript';
        if (opts.charset) {
          script.charset = opts.charset;
        }
        script.src = uri;
        /**@ignore*/
        script.onload =
        /**@ignore*/
        script.onreadystatechange = function(a, isAbort) {
          if (!done && script &&
              (isAbort === 1 || !script.readyState ||
               PATTERNS.DONE.test(script.readyState))
          ) {
            done = true;
            try {
              script.onload = script.onreadystatechange = null;
            } catch (e) {}
            if (head && script && script.parentNode) {
              try {
                head.removeChild(script);
              } catch (e) {}
            }
            script = void 0;
            d.begin();
          }
        };
        d.canceller(function() {
          try {
            if (script) {
              script.onload(0, 1);
            }
          } catch (e) {}
        });
        head.insertBefore(script, head.firstChild);
      } catch (e) {
        d.raise(e);
      }
      return d;
    };
  }())
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Private functions.

/**
 * @private
 * @ignore
 */
function buildURL(url, query) {
  var u, q, p;
  u = stringify(url);
  p = (~u.indexOf('?')) ? '&' : '?';
  q = stringify(Pot.Serializer.serializeToQueryString(query));
  while (u.slice(-1) === p) {
    u = u.slice(0, -1);
  }
  while (q.charAt(0) === p) {
    q = q.substring(1);
  }
  if (q) {
    q = p + q;
  }
  return u ? u + q : null;
}

/**
 * @private
 * @ignore
 */
function addNoCache(uri) {
  var url = stringify(uri), key, sep = '?', pre = '_';
  if (url) {
    do {
      key = pre + buildSerial(Pot, '').toLowerCase();
    } while (~url.indexOf(key));
    if (~url.indexOf(sep)) {
      sep = '&';
      while (url.slice(-1) === sep) {
        url = url.slice(0, -1);
      }
    }
    url = url + sep + key + '=' + now();
  }
  return url;
}

/**
 * @private
 * @ignore
 */
function getHead() {
  var heads, doc = PotSystem.currentDocument;
  try {
    if (doc.head && isElement(doc.head)) {
      return doc.head;
    }
  } catch (e) {}
  try {
    heads = doc.getElementsByTagName('head');
    if (heads && isElement(heads[0])) {
      return heads[0];
    }
  } catch (e) {}
  try {
    return doc.documentElement;
  } catch (e) {}
}

/**
 * @private
 * @ignore
 */
function insertId(url, id, defaults) {
  var uri = stringify(url);
  if (~uri.indexOf('=?')) {
    uri = uri.replace('=?', '=' + id);
  } else if (~uri.indexOf('?')) {
    uri = uri.replace('?', '?' + defaults + '=' + id);
  } else {
    while (uri.slice(-1) === '&') {
      uri = uri.slice(0, -1);
    }
    uri = uri + '?' + defaults + '=' + id;
  }
  return uri;
}

// Update methods for reference.
Pot.update({
  request    : Pot.Net.request,
  jsonp      : Pot.Net.requestByJSONP,
  getJSON    : Pot.Net.getJSON,
  loadScript : Pot.Net.loadScript
});

}());

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Mozilla XPCOM interfaces/methods.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * XPCOM utilities.
   *
   * @name Pot.XPCOM
   * @type Object
   * @class
   * @static
   * @public
   */
  XPCOM : {}
});

update(Pot.XPCOM, {
  /**
   * @lends Pot.XPCOM
   */
  /**
   * Evaluate JavaScript code in the sandbox.
   *
   * @param  {String}  code   The expression.
   * @param  {String}  url    The sandbox URL.
   * @return {*}              Return the result of expression.
   * @type Function
   * @function
   * @public
   * @static
   */
  evalInSandbox : function(code, url) {
    var result, re, src;
    if (PotSystem.hasComponents) {
      if (!Cu) {
        PotSystem.isWaitable = PotSystem.hasComponents = false;
        return;
      }
      re = /^[\s;]*|[\s;]*$/g;
      src = stringify(code).replace(re, '');
      result = Cu.evalInSandbox(src, Cu.Sandbox(url));
    }
    return result;
  },
  /**
   * Wait until condition is true on the thread in non-blocking.
   * If true returned, waiting state will end.
   *
   * @param  {Function|*}  cond  A function or value as condition.
   * @based  Tombloo Lib
   * @type Function
   * @function
   * @public
   * @static
   */
  throughout : function(cond) {
    var thread;
    if (PotSystem.hasComponents) {
      try {
        thread = Cc['@mozilla.org/thread-manager;1']
                .getService(Ci.nsIThreadManager).mainThread;
      } catch (e) {
        PotSystem.isWaitable = PotSystem.hasComponents = false;
      }
      if (thread && PotSystem.hasComponents) {
        do {
          thread.processNextEvent(true);
        } while (cond && !cond());
      }
    }
  },
  /**
   * Get a browser window that was active last.
   *
   * @return {Window}       Return the browser window.
   * @type Function
   * @function
   * @public
   * @static
   */
  getMostRecentWindow : function() {
    var cwin;
    if (PotSystem.hasComponents) {
      try {
        cwin = Cc['@mozilla.org/appshell/window-mediator;1']
              .getService(Ci.nsIWindowMediator)
              .getMostRecentWindow('navigator:browser');
      } catch (e) {
        PotSystem.isWaitable = PotSystem.hasComponents = false;
      }
    }
    return cwin;
  },
  /**
   * Get the specific XUL Window.
   *
   * @param  {String}  uri  The target URI to get.
   *                        Will be the browser window if omitted.
   * @return {Object}       XULWindow.
   * @type Function
   * @function
   * @public
   * @static
   */
  getChromeWindow : function(uri) {
    var result, win, wins, pref;
    if (!PotSystem.hasComponents) {
      return;
    }
    pref = uri || 'chrome://browser/content/browser.xul';
    try {
      wins = Cc['@mozilla.org/appshell/window-mediator;1']
            .getService(Ci.nsIWindowMediator)
            .getXULWindowEnumerator(null);
    } catch (e) {
      PotSystem.isWaitable = PotSystem.hasComponents = false;
      return;
    }
    while (wins.hasMoreElements()) {
      try {
        win = wins.getNext()
            .QueryInterface(Ci.nsIXULWindow).docShell
            .QueryInterface(Ci.nsIInterfaceRequestor)
            .getInterface(Ci.nsIDOMWindow);
        if (win && win.location &&
            (win.location.href == pref || win.location == pref)) {
          result = win;
          break;
        }
      } catch (e) {}
    }
    return result;
  }
});

// Update Pot object.
Pot.update({
  evalInSandbox       : Pot.XPCOM.evalInSandbox,
  throughout          : Pot.XPCOM.throughout,
  getMostRecentWindow : Pot.XPCOM.getMostRecentWindow,
  getChromeWindow     : Pot.XPCOM.getChromeWindow
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Signal/Event.
(function() {
var
/**@ignore*/
handlers         = [],
propHandlers     = [],
attachedHandlers = [],
trappers         = {},
handlersLocked   = false,
errorKey         = '*e',
PREFIX           = '.',
RE               = {
  MOUSE_OVER : /mouse(?:over|enter)/,
  MOUSE_OUT  : /mouse(?:out|leave)/,
  EVENT_ONCE : /^(?:on|)(?:(?:un|)load|DOMContentLoaded)$/,
  ID_CLEAN   : /^#/
},
Handler,
Observer;

Pot.update({
  /**
   * Signal/Event utilities.
   *
   * @name Pot.Signal
   * @type Object
   * @class
   * @static
   * @public
   */
  Signal : {}
});

// Refer the Pot properties/functions.
Signal = Pot.Signal;

update(Signal, {
  /**
   * @lends Pot.Signal
   */
  /**
   * @ignore
   */
  NAME : 'Signal',
  /**
   * @ignore
   */
  toString : PotToString,
  /**
   * @ignore
   */
  Handler : update(function(args) {
    return new Handler.fn.init(args);
  }, {
    /**
     * @lends Pot.Signal.Handler
     */
    /**
     * @ignore
     * @const
     * @private
     */
    advices : {
      normal     : 0x01,
      before     : 0x02,
      around     : 0x04,
      after      : 0x08,
      propBefore : 0x10,
      propAround : 0x20,
      propAfter  : 0x40
    }
  }),
  /**
   * @lends Pot.Signal
   */
  /**
   * @private
   * @ignore
   */
  Observer : function(object, ev) {
    var that = this, evt, pi = this.PotInternal;
    if (!pi.serial) {
      pi.serial = buildSerial(this);
    }
    update(pi, {
      orgEvent : ev || (typeof window === 'object' && window.event) || {},
      object   : object
    });
    evt = pi.orgEvent;
    if (!isObject(evt)) {
      pi.orgEvent = evt = {type : evt};
    }
    each(update({}, evt), function(v, p) {
      if (!hasOwnProperty.call(that, p)) {
        that[p] = v;
      }
    });
    try {
      if (!evt.target) {
        evt.target = evt.srcElement || Pot.currentDocument() || {};
      }
      if (evt.target.nodeType == 3 && evt.target.parentNode) {
        evt.target = evt.target.parentNode;
      }
      if (evt.metaKey == null) {
        evt.metaKey = evt.ctrlKey;
      }
      if (evt.timeStamp == null) {
        evt.timeStamp = now();
      }
      if (evt.relatedTarget == null) {
        if (RE.MOUSE_OVER.test(evt.type)) {
          evt.relatedTarget = evt.fromElement;
        } else if (RE.MOUSE_OUT.test(evt.type)) {
          evt.relatedTarget = evt.toElement;
        }
      }
    } catch (ex) {}
    this.originalEvent = evt;
  },
  /**
   * @lends Pot.Signal
   */
  /**
   * Drop file constructor.
   *
   *
   * @example
   *   // This example using jQuery.
   *   var panel = $('<div/>')
   *     .css({
   *       position   : 'fixed',
   *       left       : '10%',
   *       top        : '10%',
   *       width      : '80%',
   *       height     : '80%',
   *       minHeight  : 200,
   *       background : '#ccc',
   *       border     : '2px solid #999',
   *       zIndex     : 9999999
   *     })
   *     .hide()
   *     .text('Drop here')
   *     .appendTo('body');
   *   var dropFile = new Pot.DropFile(panel, {
   *     onShow : function() { panel.show() },
   *     onHide : function() { panel.hide() },
   *     onDrop : function(files) {
   *       panel.text('dropped');
   *     },
   *     onLoadImage : function(data, name, size) {
   *       $('<img/>').attr('src', data).appendTo('body');
   *     },
   *     onLoadText : function(data, name, size) {
   *       $('<textarea/>').val(data).appendTo('body');
   *     },
   *     onLoadUnknown : function(data, name, size) {
   *       $('<textarea/>').val(data).appendTo('body');
   *     },
   *     onLoadEnd : function(files) {
   *       this.upload(
   *         'http://www.example.com/',
   *         'dropfiles'
   *       ).then(function() {
   *         alert('finish upload.');
   *       });
   *     }
   *   });
   *   alert("Let's try drag and drop any file from your desktop.");
   *
   *
   * @param  {Element|String}  target    Target element or id.
   * @param  {Object|String}  (options)  Options for drop file:
   *                                     -------------------------------------
   *                                     - onShow : {Function}
   *                                         Should display a message that
   *                                         is able to dropped.
   *                                     - onHide : {Function}
   *                                         Should hide a message that
   *                                         is not able to dropped.
   *                                     - onDrop : {Function}
   *                                         Called when a file is dropped.
   *                                     - onLoadImage : {Function}
   *                                         Called when a file is
   *                                           loaded as image.
   *                                     - onLoadText : {Function}
   *                                         Called when a file is
   *                                           loaded as text.
   *                                     - onLoadUnknown : {Function}
   *                                         Called when a file is
   *                                           loaded as unknown type.
   *                                     - onLoadEnd : {Function}
   *                                         Called when a file is loaded.
   *                                         (i.e. enable to upload).
   *                                     -------------------------------------
   * @return {DropFile}                  Return an instance of Pot.DropFile.
   * @name Pot.Signal.DropFile
   * @constructor
   * @public
   */
  DropFile : function(target, options) {
    return new DropFile.fn.init(target, options);
  },
  /**
   * @lends Pot.Signal
   */
  /**
   * Check whether the argument object is an instance of Pot.Signal.Handler.
   *
   *
   * @param  {Object|*}  x  The target object to test.
   * @return {Boolean}      Return true if the argument object is an
   *                          instance of Pot.Signal.Handler,
   *                          otherwise return false.
   * @type Function
   * @function
   * @static
   */
  isHandler : function(x) {
    return x != null && ((x instanceof Handler) ||
     (x.id   != null && x.id   === Handler.fn.id &&
      x.NAME != null && x.NAME === Handler.fn.NAME));
  },
  /**
   * Check whether the argument object is an instance of Pot.Signal.Observer.
   *
   *
   * @param  {Object|*}  x  The target object to test.
   * @return {Boolean}      Return true if the argument object is an
   *                          instance of Pot.Signal.Observer,
   *                          otherwise return false.
   * @type Function
   * @function
   * @static
   */
  isObserver : function(x) {
    return x != null && ((x instanceof Observer) ||
     (x.PotInternal != null && x.PotInternal.id != null &&
      x.PotInternal.id === Observer.fn.PotInternal.id &&
      x.PotInternal.NAME != null &&
      x.PotInternal.NAME === Observer.fn.PotInternal.NAME));
  },
  /**
   * Attaches a signal to a slot,
   *  and return a handler object as a unique identifier that
   *  can be used to detach that signal.
   *
   *
   * @example
   *   // Usage like addEventListener/removeEventListener.
   *   // Will get to a DOM element by document.getElementById if the
   *   //   first argument passed as a string.
   *   var handler = attach('#foo', 'click', function(ev) {...});
   *   //
   *   // Release the signal(Event).
   *   detach(handler);
   *
   *
   * @example
   *   // Example code of signal for Object usage.
   *   var MyObj = {};
   *   // Register your own signal.
   *   var handler = attach(MyObj, 'clear-data', function() {
   *     // To initialize the properties etc.
   *     MyObj.data = null;
   *     MyObj.time = null;
   *   });
   *   attach(window, 'load', function() {
   *     // Send a signal to initialize.
   *     signal(MyObj, 'clear-data');
   *     // Also set to clear when you press the reset button.
   *     attach('#reset', 'click', function() {
   *       signal(MyObj, 'clear-data');
   *     });
   *     // Existing processing etc.
   *     myLoadProcess();
   *     //...
   *   });
   *
   *
   * @param  {Object|Function|String}  object
   *           The object that be target of the signal.
   *           If passed in a string then will be a
   *             HTML element by document.getElementById.
   * @param  {String|Array}  signalName
   *           `signalName` is a string that represents a signal name.
   *           If `object` is a DOM object then
   *             it can be specify one of the 'onxxx' native events.
   *           That case 'on' prefix is optionally.
   * @param  {Function}  callback
   *           An action to take when the signal is triggered.
   * @param  {Boolean}  (useCapture)
   *           (Optional) `useCapture` will passed its 3rd argument to
   *             addEventListener if environment is available it on DOM.
   * @param  {Boolean}  (once)
   *           (Optional) Only internal usage.
   * @return {Object|Array}
   *           Return an instance of Pot.Signal.Handler object as
   *             a unique identifier that can be used to detach that signal.
   *
   * @type Function
   * @function
   * @class
   * @public
   * @static
   */
  attach : function(object, signalName, callback, useCapture, once) {
    var results = [], isDOM, isMulti, capture, advice,
        o = getElement(object);
    if (!o) {
      return;
    }
    isDOM = isDOMObject(o);
    capture = !!useCapture;
    if (isArray(signalName)) {
      isMulti = true;
    }
    advice = Handler.advices.normal;
    each(arrayize(signalName), function(sig) {
      var sigName, handler, listener;
      sigName = stringify(sig);
      listener = createListener(
        o, sigName, callback, capture, isDOM, once, advice
      );
      handler = new Handler({
        object     : o,
        signal     : sigName,
        listener   : listener,
        callback   : callback,
        isDOM      : isDOM,
        useCapture : capture,
        advice     : advice,
        attached   : true
      });
      withHandlers(function(hs) {
        hs[hs.length] = handler;
      });
      if (isDOM) {
        if (o.addEventListener) {
          o.addEventListener(
            adaptSignalForDOM(o, sigName),
            listener,
            capture
          );
        } else if (o.attachEvent) {
          o.attachEvent(
            adaptSignalForDOM(o, sigName),
            listener
          );
        }
      }
      results[results.length] = handler;
    });
    return isMulti ? results : results[0];
  },
  /**
   * Attaches a signal to a slot on before,
   *  and return a handler object as a unique identifier that
   *  can be used to detach that signal.
   *
   *
   * @example
   *   // Set the event of pressing the Save button.
   *   attach('#saveData', 'click', function() {
   *     // Saving function.
   *     saveData(document.getElementById('inputText').value);
   *     // Function to send a message to user that the data saved.
   *     showSaveData('Saved!');
   *   });
   *   // Add the callback function for
   *   //  move the focus after click the element.
   *   attachAfter('#saveData', 'click', function() {
   *     document.getElementById('inputText').focus();
   *   });
   *   // To configure the logging before calling it.
   *   attachBefore('#saveData', 'click', function() {
   *     MyLogger.log('Save inputText');
   *   });
   *
   *
   * @param  {Object|Function|String}  object
   *           The object that be target of the signal.
   *           If passed in a string then will be a
   *             HTML element by document.getElementById.
   * @param  {String|Array}  signalName
   *           `signalName` is a string that represents a signal name.
   *           If `object` is a DOM object then
   *             it can be specify one of the 'onxxx' native events.
   *           That case 'on' prefix is optionally.
   * @param  {Function}  callback
   *           An action to take when the signal is triggered.
   * @param  {Boolean}  (useCapture)
   *           (Optional) `useCapture` will passed its 3rd argument to
   *             addEventListener if environment is available it on DOM.
   * @param  {Boolean}  (once)
   *           (Optional) Only internal usage.
   * @return {Object|Array}
   *           Return an instance of Pot.Signal.Handler object as
   *             a unique identifier that can be used to detach that signal.
   *
   * @type Function
   * @function
   * @class
   * @public
   * @static
   */
  attachBefore : function(object, signalName, callback, useCapture, once) {
    return attachByJoinPoint(
      object, signalName, callback,
      Handler.advices.before, once
    );
  },
  /**
   * Attaches a signal to a slot on after,
   *  and return a handler object as a unique identifier that
   *  can be used to detach that signal.
   *
   *
   * @example
   *   // Set the event of pressing the Save button.
   *   attach('#saveData', 'click', function() {
   *     // Saving function.
   *     saveData(document.getElementById('inputText').value);
   *     // Function to send a message to user that the data saved.
   *     showSaveData('Saved!');
   *   });
   *   // Add the callback function for
   *   //  move the focus after click the element.
   *   attachAfter('#saveData', 'click', function() {
   *     document.getElementById('inputText').focus();
   *   });
   *   // To configure the logging before calling it.
   *   attachBefore('#saveData', 'click', function() {
   *     MyLogger.log('Save inputText');
   *   });
   *
   *
   * @param  {Object|Function|String}  object
   *           The object that be target of the signal.
   *           If passed in a string then will be a
   *             HTML element by document.getElementById.
   * @param  {String|Array}  signalName
   *           `signalName` is a string that represents a signal name.
   *           If `object` is a DOM object then
   *             it can be specify one of the 'onxxx' native events.
   *           That case 'on' prefix is optionally.
   * @param  {Function}  callback
   *           An action to take when the signal is triggered.
   * @param  {Boolean}  (useCapture)
   *           (Optional) `useCapture` will passed its 3rd argument to
   *             addEventListener if environment is available it on DOM.
   * @param  {Boolean}  (once)
   *           (Optional) Only internal usage.
   * @return {Object|Array}
   *           Return an instance of Pot.Signal.Handler object as
   *             a unique identifier that can be used to detach that signal.
   *
   * @type Function
   * @function
   * @class
   * @public
   * @static
   */
  attachAfter : function(object, signalName, callback, useCapture, once) {
    return attachByJoinPoint(
      object, signalName, callback,
      Handler.advices.after, once
    );
  },
  /**
   * Attaches a signal to a slot on before,
   *  and return a handler object as a unique identifier that
   *  can be used to detach that signal.
   * When method is called, this callback will be triggered.
   *
   *
   * @example
   *   // Example code for add callback to the
   *   //  Object direct like aspect settings.
   *   var MyApp = {
   *     execute : function() {
   *       // Begin something process.
   *       myAppDoit();
   *     }
   *   };
   *   attach('#execute', 'click', function() {
   *     // Execute Application.
   *     MyApp.execute();
   *   });
   *   // Add a logging callback function before execution.
   *   attachPropBefore(MyApp, 'execute', function() {
   *     MyLogger.log('Begin execute');
   *   });
   *   // Add a logging callback function after execution.
   *   attachPropAfter(MyApp, 'execute', function() {
   *     MyLogger.log('End execute');
   *   });
   *
   *
   * @param  {Object|Function|String}  object
   *           The object that be target of the signal.
   *           If passed in a string then will be a
   *             HTML element by document.getElementById.
   * @param  {String|Array}  signalName
   *           `signalName` is a string that represents a signal name.
   *           If `object` is a DOM object then
   *             it can be specify one of the 'onxxx' native events.
   *           That case 'on' prefix is optionally.
   * @param  {Function}  callback
   *           An action to take when the signal is triggered.
   * @param  {Boolean}  (useCapture)
   *           (Optional) `useCapture` will passed its 3rd argument to
   *             addEventListener if environment is available it on DOM.
   * @param  {Boolean}  (once)
   *           (Optional) Only internal usage.
   * @return {Object|Array}
   *           Return an instance of Pot.Signal.Handler object as
   *             a unique identifier that can be used to detach that signal.
   *
   * @type Function
   * @function
   * @class
   * @public
   * @static
   */
  attachPropBefore : function(object, propName, callback, useCapture, once) {
    return attachPropByJoinPoint(
      object, propName, callback,
      Handler.advices.propBefore, once
    );
  },
  /**
   * Attaches a signal to a slot on after,
   *  and return a handler object as a unique identifier that
   *  can be used to detach that signal.
   * When method is called, this callback will be triggered.
   *
   *
   * @example
   *   // Example code for add callback to the
   *   //  Object direct like aspect settings.
   *   var MyApp = {
   *     execute : function() {
   *       // Begin something process.
   *       myAppDoit();
   *     }
   *   };
   *   attach('#execute', 'click', function() {
   *     // Execute Application.
   *     MyApp.execute();
   *   });
   *   // Add a logging callback function before execution.
   *   attachPropBefore(MyApp, 'execute', function() {
   *     MyLogger.log('Begin execute');
   *   });
   *   // Add a logging callback function after execution.
   *   attachPropAfter(MyApp, 'execute', function() {
   *     MyLogger.log('End execute');
   *   });
   *
   *
   * @param  {Object|Function|String}  object
   *           The object that be target of the signal.
   *           If passed in a string then will be a
   *             HTML element by document.getElementById.
   * @param  {String|Array}  signalName
   *           `signalName` is a string that represents a signal name.
   *           If `object` is a DOM object then
   *             it can be specify one of the 'onxxx' native events.
   *           That case 'on' prefix is optionally.
   * @param  {Function}  callback
   *           An action to take when the signal is triggered.
   * @param  {Boolean}  (useCapture)
   *           (Optional) `useCapture` will passed its 3rd argument to
   *             addEventListener if environment is available it on DOM.
   * @param  {Boolean}  (once)
   *           (Optional) Only internal usage.
   * @return {Object|Array}
   *           Return an instance of Pot.Signal.Handler object as
   *             a unique identifier that can be used to detach that signal.
   *
   * @type Function
   * @function
   * @class
   * @public
   * @static
   */
  attachPropAfter : function(object, propName, callback, useCapture, once) {
    return attachPropByJoinPoint(
      object, propName, callback,
      Handler.advices.propAfter, once
    );
  },
  /**
   * Detaches a signal.
   * To detach a signal, pass its handler identifier returned by attach().
   * This is similar to how the setTimeout and clearTimeout works.
   *
   *
   * @example
   *   // This is similar to how the setTimeout and clearTimeout works.
   *   var handler = attach('#foo', 'click', function(ev) {...});
   *   // Release the signal(Event).
   *   detach(handler);
   *
   *
   * @param  {Object|Function}  object
   *           An instance identifier of Pot.Signal.Handler object that
   *             returned by attach().
   *           Or if signal using DOM object, you can specify the same as the
   *             removeEventListener arguments usage.
   * @param  {String}  (signalName)
   *           (Optional) If `object` is a DOM object,
   *             you can specify same as the
   *             removeEventListener arguments usage.
   *           `signalName` is the signal/event in string.
   * @param  {Function}  (callback)
   *           (Optional) If `object` is a DOM object,
   *             you can specify same as the
   *             removeEventListener arguments usage.
   *           `callback` is a trigger function.
   * @param  {Boolean}  (useCapture)
   *           (Optional) If `object` is a DOM object,
   *             you can specify same as the
   *             removeEventListener arguments usage.
   *           `useCapture` is 3rd argument of
   *             removeEventListener if environment is available it on DOM.
   * @return {Boolean}
   *           Success or failure.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  detach : function(object, signalName, callback, useCapture) {
    var result = false, args = arguments, target,
        o = getElement(object);
    if (!o) {
      return;
    }
    if (Signal.isHandler(o)) {
      eachHandlers(function(h) {
        if (h && h.attached && h === o) {
          target = h;
          throw PotStopIteration;
        }
      });
    } else if (args.length > 1) {
      eachHandlers(function(h) {
        if (h && h.attached &&
            h.object === o &&
            h.signal == signalName &&
            h.callback === callback
        ) {
          target = h;
          throw PotStopIteration;
        }
      });
    }
    if (target) {
      detachHandler(target);
      result = true;
    }
    return result;
  },
  /**
   * Removes all set of signals connected with object.
   *
   *
   * @example
   *   // Release all of element's event.
   *   var foo = document.getElementById('foo');
   *   attach(foo, 'click',     function(ev) {...});
   *   attach(foo, 'mouseover', function(ev) {...});
   *   attach(foo, 'mouseout',  function(ev) {...});
   *   // Detach all of foo's events.
   *   detachAll(foo);
   *
   *
   * @example
   *   // Release all of signals.
   *   attach(window,        'load',      function(ev) {...});
   *   attach(document.body, 'mousemove', function(ev) {...});
   *   attach('#foo',        'click',     function(ev) {...});
   *   // Detach all of signals.
   *   detachAll();
   *
   *
   * @param  {Object|Function}  (object)
   *           (Optional) An instance identifier of
   *             Pot.Signal.Handler object that returned by attach().
   *           If omitted, a global object will be target.
   * @param  {String|Array}  (signals)
   *           (Optional) A signal or an event name in string
   *             for detach and remove.
   *           If passed as an Array, will be target all signal items.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  detachAll : function(/*[object[, signals]]*/) {
    var args = arguments,
        o, signals = [], sigs = {}, targets = [];
    switch (args.length) {
      case 0:
          break;
      case 1:
          o = args[0];
          break;
      case 2:
          o = args[0];
          signals = args[1] || [];
          break;
      default:
          o = args[0];
          signals = arrayize(args, 1);
    }
    if (o != null) {
      o = getElement(o);
    }
    signals = arrayize(signals);
    each(signals, function(sig) {
      sigs[PREFIX + stringify(sig)] = true;
    });
    eachHandlers(function(h) {
      if (!h ||
          ((o == null || h.object === o) &&
          ((!signals  || signals.length === 0) ||
          (signals.length && h.signal in sigs)))
      ) {
        if (h && h.attached) {
          targets[targets.length] = h;
        }
      }
    });
    each(targets, function(h) {
      detachHandler(h);
    });
  },
  /**
   * `signal` will send signal to a connected with object and triggered.
   * When signal is called with an object and the specify signal,
   *   the observer function will be triggered.
   * Note that when using this function for DOM signals,
   *   a single event argument is expected by most listeners.
   *
   *
   * @example
   *   // Example code of signal for Object usage.
   *   var MyObj = {};
   *   // Register your own signal.
   *   var handler = attach(MyObj, 'clear-data', function() {
   *     // To initialize the properties etc.
   *     MyObj.data = null;
   *     MyObj.time = null;
   *   });
   *   attach(window, 'load', function() {
   *     // Send a signal to initialize.
   *     signal(MyObj, 'clear-data');
   *     // Also set to clear when you press the reset button.
   *     attach('#reset', 'click', function() {
   *       signal(MyObj, 'clear-data');
   *     });
   *     // Existing processing etc.
   *     myLoadProcess();
   *     //...
   *   });
   *
   *
   * @param  {Object|Function}  object
   *           An instance identifier of
   *             Pot.Signal.Handler object that returned by attach().
   * @param  {String|Array}  signalName
   *           A signal or an event name in string for signal.
   * @return {Deferred}
   *           Return result of triggered as an instance of Pot.Deferred.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  signal : function(object, signalName) {
    var deferred, args = arrayize(arguments, 2),
        errors = [], sigName, advice, signals = {},
        o = getElement(object);
    if (!o) {
      return;
    }
    deferred = newDeferred();
    sigName = signalName;
    advice = Handler.advices.normal;
    each(arrayize(sigName), function(sig) {
      signals[PREFIX + stringify(sig)] = true;
    });
    eachHandlers(function(h) {
      if (h && h.attached &&
          h.advice === advice &&
          h.object === o &&
          ((PREFIX + h.signal) in signals)
      ) {
        deferred.then(function() {
          var result = h.listener.apply(o, args);
          if (isDeferred(result)) {
            result.begin();
          }
          return result;
        }, function(err) {
          errors[errors.length] = err;
        });
      }
    });
    return deferred.ensure(function(res) {
      if (isError(res)) {
        errors[errors.length] = res;
      }
      switch (errors.length) {
        case 0:
            break;
        case 1:
            throw errors[0];
        default:
            throw update(errors[0] || {}, {errors : errors});
      }
      return res;
    }).begin();
  },
  /**
   * Cancel and stop event.
   *
   *
   * @example
   *   attach('#foo', 'click', function(ev) {
   *     myProcess();
   *     return cancelEvent(ev);
   *   });
   *
   *
   * @param  {Event}    ev  The event object.
   * @return {Boolean}      Returns always false.
   * @type   Function
   * @function
   * @public
   * @static
   */
  cancelEvent : function(ev) {
    /**@ignore*/
    var f = function(v) {
      try {
        v.preventDefault();
        v.stopPropagation();
      } catch (e) {}
    };
    if (ev) {
      f();
      if (ev.originalEvent) {
        f(ev.originalEvent);
      }
      if (ev.PotInternal && ev.PotInternal.orgEvent) {
        f(ev.PotInternal.orgEvent);
      }
    }
    return false;
  }
});

// Refer the Pot properties/functions.
DropFile = Signal.DropFile;

Handler  = Signal.Handler;
Observer = Signal.Observer;

// Definition of prototype.
DropFile.fn = DropFile.prototype = update(DropFile.prototype, {
  /**
   * @lends Pot.Signal.DropFile.prototype
   */
  /**
   * @private
   * @ignore
   * @internal
   */
  constructor : DropFile,
  /**
   * @private
   * @ignore
   */
  id : PotInternal.getMagicNumber(),
  /**
   * @private
   * @ignore
   * @const
   */
  NAME : 'DropFile',
  /**
   * A unique strings.
   *
   * @type  String
   * @const
   * @ignore
   */
  serial : null,
  /**
   * toString.
   *
   * @return  Return formatted string of object.
   * @type Function
   * @function
   * @static
   * @ignore
   */
  toString : PotToString,
  /**
   * @ignore
   * @private
   */
  defaultOptions : {
    onShow         : null,
    onHide         : null,
    onDrop         : null,
    onLoadImage    : null,
    onLoadText     : null,
    onLoadUnknown  : null,
    onLoadEnd      : null,
    onProgress     : null,
    onProgressFile : null,
    // readAs:
    //  - 'text'
    //  - 'binary'
    //  - 'arraybuffer'
    //  - 'datauri'
    //  or null (auto)
    readAs         : null,
    encoding       : null
  },
  /**
   * Text encoding.
   *
   * @type  String
   * @ignore
   */
  encoding : null,
  /**
   * @ignore
   * @private
   */
  loadedFiles : [],
  /**
   * @ignore
   * @private
   */
  handleCache : [],
  /**
   * @ignore
   * @private
   */
  target : [],
  /**
   * @ignore
   * @private
   */
  options : {},
  /**
   * @ignore
   * @private
   */
  isShow : false,
  /**
   * Initialize properties.
   *
   * @private
   * @ignore
   */
  init : function(target, options) {
    if (!this.serial) {
      this.serial = buildSerial(this);
    }
    this.loadedFiles = [];
    this.handleCache = [];
    this.isShow = false;
    this.target = getElement(target);
    this.options = update({}, this.defaultOptions, options || {});
    if (this.options.encoding) {
      this.encoding = this.options.encoding;
    }
    this.assignReadType();
    if (this.target) {
      this.initEvents();
    }
    return this;
  },
  /**
   * Clear drop events.
   *
   * @public
   */
  clearDropEvents : function() {
    each(this.handleCache, function(h) {
      Signal.detach(h);
    });
    this.handleCache = [];
  },
  /**
   * Initialize events.
   *
   * @private
   * @ignore
   */
  initEvents : function() {
    var that = this, target = this.target, html,
        cache = this.handleCache, op = this.options, ps = Signal;
    cache[cache.length] = ps.attach(target, 'drop', function(ev) {
      var files, reader, i = 0, total, fileList,
          deferreds = {
            seek   : new Deferred(),
            files  : [],
            steps  : [],
            ends   : [true],
            done   : false
          },
          /**@ignore*/
          pushFiles = function(evt) {
            if (evt && evt.target && evt.target.result != null) {
              that.loadedFiles.push(evt.target.result);
              return true;
            } else {
              return false;
            }
          };
      that.isShow = false;
      fileList = ev.dataTransfer && ev.dataTransfer.files;
      if (fileList) {
        total = 0;
        files = [];
        each(fileList, function(file) {
          if (file) {
            files[total++] = file;
          }
        });
        if (op.onDrop) {
          op.onDrop.call(that, files, total);
        }
        if (PotSystem.hasFileReader) {
          reader = new FileReader();
          /**@ignore*/
          reader.onloadend = function(evt) {
            if (pushFiles(evt)) {
              if (deferreds.files[i] && !deferreds.ends[i]) {
                deferreds.files[i].begin();
              }
            }
          };
          Deferred.forEach(files, function(file) {
            if (file) {
              deferreds.seek.then(function() {
                var fileinfo = update({}, file, {index : i++});
                return Deferred.till(function() {
                  return !Pot.some(deferreds.ends, function(end) {
                    return end === false;
                  });
                }).then(function() {
                  deferreds.ends[i] = false;
                  deferreds.steps[i] = new Deferred();
                  deferreds.files[i] = new Deferred().then(function() {
                    if (that.isImageFile(fileinfo.type)) {
                      that.loadAsImage(deferreds, i, total, file, fileinfo);
                    } else if (that.isTextFile(fileinfo.type)) {
                      that.loadAsText(deferreds, i, total, file, fileinfo);
                    } else {
                      that.loadAsUnknown(deferreds, i, total, file, fileinfo);
                    }
                    return deferreds.steps[i];
                  });
                  that.readFile(reader, file);
                  return deferreds.files[i];
                });
              });
            }
          }).then(function() {
            deferreds.seek.then(function() {
              var done = Pot.every(deferreds.ends, function(end) {
                return end === true;
              });
              if (done && !deferreds.done) {
                deferreds.done = true;
                if (op.onProgress) {
                  that.updateProgressEnd();
                }
                if (op.onLoadEnd) {
                  op.onLoadEnd.call(that, arrayize(that.loadedFiles));
                }
              }
            }).begin();
          });
        }
      }
    });
    cache[cache.length] = ps.attach(target, 'dragenter', function(ev) {
      that.isShow = true;
      ps.cancelEvent(ev);
    });
    cache[cache.length] = ps.attach(target, 'dragover', function(ev) {
      that.isShow = true;
      ps.cancelEvent(ev);
    });
    cache[cache.length] = ps.attach(target, 'dragleave', function(ev) {
      that.isShow = false;
    });
    if (op.onHide) {
      op.onHide.call(that);
    }
    html = Pot.currentDocument().documentElement;
    cache[cache.length] = ps.attach(html, 'drop', function(ev) {
      that.isShow = false;
      if (op.onHide) {
        op.onHide.call(that);
      }
      ps.cancelEvent(ev);
    });
    cache[cache.length] = ps.attach(html, 'dragleave', function(ev) {
      PotInternalSetTimeout(function() {
        if (that.isShow) {
          that.isShow = false;
        } else {
          if (op.onHide) {
            op.onHide.call(that);
          }
        }
      }, 1000);
    });
    each(['dragenter', 'dragover'], function(type) {
      cache[cache.length] = ps.attach(html, type, function(ev) {
        var dt = ev && ev.dataTransfer, doShow, re;
        if (dt) {
          if (dt.files && dt.files.length) {
            doShow = true;
          } else if (dt.types) {
            re = /Files/i;
            if (re.test(dt.types)) {
              doShow = true;
            } else if (isArrayLike(dt.types)) {
              each(dt.types, function(t) {
                if (re.test(t)) {
                  doShow = true;
                  throw PotStopIteration;
                }
              });
            }
          }
        }
        if (doShow) {
          that.isShow = true;
          if (op.onShow) {
            op.onShow.call(that);
          }
        }
        ps.cancelEvent(ev);
      });
    });
  },
  /**
   * @private
   * @ignore
   */
  readFile : function(reader, file, isText) {
    switch (this.options.readAs) {
      case 'text':
          if (this.encoding) {
            reader.readAsText(file, this.encoding);
          } else {
            reader.readAsText(file);
          }
          break;
      case 'binary':
          reader.readAsBinaryString(file);
          break;
      case 'arraybuffer':
          reader.readAsArrayBuffer(file);
          break;
      case 'datauri':
          reader.readAsDataURL(file);
          break;
      default:
          if (isText) {
            if (this.encoding) {
              reader.readAsText(file, this.encoding);
            } else {
              reader.readAsText(file);
            }
          } else {
            reader.readAsDataURL(file);
          }
    }
  },
  /**
   * @private
   * @ignore
   */
  assignReadType : function() {
    var res, type = stringify(this.options.readAs).toLowerCase();
    if (~type.indexOf('text')) {
      res = 'text';
    } else if (~type.indexOf('bin')) {
      res = 'binary';
    } else if (~type.indexOf('arr') || ~type.indexOf('buf')) {
      res = 'arraybuffer';
    } else if (~type.indexOf('data') || ~type.indexOf('ur')) {
      res = 'datauri';
    } else {
      res = null;
    }
    this.options.readAs = res;
  },
  /**
   * @private
   * @ignore
   */
  isImageFile : function(type) {
    return /image/i.test(type);
  },
  /**
   * @private
   * @ignore
   */
  isTextFile : function(type) {
    return !/image|audio|video|zip|compress|stream/i.test(type);
  },
  /**
   * Upload the dropped files with specified options.
   *
   *
   * @example
   *   // This example using jQuery.
   *   var panel = $('<div/>')
   *     .css({
   *       position   : 'fixed',
   *       left       : '10%',
   *       top        : '10%',
   *       width      : '80%',
   *       height     : '80%',
   *       minHeight  : 200,
   *       background : '#ccc',
   *       border     : '2px solid #999',
   *       zIndex     : 9999999
   *     })
   *     .hide()
   *     .text('Drop here')
   *     .appendTo('body');
   *   var dropFile = new Pot.DropFile(panel, {
   *     onShow : function() { panel.show() },
   *     onHide : function() { panel.hide() },
   *     onDrop : function(files) {
   *       panel.text('dropped');
   *     },
   *     onLoadImage : function(data, name, size) {
   *       $('<img/>').attr('src', data).appendTo('body');
   *     },
   *     onLoadText : function(data, name, size) {
   *       $('<textarea/>').val(data).appendTo('body');
   *     },
   *     onLoadUnknown : function(data, name, size) {
   *       $('<textarea/>').val(data).appendTo('body');
   *     },
   *     onLoadEnd : function(files) {
   *       this.upload(
   *         'http://www.example.com/',
   *         'dropfiles'
   *       ).then(function() {
   *         alert('finish upload.');
   *       });
   *     }
   *   });
   *   alert("Let's try drag and drop any file from your desktop.");
   *
   *
   * @param  {String}             url      Target url to upload.
   * @param  {Object|String|*}  (options)  Upload options.
   *                                       Available parameters:
   *                                       -----------------------------------
   *                                       - key : {String}
   *                                           The file data key name in
   *                                             query string if specify.
   *                                           (default = 'file').
   *                                       - sendContent : {Object|Array}
   *                                           Other parameters if you need.
   *                                       -----------------------------------
   * @return {Deferred}                    Return the Pot.Deferred instance.
   * @type Function
   * @function
   * @public
   */
  upload : function(url, options) {
    var d, uri, files = this.loadedFiles,
        opts = {}, re, data, key = 'file';
    if (files && files.length) {
      if (isString(options)) {
        key = options;
      } else if (isObject(options)) {
        re = /key|file|name/i;
        each(options, function(v, k) {
          if (isString(v) && re.test(k)) {
            key = v;
            throw PotStopIteration;
          }
        });
        opts = update({}, options);
      }
      uri = stringify(url);
      re = /([^@:;#?&=\/\\]+)=[?]/;
      if (re.test(uri)) {
        key = uri.match(re)[1];
        uri = uri.replace(key, '');
      }
      data = opts.sendContent || opts.queryString || {};
      if (isArray(data)) {
        data[data.length] = [key, files.splice(0, files.length)];
      } else {
        data[key] = files.splice(0, files.length);
      }
      opts.sendContent = data;
      opts.queryString = null;
      opts.method = opts.method || 'POST';
      d = Pot.Net.request(uri, opts);
    }
    return Deferred.maybeDeferred(d);
  },
  /**
   * @private
   * @ignore
   */
  loadAsImage : function(deferreds, i, total, file, fileinfo) {
    var that = this,
        op = this.options,
        reader = new FileReader(),
        callback = op.onLoadImage;
    if (op.onProgressFile) {
      /**@ignore*/
      reader.onprogress = function(ev) {
        that.updateProgressFile(ev, fileinfo, total);
      };
    }
    /**@ignore*/
    reader.onload = function(ev) {
      deferreds.ends[i] = true;
      deferreds.steps[i].begin();
      if (op.onProgressFile) {
        that.updateProgressFileEnd(fileinfo);
      }
      if (callback) {
        callback.call(
          that,
          ev && ev.target && ev.target.result,
          fileinfo
        );
      }
    };
    /**@ignore*/
    reader.onerror = function(err) {
      deferreds.ends[i] = true;
      deferreds.steps[i].raise(err);
    };
    this.readFile(reader, file);
  },
  /**
   * @private
   * @ignore
   */
  loadAsText : function(deferreds, i, total, file, fileinfo) {
    var that = this,
        op = this.options,
        reader = new FileReader(),
        callback = op.onLoadText;
    if (op.onProgressFile) {
      /**@ignore*/
      reader.onprogress = function(ev) {
        that.updateProgressFile(ev, fileinfo, total);
      };
    }
    /**@ignore*/
    reader.onload = function(ev) {
      deferreds.ends[i] = true;
      deferreds.steps[i].begin();
      if (op.onProgressFile) {
        that.updateProgressFileEnd(fileinfo);
      }
      if (callback) {
        callback.call(
          that,
          ev && ev.target && ev.target.result,
          fileinfo
        );
      }
    };
    /**@ignore*/
    reader.onerror = function(err) {
      deferreds.ends[i] = true;
      deferreds.steps[i].raise(err);
    };
    this.readFile(reader, file, true);
  },
  /**
   * @private
   * @ignore
   */
  loadAsUnknown : function(deferreds, i, total, file, fileinfo) {
    var that = this,
        op = this.options,
        reader = new FileReader(),
        callback = op.onLoadUnknown;
    if (op.onProgressFile) {
      /**@ignore*/
      reader.onprogress = function(ev) {
        that.updateProgressFile(ev, fileinfo, total);
      };
    }
    /**@ignore*/
    reader.onload = function(ev) {
      deferreds.ends[i] = true;
      deferreds.steps[i].begin();
      if (op.onProgressFile) {
        that.updateProgressFileEnd(fileinfo);
      }
      if (callback) {
        callback.call(
          that,
          ev && ev.target && ev.target.result,
          fileinfo
        );
      }
    };
    /**@ignore*/
    reader.onerror = function(err) {
      deferreds.ends[i] = true;
      deferreds.steps[i].raise(err);
    };
    this.readFile(reader, file);
  },
  /**
   * @private
   * @ignore
   */
  updateProgress : function(index, total) {
    var per, callback = this.options.onProgress;
    if (callback) {
      per = Math.max(0,
              Math.min(100,
                Math.round((index / total) * 100)
              )
      );
      callback.call(this, per);
    }
  },
  /**
   * @private
   * @ignore
   */
  updateProgressEnd : function() {
    var callback = this.options.onProgress;
    if (callback) {
      callback.call(this, 100);
    }
  },
  /**
   * @private
   * @ignore
   */
  updateProgressFile : function(evt, fileinfo, total) {
    var per, op = this.options, callback = op.onProgressFile;
    if (callback &&
        evt && evt.lengthComputable && evt.loaded != null) {
      per = Math.max(0,
              Math.min(100,
                Math.round((evt.loaded / evt.total) * 100)
              )
      );
      callback.call(this, per, fileinfo);
    }
    if (op.onProgress) {
      this.updateProgress(fileinfo.index, total);
    }
  },
  /**
   * @private
   * @ignore
   */
  updateProgressFileEnd : function(fileinfo) {
    var callback = this.options.onProgressFile;
    if (callback) {
      callback.call(this, 100, fileinfo);
    }
  }
});
DropFile.fn.init.prototype = DropFile.fn;

// Definition of prototype.
Handler.fn = Handler.prototype = update(Handler.prototype, {
  /**
   * @lends Pot.Signal.Handler.prototype
   */
  /**
   * @private
   * @ignore
   * @internal
   */
  constructor : Handler,
  /**
   * @private
   * @ignore
   */
  id : PotInternal.getMagicNumber(),
  /**
   * @private
   * @ignore
   * @const
   */
  NAME : 'Handler',
  /**
   * A unique strings.
   *
   * @type  String
   * @const
   * @ignore
   */
  serial : null,
  /**
   * toString.
   *
   * @return  Return formatted string of object.
   * @type Function
   * @function
   * @static
   * @ignore
   */
  toString : PotToString,
  /**
   * Initialize properties
   *
   * @private
   * @ignore
   */
  init : function(params) {
    if (!this.serial) {
      this.serial = buildSerial(this);
    }
    update(this, params);
    return this;
  }
});
Handler.fn.init.prototype = Handler.fn;

Observer.fn = Observer.prototype = {
  /**
   * @lends Pot.Signal.Observer.prototype
   */
  /**
   * @ignore
   */
  constructor : Observer,
  /**
   * @private
   * @ignore
   * @internal
   */
  PotInternal : {
    /**
     * @ignore
     */
    id : PotInternal.getMagicNumber(),
    /**
     * @ignore
     */
    NAME : 'Observer',
    /**
     * @ignore
     */
    serial : null,
    /**
     * @ignore
     */
    orgEvent : null,
    /**
     * @ignore
     */
    object : null
  },
  /**
   * toString.
   *
   * @return  Return formatted string of object.
   * @type Function
   * @function
   * @ignore
   */
  toString : function() {
    return buildObjectString(this.PotInternal.NAME);
  },
  /**
   * preventDefault.
   *
   * @type Function
   * @function
   * @ignore
   */
  preventDefault : function() {
    var ev;
    try {
      ev = this.PotInternal.orgEvent;
      if (ev) {
        if (ev.preventDefault) {
          ev.preventDefault();
        } else {
          ev.returnValue = false;
        }
      }
    } catch (e) {}
    if (this.originalEvent) {
      try {
        ev = this.originalEvent;
        if (ev) {
          if (ev.preventDefault) {
            ev.preventDefault();
          } else {
            ev.returnValue = false;
          }
        }
      } catch (e) {}
    }
  },
  /**
   * stopPropagation.
   *
   * @type Function
   * @function
   * @ignore
   */
  stopPropagation : function() {
    var ev;
    try {
      ev = this.PotInternal.orgEvent;
      if (ev) {
        if (ev.stopPropagation) {
          ev.stopPropagation();
        }
        ev.cancelBubble = true;
      }
    } catch (e) {}
    if (this.originalEvent) {
      try {
        ev = this.originalEvent;
        if (ev) {
          if (ev.stopPropagation) {
            ev.stopPropagation();
          }
          ev.cancelBubble = true;
        }
      } catch (e) {}
    }
  }
};

// Definition of 'once' methods.
each({
  /**
   * Similar to attach*(),
   *   but detaches the signal handler automatically once it has fired.
   *
   *
   * @example
   *   attach.once(document.body, 'click', function() {
   *     alert('This message will show only once.');
   *   });
   *
   *
   * @param  {Object|Function|String}  object
   *           The object that be target of the signal.
   *           If passed in a string then will be a
   *             HTML element by document.getElementById.
   * @param  {String}  signalName
   *           `signalName` is a string that represents a signal name.
   *           If `object` is a DOM object then
   *             it can be specify one of the 'onxxx' native events.
   *           That case 'on' prefix is optionally.
   * @param  {Function}  callback
   *           An action to take when the signal is triggered.
   * @param  {Boolean}  (useCapture)
   *           (Optional) `useCapture` will passed its 3rd argument to
   *             addEventListener if environment is available it on DOM.
   * @return {Object}
   *           Return an instance of Pot.Signal.Handler object as
   *             a unique identifier that can be used to detach that signal.
   *
   * @name Pot.Signal.attach.once
   * @type Function
   * @function
   * @public
   * @static
   */
  attach : 4,
  /**
   * Similar to attach*(),
   *   but detaches the signal handler automatically once it has fired.
   *
   *
   * @example
   *   attachBefore.once(document.body, 'click', function() {
   *     alert('This message will show only once.');
   *   });
   *
   *
   * @param  {Object|Function|String}  object
   *           The object that be target of the signal.
   *           If passed in a string then will be a
   *             HTML element by document.getElementById.
   * @param  {String}  signalName
   *           `signalName` is a string that represents a signal name.
   *           If `object` is a DOM object then
   *             it can be specify one of the 'onxxx' native events.
   *           That case 'on' prefix is optionally.
   * @param  {Function}  callback
   *           An action to take when the signal is triggered.
   * @param  {Boolean}  (useCapture)
   *           (Optional) `useCapture` will passed its 3rd argument to
   *             addEventListener if environment is available it on DOM.
   * @return {Object}
   *           Return an instance of Pot.Signal.Handler object as
   *             a unique identifier that can be used to detach that signal.
   *
   * @name Pot.Signal.attachBefore.once
   * @type Function
   * @function
   * @public
   * @static
   */
  attachBefore : 4,
  /**
   * Similar to attach*(),
   *   but detaches the signal handler automatically once it has fired.
   *
   *
   * @example
   *   attachAfter.once(document.body, 'click', function() {
   *     alert('This message will show only once.');
   *   });
   *
   *
   * @param  {Object|Function|String}  object
   *           The object that be target of the signal.
   *           If passed in a string then will be a
   *             HTML element by document.getElementById.
   * @param  {String}  signalName
   *           `signalName` is a string that represents a signal name.
   *           If `object` is a DOM object then
   *             it can be specify one of the 'onxxx' native events.
   *           That case 'on' prefix is optionally.
   * @param  {Function}  callback
   *           An action to take when the signal is triggered.
   * @param  {Boolean}  (useCapture)
   *           (Optional) `useCapture` will passed its 3rd argument to
   *             addEventListener if environment is available it on DOM.
   * @return {Object}
   *           Return an instance of Pot.Signal.Handler object as
   *             a unique identifier that can be used to detach that signal.
   *
   * @name Pot.Signal.attachAfter.once
   * @type Function
   * @function
   * @public
   * @static
   */
  attachAfter : 4,
  /**
   * Similar to attach*(),
   *   but detaches the signal handler automatically once it has fired.
   *
   *
   * @example
   *   attachPropBefore.once(MyObj, 'initialize', function() {
   *     alert('This message will show only once.');
   *   });
   *
   *
   * @param  {Object|Function|String}  object
   *           The object that be target of the signal.
   *           If passed in a string then will be a
   *             HTML element by document.getElementById.
   * @param  {String}  signalName
   *           `signalName` is a string that represents a signal name.
   *           If `object` is a DOM object then
   *             it can be specify one of the 'onxxx' native events.
   *           That case 'on' prefix is optionally.
   * @param  {Function}  callback
   *           An action to take when the signal is triggered.
   * @param  {Boolean}  (useCapture)
   *           (Optional) `useCapture` will passed its 3rd argument to
   *             addEventListener if environment is available it on DOM.
   * @return {Object}
   *           Return an instance of Pot.Signal.Handler object as
   *             a unique identifier that can be used to detach that signal.
   *
   * @name Pot.Signal.attachPropBefore.once
   * @type Function
   * @function
   * @public
   * @static
   */
  attachPropBefore : 4,
  /**
   * Similar to attach*(),
   *   but detaches the signal handler automatically once it has fired.
   *
   *
   * @example
   *   attachPropAfter.once(MyObj, 'initialize', function() {
   *     alert('This message will show only once.');
   *   });
   *
   *
   * @param  {Object|Function|String}  object
   *           The object that be target of the signal.
   *           If passed in a string then will be a
   *             HTML element by document.getElementById.
   * @param  {String}  signalName
   *           `signalName` is a string that represents a signal name.
   *           If `object` is a DOM object then
   *             it can be specify one of the 'onxxx' native events.
   *           That case 'on' prefix is optionally.
   * @param  {Function}  callback
   *           An action to take when the signal is triggered.
   * @param  {Boolean}  (useCapture)
   *           (Optional) `useCapture` will passed its 3rd argument to
   *             addEventListener if environment is available it on DOM.
   * @return {Object}
   *           Return an instance of Pot.Signal.Handler object as
   *             a unique identifier that can be used to detach that signal.
   *
   * @name Pot.Signal.attachPropAfter.once
   * @type Function
   * @function
   * @public
   * @static
   */
  attachPropAfter : 4
}, function(index, name) {
  update(Signal[name], {
    /**@ignore*/
    once : function() {
      var args = arrayize(arguments);
      args[index] = true;
      return Signal[name].apply(Signal, args);
    }
  });
});

// Definition of internal signal trappers.
each({
  /**@ignore*/
  normal     : true,
  /**@ignore*/
  before     : true,
  /**@ignore*/
  after      : true,
  /**@ignore*/
  propBefore : true,
  /**@ignore*/
  propAfter  : true
}, function(v, k) {
  var o = {};
  /**@ignore*/
  o[k] = function(deferred, object, sigName, args) {
    return signalByJoinPoint(
      deferred, object, sigName,
      Handler.advices[k],
      args
    );
  };
  update(trappers, o);
});

// Private functions.
/**
 * @private
 * @ignore
 */
function createListener(object, sigName, callback,
                        useCapture, isDOM, once, advice) {
  var resultFunc,
      isLoadEvent = (isDOM && RE.EVENT_ONCE.test(sigName)),
      isOnce, onceHandler, fn, ps = Signal, done;
  if (once || isLoadEvent) {
    isOnce = true;
    /**@ignore*/
    onceHandler = function(listener) {
      ps.detach(object, sigName, callback, useCapture);
    };
  }
  if (isAttached(object, sigName, true)) {
    if (advice === Handler.advices.normal) {
      replaceToAttached(object, sigName);
    }
    fn = PotNoop;
    if (isDOM) {
      return fn;
    } else {
      eachHandlers(function(h) {
        if (h && !h.isDOM &&
            h.advice === Handler.advices.normal &&
            h.object === object && h.signal == sigName &&
            h.listener !== PotNoop
        ) {
          if (done) {
            h.listener = PotNoop;
          } else if (!h.attached) {
            fn = h.listener;
            h.listener = PotNoop;
            done = true;
          }
        }
      });
      return fn;
    }
  }
  attachedHandlers[attachedHandlers.length] = {
    object   : object,
    signal   : sigName,
    advice   : advice,
    attached : true
  };
  /**@ignore*/
  resultFunc = function(ev) {
    var d    = newDeferred(),
        args = arguments,
        me   = resultFunc,
        obs  = isDOM ? new Observer(object, ev) : args;
    d.data(errorKey, []);
    trappers.before(d, object, sigName, obs);
    trappers.normal(d, object, sigName, obs);
    trappers.after(d, object, sigName, obs);
    return d.ensure(function(res) {
      var errors;
      if (isError(res)) {
        this.data(errorKey,
          concat.call(this.data(errorKey) || [], res)
        );
      }
      errors = this.data(errorKey);
      if (isOnce) {
        onceHandler(me);
      }
      if (errors && errors.length) {
        if (errors.length > 1) {
          throw update(errors[0], {errors : errors});
        } else {
          throw errors[0];
        }
      }
      return res;
    }).begin();
  };
  return resultFunc;
}

/**
 * @private
 * @ignore
 */
function signalByJoinPoint(deferred, object, signalName, advice, args) {
  var signals = {}, sigNames, attached,
      o = getElement(object);
  if (!o) {
    return;
  }
  sigNames = arrayize(signalName);
  each(sigNames, function(sig) {
    signals[PREFIX + stringify(sig)] = true;
  });
  attached = false;
  switch (advice) {
    case Handler.advices.normal:
        attached = true;
        break;
    case Handler.advices.before:
    case Handler.advices.after:
        each(sigNames, function(sig) {
          if (isAttached(o, stringify(sig))) {
            attached = true;
            throw PotStopIteration;
          }
        });
        break;
    case Handler.advices.propBefore:
    case Handler.advices.propAfter:
        each(sigNames, function(sig) {
          if (isPropAttached(o, stringify(sig))) {
            attached = true;
            throw PotStopIteration;
          }
        });
        break;
    default:
        attached = false;
  }
  if (attached) {
    eachHandlers(function(h) {
      var key = stringify(h && h.signal);
      if (h && h.attached &&
          h.advice === advice &&
          h.object === o &&
          ((PREFIX + key) in signals)
      ) {
        deferred.ensure(function(res) {
          if (isError(res)) {
            this.data(errorKey,
              concat.call(this.data(errorKey) || [], res)
            );
          }
          if (advice === Handler.advices.normal) {
            return h.callback.apply(o, arrayize(args));
          } else {
            return h.listener.apply(o, arrayize(args));
          }
        });
      }
    });
  }
  return deferred;
}

/**
 * @private
 * @ignore
 */
function isAttached(object, sigName, ignoreAttached) {
  var result = false;
  each(arrayize(sigName), function(sig) {
    var i, h, k = stringify(sig);
    for (i = attachedHandlers.length - 1; i >= 0; i--) {
      h = attachedHandlers[i];
      if (h && (ignoreAttached || h.attached) &&
          h.advice === Handler.advices.normal &&
          h.object === object && h.signal == k) {
        result = true;
        throw PotStopIteration;
      }
    }
  });
  return result;
}

/**
 * @private
 * @ignore
 */
function replaceToAttached(object, sigName) {
  var result = false;
  each(arrayize(sigName), function(sig) {
    var i, h, k = stringify(sig);
    for (i = attachedHandlers.length - 1; i >= 0; i--) {
      h = attachedHandlers[i];
      if (h && !h.attached &&
          h.advice === Handler.advices.normal &&
          h.object === object && h.signal == k) {
        h.attached = true;
        throw PotStopIteration;
      }
    }
  });
  return result;
}

/**
 * @private
 * @ignore
 */
function isPropAttached(object, prop, ignoreAttached) {
  var result = false;
  each(arrayize(prop), function(p) {
    var i, h, k = stringify(p);
    for (i = propHandlers.length - 1; i >= 0; i--) {
      h = propHandlers[i];
      if (h && (ignoreAttached || h.attached) &&
          h.object === object && h.signal == k) {
        result = true;
        throw PotStopIteration;
      }
    }
  });
  return result;
}

/**
 * @private
 * @ignore
 */
function replaceToPropAttached(object, prop) {
  var result = false;
  each(arrayize(prop), function(sig) {
    var i, h, k = stringify(sig);
    for (i = propHandlers.length - 1; i >= 0; i--) {
      h = propHandlers[i];
      if (h && !h.attached &&
          (h.advice === Handler.advices.propBefore ||
           h.advice === Handler.advices.propAfter) &&
          h.object === object && h.signal == k) {
        h.attached = true;
        throw PotStopIteration;
      }
    }
  });
  return result;
}

/**
 * @private
 * @ignore
 */
function detachHandler(handler) {
  var object, signal, listener, capture,
      i, h, has, sub;
  if (!handler || !handler.attached) {
    return;
  }
  handler.attached = false;
  object   = handler.object;
  signal   = handler.signal;
  capture  = handler.useCapture;
  listener = handler.listener;
  if (!handler.isDOM) {
    if (handler.advice === Handler.advices.propBefore ||
        handler.advice === Handler.advices.propAfter) {
      has = false;
      eachHandlers(function(h) {
        if (h && h.attached && !h.isDOM &&
            (h.advice === Handler.advices.propBefore ||
             h.advice === Handler.advices.propAfter) &&
             h.object === object && h.signal == signal) {
          has = true;
          throw PotStopIteration;
        }
      });
      if (!has) {
        for (i = propHandlers.length - 1; i >= 0; i--) {
          h = propHandlers[i];
          if (h && h.attached &&
              h.object === object && h.signal == signal) {
            h.attached = false;
          }
        }
      }
    } else if (handler.advice === Handler.advices.normal) {
      has = false;
      sub = null;
      eachHandlers(function(h) {
        if (h && h.attached && !h.isDOM &&
            h.advice === Handler.advices.normal &&
            h.object === object && h.signal == signal) {
          has = true;
          sub = h;
          throw PotStopIteration;
        }
      });
      if (has) {
        if (sub && sub.listener === PotNoop && listener !== PotNoop) {
          sub.listener = listener;
        }
      } else {
        for (i = attachedHandlers.length - 1; i >= 0; i--) {
          h = attachedHandlers[i];
          if (h && h.attached &&
              h.object === object && h.signal == signal) {
            h.attached = false;
          }
        }
      }
    }
  } else {
    if (handler.advice === Handler.advices.normal) {
      has = false;
      eachHandlers(function(h) {
        if (h && h.attached && h.isDOM &&
            h.advice === Handler.advices.normal &&
            h.object === object && h.signal == signal) {
          has = true;
          throw PotStopIteration;
        }
      });
      if (!has) {
        for (i = attachedHandlers.length - 1; i >= 0; i--) {
          h = attachedHandlers[i];
          if (h && h.attached &&
              h.advice === Handler.advices.normal &&
              h.object === object && h.signal == signal) {
            h.attached = false;
          }
        }
      }
    }
  }
  cleanHandlers();
}

/**
 * @private
 * @ignore
 */
function attachByJoinPoint(object, signalName, callback, advice, once) {
  var results = [], o, isDOM, isMulti, bindListener;
  o = getElement(object);
  if (!o) {
    return;
  }
  /**@ignore*/
  bindListener = function(sig) {
    /**@ignore*/
    var func = function() {
      var args = arguments;
      callback.apply(o, args);
      if (once) {
        Signal.detach(o, sig, func, false);
      }
    };
    return func;
  };
  isDOM = isDOMObject(o);
  if (isArray(signalName)) {
    isMulti = true;
  }
  each(arrayize(signalName), function(sig) {
    var sigName = stringify(sig), handler, listener;
    listener = bindListener(sigName);
    handler = new Handler({
      object     : o,
      signal     : sigName,
      listener   : listener,
      callback   : listener,
      isDOM      : isDOM,
      useCapture : false,
      advice     : advice,
      attached   : true
    });
    withHandlers(function(hs) {
      hs[hs.length] = handler;
    });
    results[results.length] = handler;
  });
  return isMulti ? results : results[0];
}

/**
 * @private
 * @ignore
 */
function attachPropByJoinPoint(object, propName, callback, advice, once) {
  var results = [], isMulti, props,
      bindListener, ps = Signal;
  if (!object || !isFunction(callback)) {
    return;
  }
  if (isArray(propName)) {
    isMulti = true;
  }
  /**@ignore*/
  bindListener = function(sigName) {
    /**@ignore*/
    var func = function() {
      var args = arguments;
      callback.apply(object, args);
      if (once) {
        ps.detach(object, sigName, func, false);
      }
    };
    return func;
  };
  props = arrayize(propName);
  each(props, function(p) {
    var key = stringify(p);
    if (isPropAttached(object, key, true)) {
      if (advice === Handler.advices.propBefore ||
          advice === Handler.advices.propAfter) {
        replaceToPropAttached(object, key);
      }
    } else {
      propHandlers[propHandlers.length] = {
        object   : object,
        signal   : key,
        advice   : advice,
        attached : true
      };
      Pot.override(object, key, function(inherits, args) {
        var uniq = {},
            d = newDeferred(),
            orgResult = uniq;
        d.data(errorKey, []);
        trappers.propBefore(d, object, key, args);
        d.ensure(function(res) {
          if (isError(res)) {
            this.data(errorKey,
              concat.call(this.data(errorKey) || [], res)
            );
          }
          return inherits.apply(object, args);
        }).then(function(res) {
          orgResult = res;
          return res;
        });
        trappers.normal(d, object, key, args);
        trappers.propAfter(d, object, key, args);
        d.ensure(function(res) {
          var errors;
          if (isError(res)) {
            this.data(errorKey,
              concat.call(this.data(errorKey) || [], res)
            );
          }
          errors = this.data(errorKey);
          if (errors && errors.length) {
            if (errors.length > 1) {
              throw update(errors[0], {errors : errors});
            } else {
              throw errors[0];
            }
          }
          return res;
        }).begin();
        return (orgResult === uniq) ? null : orgResult;
      });
    }
  });
  each(props, function(p) {
    var name = stringify(p), handler, listener;
    listener = bindListener(name);
    handler = new Handler({
      object     : object,
      signal     : name,
      listener   : listener,
      callback   : listener,
      isDOM      : false,
      useCapture : false,
      advice     : advice,
      attached   : true
    });
    withHandlers(function(hs) {
      hs[hs.length] = handler;
    });
    results[results.length] = handler;
  });
  return isMulti ? results : results[0];
}

/**
 * @private
 * @ignore
 */
function adaptSignalForDOM(object, signal) {
  var s = stringify(signal), prefix = 'on';
  if (object) {
    if (object.addEventListener) {
      if (s.indexOf(prefix) === 0) {
        s = s.substring(2);
      }
    } else if (object.attachEvent) {
      if (s.indexOf(prefix) !== 0) {
        s = prefix + s;
      }
    }
  }
  return s;
}

/**
 * @private
 * @ignore
 */
function isDOMObject(o) {
  return !!(o &&
            (o.addEventListener && o.removeEventListener) ||
            (o.attachEvent && o.detachEvent));
}

/**
 * @private
 * @ignore
 */
function getElement(expr) {
  if (typeof expr === 'object' || isFunction(expr)) {
    if (expr.jquery && expr.get) {
      return expr.get(0);
    } else {
      return expr;
    }
  }
  if (isString(expr)) {
    try {
      return Pot.currentDocument().getElementById(
        stringify(expr).replace(RE.ID_CLEAN, '')
      );
    } catch (e) {}
  }
  return false;
}

/**
 * @private
 * @ignore
 */
function eachHandlers(callback) {
  var result, err = null, i, len;
  handlersLocked = true;
  try {
    len = handlers.length;
    for (i = 0; i < len; i++) {
      result = callback(handlers[i], i);
    }
  } catch (e) {
    err = e;
  } finally {
    handlersLocked = false;
  }
  if (err !== null && !isStopIter(err)) {
    throw err;
  }
  return result;
}

/**
 * @private
 * @ignore
 */
function withHandlers(callback) {
  var result,
      limit = 255,
      retry = {},
      end   = false;
  /**@ignore*/
  (function restback() {
    try {
      if (handlersLocked) {
        if (--limit >= 0) {
          throw retry;
        } else {
          limit = -1;
          PotInternalSetTimeout(function() {
            restback();
          }, 0);
        }
      } else {
        if (!end) {
          end = true;
          result = callback(handlers);
        }
      }
    } catch (e) {
      if (e === retry) {
        return restback();
      } else {
        throw e;
      }
    }
  })();
  return result;
}

/**
 * @private
 * @ignore
 */
function cleanHandlers() {
  var i, len, h, t = [], err;
  if (!handlersLocked) {
    handlersLocked = true;
    try {
      len = handlers.length;
      for (i = 0; i < len; i++) {
        h = handlers[i];
        if (!h ||
            (!h.attached &&
              (
                (h.advice === Handler.advices.normal &&
                 h.listener === PotNoop
                ) ||
                (h.advice === Handler.advices.propBefore ||
                 h.advice === Handler.advices.propAfter
                ) ||
                (h.advice === Handler.advices.before ||
                 h.advice === Handler.advices.after
                )
              )
            )
        ) {
          continue;
        }
        t[t.length] = h;
      }
      handlers.splice(0, len);
      push.apply(handlers, t);
    } catch (e) {
      err = e;
    } finally {
      handlersLocked = false;
    }
    if (err != null) {
      throw err;
    }
  }
}

/**
 * @private
 * @ignore
 */
function newDeferred() {
  return new Deferred({async : false});
}

// Update Pot object.
Pot.update({
  attach           : Pot.Signal.attach,
  attachBefore     : Pot.Signal.attachBefore,
  attachAfter      : Pot.Signal.attachAfter,
  attachPropBefore : Pot.Signal.attachPropBefore,
  attachPropAfter  : Pot.Signal.attachPropAfter,
  detach           : Pot.Signal.detach,
  detachAll        : Pot.Signal.detachAll,
  signal           : Pot.Signal.signal,
  cancelEvent      : Pot.Signal.cancelEvent,
  DropFile         : Pot.Signal.DropFile
});

}());

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Hash.
(function() {
var PREFIX = '.', createHashIterator;

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Hash.
   *
   * Hash can contain any key names.
   *  e.g. "__iterator__" and "hasOwnProperty" etc. will crush object.
   * The implementation to resolve them.
   *
   *
   * @example
   *   var hash = new Pot.Hash();
   *   hash.set('key1', 'value1');
   *   hash.set('key2', [1, 2, 3]);
   *   debug(hash.toJSON());
   *   // @results {"key1":"value1","key2":[1,2,3]}
   *   //
   *   hash.clear();
   *   // If you use the following keys to builtin Object,
   *   //  object will no longer work usually.
   *   hash.set('__iterator__',   'iterator');
   *   hash.set('hasOwnProperty', 'hasOwn');
   *   hash.set('prototype',      'proto');
   *   hash.set('constructor',    'construct');
   *   debug(hash.toJSON());
   *   // @results
   *   //   {
   *   //     "__iterator__": "iterator",
   *   //     "hasOwnProperty": "hasOwn",
   *   //     "prototype": "proto",
   *   //     "constructor": "construct"
   *   //   }
   *   //
   *   var result = hash.map(function(value, key, object) {
   *     return '[' + value + ']';
   *   }).reduce(function(a, b) {
   *     return a + b;
   *   });
   *   debug(result);
   *   // @results  result = '[iterator][hasOwn][proto][construct]'
   *
   *
   * @param  {Object|*}  (...)  (Optional) Items.
   * @return {Pot.Hash}         Returns an instance of Pot.Hash.
   *
   * @name  Pot.Hash
   * @type  Function
   * @class
   * @constructor
   * @public
   */
  Hash : function() {
    return isHash(this) ? this.init(arguments)
                        : new Hash.fn.init(arguments);
  }
});

// Definition of the creator method for iterators and iteration speeds.
update(PotTmp, {
  /**
   * @ignore
   */
  createHashIterator : function(creator) {
    var
    /**@ignore*/
    create = function(speed) {
      var key = speed;
      if (!key) {
        each(PotInternalLightIterator.speeds, function(v, k) {
          if (v === PotInternalLightIterator.defaults.speed) {
            key = k;
            throw PotStopIteration;
          }
        });
      }
      return creator(key);
    },
    methods = {},
    construct = create();
    each(PotInternalLightIterator.speeds, function(v, k) {
      methods[k] = create(k);
    });
    return update(construct, methods);
  }
});

// Refer the Pot properties/functions.
Hash = Pot.Hash;
createHashIterator = PotTmp.createHashIterator;

// Define the prototype of Pot.Hash
Hash.fn = Hash.prototype = update(Hash.prototype, {
  /**
   * @lends Pot.Hash.prototype
   */
  /**
   * @ignore
   */
  constructor : Hash,
  /**
   * @const
   * @private
   * @ignore
   */
  id : PotInternal.getMagicNumber(),
  /**
   * @const
   * @private
   */
  serial : null,
  /**
   * StopIteration.
   *
   * @type Object
   * @const
   * @public
   */
  StopIteration : PotStopIteration,
  /**
   * @private
   * @ignore
   */
  _rawData : {},
  /**
   * Length of Hash data.
   *
   * @type  Number
   * @readonly
   * @public
   */
  length : 0,
  /**
   * @private
   * @readonly
   * @const
   * @ignore
   */
  NAME : 'Hash',
  /**
   * toString.
   *
   * @return  Return formatted string of object.
   * @type Function
   * @function
   * @static
   * @public
   */
  toString : PotToString,
  /**
   * isHash.
   *
   * @type Function
   * @function
   * @static
   * @public
   */
  isHash : isHash,
  /**
   * Initialization.
   *
   * @private
   * @ignore
   */
  init : function(argument) {
    var that = this, args, len;
    if (!this.serial) {
      this.serial = buildSerial(this);
    }
    this._rawData = {};
    this.length   = 0;
    args = arrayize(argument);
    len = args.length;
    if (len === 2 && !isObject(args[0])) {
      this.set(args[0], args[1]);
    } else if (len) {
      each(args, function(arg) {
        that.set(arg);
      });
    }
    PotInternal.referSpeeds.call(this, PotInternalLightIterator.speeds);
    return this;
  },
  /**
   * Get the item by the specified key name.
   *
   * @param  {String}  key  The key name.
   * @return {*}            A value that related to the key name.
   * @function
   * @public
   */
  get : function(key) {
    return this._rawData[PREFIX + key];
  },
  /**
   * Set the item that is specified key name and value.
   *
   * @param  {String}   key    The key name.
   * @param  {*}        value  The value.
   * @return {Pot.Hash}        Return the Hash.
   * @function
   * @public
   */
  set : function(key, value) {
    var that = this;
    if (isHash(key)) {
      key.forEach(function(v, k) {
        that.set(k, v);
      });
    } else if (key && isObject(key)) {
      each(key, function(v, k) {
        that.set(k, v);
      });
    } else {
      if (!this.has(key)) {
        this.length++;
      }
      this._rawData[PREFIX + key] = value;
    }
    return this;
  },
  /**
   * Check whether a key exists.
   *
   * @param  {String}  key  The key name to check.
   * @return {Boolean}      Return true if exists.
   * @function
   * @public
   */
  has : function(key) {
    return ((PREFIX + key) in this._rawData);
  },
  /**
   * Check whether a value exists.
   *
   * @param  {*}       value  The value to check.
   * @return {Boolean}        Return true if exists.
   * @function
   * @public
   */
  hasValue : function(value) {
    var result = false;
    each(this._rawData, function(v, k) {
      if (k && k.charAt(0) === PREFIX && v === value) {
        result = true;
        throw PotStopIteration;
      }
    });
    return result;
  },
  /**
   * Remove an item by specified key name.
   *
   * @param  {String}   key  The key name.
   * @return {Pot.Hash}      Return the Hash.
   * @function
   * @public
   */
  remove : function(key) {
    if (this.has(key)) {
      delete this._rawData[(PREFIX + key)];
      this.length--;
    }
    return this;
  },
  /**
   * Clear the data.
   * All items will remove.
   *
   * @return {Pot.Hash}  Return the Hash.
   * @function
   * @public
   */
  clear : function() {
    this._rawData = {};
    this.length   = 0;
    return this;
  },
  /**
   * Collect all key names as an array.
   *
   * @return  {Array}   Return all key names as an array.
   * @function
   * @public
   */
  keys : function() {
    var keys = [];
    each(this._rawData, function(v, k) {
      if (k && k.charAt(0) === PREFIX) {
        keys[keys.length] = k.substring(1);
      }
    });
    return keys;
  },
  /**
   * Collect all values as an array.
   *
   * @return  {Array}   Return all values as an array.
   * @function
   * @public
   */
  values : function() {
    var values = [];
    each(this._rawData, function(v, k) {
      if (k && k.charAt(0) === PREFIX) {
        values[values.length] = v;
      }
    });
    return values;
  },
  /**
   * Convert all items to JSON format.
   *
   *
   * @example
   *   var hash = new Pot.Hash({foo: [1], bar: [2], baz: [3]});
   *   hash.set({a: 4, b: 5, c: [6, 7, '"hoge"']});
   *   var json = hash.toJSON();
   *   debug(json);
   *   // @results
   *   //   '{"foo":[1],"bar":[2],"baz":[3],"a":4,"b":5,"c":[6,7,"\"hoge\""]}'
   *
   *
   * @return {String} Return a JSON string object that has all items.
   * @function
   * @public
   */
  toJSON : function() {
    var results = [], key, json = Pot.Serializer.serializeToJSON;
    each(this._rawData, function(v, k) {
      if (k && k.charAt(0) === PREFIX) {
        key = k.substring(1);
        try {
          results[results.length] = json(key) + ':' + json(v);
        } catch (e) {}
      }
    });
    return '{' + results.join(',') + '}';
  },
  /**
   * Convert all items to plain object.
   *
   * Notice:
   *  if special keys existed (e.g. hasOwnProperty or __iterator__ etc.)
   *    then object will be broken.
   *
   * @return {Object} Return an object that has all items.
   * @function
   * @public
   */
  toObject : function() {
    var o = {}, key;
    each(this._rawData, function(v, k) {
      if (k && k.charAt(0) === PREFIX) {
        key = k.substring(1);
        try {
          o[key] = v;
        } catch (e) {}
      }
    });
    return o;
  },
  /**
   * Convert all elements to the items() format array.
   *
   *
   * @example
   *   var hash = new Pot.Hash();
   *   hash.set('prototype',      'value1');
   *   hash.set('__iterator__',   'value2');
   *   hash.set('hasOwnProperty', 'value3');
   *   var result = hash.toItems();
   *   debug(result);
   *   // @results
   *   //   [
   *   //     ['prototype',      'value1'],
   *   //     ['__iterator__',   'value2'],
   *   //     ['hasOwnProperty', 'value3']
   *   //   ]
   *
   *
   * @see Pot.Struct.items
   *
   * @return {Array} Return the items() format array.
   * @function
   * @public
   */
  toItems : function() {
    var items = [], key;
    each(this._rawData, function(v, k) {
      if (k && k.charAt(0) === PREFIX) {
        key = k.substring(1);
        items[items.length] = [key, v];
      }
    });
    return items;
  },
  /**
   * Iterate each items with calls callback function.
   *
   *
   * @example
   *   var hash = new Pot.Hash();
   *   hash.set('key1', 'value1');
   *   hash.set('key2', 'value2');
   *   hash.set('key3', 'value3');
   *   var s = '';
   *   hash.forEach(function(value, key, object) {
   *     s += key + ':' + value + ';';
   *   });
   *   debug(s);
   *   // @results  s = 'key1:value1;key2:value2;key3:value3;'
   *
   *
   * @param  {Function}  callback   An iterable function.
   *                                  function(value, key, object)
   *                                    this == `context`.
   *                                Throw Pot.StopIteration
   *                                  if you want to stop the loop.
   * @param  {*}         (context)  Optionally, context object. (i.e. this)
   * @return {Pot.Hash}             Return the Hash.
   *
   * @name  Pot.Hash.forEach
   * @class
   * @function
   * @public
   *
   * @property {Function} limp   Iterates "forEach" loop with slowest speed.
   * @property {Function} doze   Iterates "forEach" loop with slower speed.
   * @property {Function} slow   Iterates "forEach" loop with slow speed.
   * @property {Function} normal Iterates "forEach" loop with default speed.
   * @property {Function} fast   Iterates "forEach" loop with fast speed.
   * @property {Function} rapid  Iterates "forEach" loop with faster speed.
   * @property {Function} ninja  Iterates "forEach" loop with fastest speed.
   */
  forEach : createHashIterator(function(speedKey) {
    /**@ignore*/
    var func = function(callback, context) {
      var that = func.instance || this;
      Pot.forEach[speedKey](that._rawData, function(val, k, object) {
        var key, result;
        if (k && k.charAt(0) === PREFIX) {
          key = k.substring(1);
          result = callback.call(context, val, key, object);
        }
      });
      return that;
    };
    return func;
  }),
  /**
   * Creates a new object with the results of calling a
   *   provided function on every element in object.
   *
   * This method like Array.prototype.map
   *
   *
   * @example
   *   var hash = new Pot.Hash();
   *   hash.set({a: 1, b: 2, c: 3, d: 4, e: 5});
   *   var result = hash.map(function(value, key) {
   *     return value * 100;
   *   });
   *   debug(result.toObject());
   *   // @results {a: 100, b: 200, c: 300, d: 400, e: 500}
   *
   *
   * @param  {Function}  callback    A callback function.
   * @param  {*}         (context)   (Optional) Object to use
   *                                   as `this` when executing callback.
   * @return {Pot.Hash}              Return a new instance of Hash that
   *                                   has result of each callbacks.
   *
   * @name  Pot.Hash.map
   * @class
   * @function
   * @public
   *
   * @property {Function} limp   Iterates "map" loop with slowest speed.
   * @property {Function} doze   Iterates "map" loop with slower speed.
   * @property {Function} slow   Iterates "map" loop with slow speed.
   * @property {Function} normal Iterates "map" loop with default speed.
   * @property {Function} fast   Iterates "map" loop with fast speed.
   * @property {Function} rapid  Iterates "map" loop with faster speed.
   * @property {Function} ninja  Iterates "map" loop with fastest speed.
   */
  map : createHashIterator(function(speedKey) {
    /**@ignore*/
    var func = function(callback, context) {
      var that = func.instance || this,
          hash = new Hash();
      Pot.forEach[speedKey](that._rawData, function(val, k, object) {
        var key, result;
        if (k && k.charAt(0) === PREFIX) {
          key = k.substring(1);
          result = callback.call(context, val, key, object);
          hash.set(key, result);
        }
      });
      return hash;
    };
    return func;
  }),
  /**
   * Creates a new object with all elements that
   *  pass the test implemented by the provided function.
   *
   * This method like Array.prototype.filter
   *
   *
   * @example
   *   var hash = new Pot.Hash({a: 1, b: 2, c: 3, d: 4, e: 5});
   *   var result = hash.filter(function(value, key, obj) {
   *     return value % 2 == 0;
   *   });
   *   debug(result.toObject());
   *   // @results {b: 2, d: 4}
   *
   *
   * @param  {Function}    callback    A callback function.
   * @param  {*}           (context)   (Optional) Object to use
   *                                     as `this` when executing callback.
   * @return {Pot.Hash}                Return a new Hash instance that
   *                                     has result of each callbacks.
   * @name  Pot.Hash.filter
   * @class
   * @function
   * @public
   *
   * @property {Function} limp   Iterates "filter" loop with slowest speed.
   * @property {Function} doze   Iterates "filter" loop with slower speed.
   * @property {Function} slow   Iterates "filter" loop with slow speed.
   * @property {Function} normal Iterates "filter" loop with default speed.
   * @property {Function} fast   Iterates "filter" loop with fast speed.
   * @property {Function} rapid  Iterates "filter" loop with faster speed.
   * @property {Function} ninja  Iterates "filter" loop with fastest speed.
   */
  filter : createHashIterator(function(speedKey) {
    /**@ignore*/
    var func = function(callback, context) {
      var that = func.instance || this,
          hash = new Hash();
      Pot.forEach[speedKey](that._rawData, function(val, k, object) {
        var key;
        if (k && k.charAt(0) === PREFIX) {
          key = k.substring(1);
          if (callback.call(context, val, key, object)) {
            hash.set(key, val);
          }
        }
      });
      return hash;
    };
    return func;
  }),
  /**
   * Apply a function against an accumulator and each value of
   *  the object (from left-to-right) as to reduce it to a single value.
   *
   * This method like Array.prototype.reduce
   *
   *
   * @example
   *   var object = {a: 1, b: 2, c: 3};
   *   var hash = new Pot.Hash(object);
   *   var total = hash.reduce(function(a, b) { return a + b; });
   *   debug(total);
   *   // @results 6
   *
   *
   * @param  {Function}       callback  A callback function.
   * @param  {*}              initial   An initial value passed as `callback`
   *                                      argument that will be used on
   *                                      first iteration.
   * @param  {*}             (context)  (Optional) Object to use as
   *                                      the first argument to the
   *                                      first call of the `callback`.
   * @return {*}                        Return the result of each callbacks.
   * @name  Pot.Hash.reduce
   * @class
   * @function
   * @public
   *
   * @property {Function} limp   Iterates "reduce" loop with slowest speed.
   * @property {Function} doze   Iterates "reduce" loop with slower speed.
   * @property {Function} slow   Iterates "reduce" loop with slow speed.
   * @property {Function} normal Iterates "reduce" loop with default speed.
   * @property {Function} fast   Iterates "reduce" loop with fast speed.
   * @property {Function} rapid  Iterates "reduce" loop with faster speed.
   * @property {Function} ninja  Iterates "reduce" loop with fastest speed.
   */
  reduce : createHashIterator(function(speedKey) {
    /**@ignore*/
    var func = function(callback, initial, context) {
      var that = func.instance || this,
          value, skip, p, raw = that._rawData;
      if (initial == null) {
        for (p in raw) {
          if (p && p.charAt(0) === PREFIX) {
            try {
              value = raw[p];
              break;
            } catch (e) {}
          }
        }
      } else {
        value = initial;
      }
      skip = true;
      Pot.forEach[speedKey](raw, function(val, k, object) {
        var key;
        if (skip) {
          skip = false;
        } else {
          if (k && k.charAt(0) === PREFIX) {
            key = k.substring(1);
            value = callback.call(context, value, val, key, object);
          }
        }
      });
      return value;
    };
    return func;
  }),
  /**
   * Tests whether all elements in the object pass the
   *  test implemented by the provided function.
   *
   * This method like Array.prototype.every
   *
   * @example
   *   var hash = new Pot.Hash();
   *   hash.set({A: 12, B: 5, C: 8, D: 130, E: 44});
   *   var result = hash.every(function(value, key, object) {
   *     return (value >= 10);
   *   });
   *   debug('[1] result = ' + result); // @results false
   *   hash.clear();
   *   hash.set({A: 12, B: 54, C: 18, D: 130, E: 44});
   *   result = hash.every(function(value, key, object) {
   *     return (value >= 10);
   *   });
   *   debug('[2] result = ' + result); // @results true
   *
   *
   * @param  {Function}  callback   A callback function.
   * @param  {*}         (context)  (Optional) Object to use
   *                                  as `this` when executing callback.
   * @return {Boolean}              Return the Boolean result by callback.
   *
   * @name  Pot.Hash.every
   * @class
   * @function
   * @public
   *
   * @property {Function} limp   Iterates "every" loop with slowest speed.
   * @property {Function} doze   Iterates "every" loop with slower speed.
   * @property {Function} slow   Iterates "every" loop with slow speed.
   * @property {Function} normal Iterates "every" loop with default speed.
   * @property {Function} fast   Iterates "every" loop with fast speed.
   * @property {Function} rapid  Iterates "every" loop with faster speed.
   * @property {Function} ninja  Iterates "every" loop with fastest speed.
   */
  every : createHashIterator(function(speedKey) {
    /**@ignore*/
    var func = function(callback, context) {
      var that = func.instance || this, result = true;
      Pot.forEach[speedKey](that._rawData, function(val, k, object) {
        var key;
        if (k && k.charAt(0) === PREFIX) {
          key = k.substring(1);
          if (!callback.call(context, val, key, object)) {
            result = false;
            throw PotStopIteration;
          }
        }
      });
      return result;
    };
    return func;
  }),
  /**
   * Tests whether some element in the object passes the
   *  test implemented by the provided function.
   *
   * This method like Array.prototype.some
   *
   *
   * @example
   *   var hash = new Pot.Hash();
   *   hash.set({A: 2, B: 5, C: 8, D: 1, E: 4});
   *   var result = hash.some(function(value, key, object) {
   *     return (value >= 10);
   *   });
   *   debug('[1] result = ' + result); // @results false
   *   hash.clear();
   *   hash.set({A: 12, B: 5, C: 8, D: 1, E: 4});
   *   result = hash.some(function(value, key, object) {
   *     return (value >= 10);
   *   });
   *   debug('[2] result = ' + result); // @results true
   *
   *
   * @param  {Function}    callback   A callback function.
   * @param  {*}           (context)  (Optional) Object to use
   *                                    as `this` when executing callback.
   * @return {Boolean}                Return the Boolean result by callback.
   *
   * @name  Pot.Hash.some
   * @class
   * @function
   * @public
   *
   * @property {Function} limp   Iterates "some" loop with slowest speed.
   * @property {Function} doze   Iterates "some" loop with slower speed.
   * @property {Function} slow   Iterates "some" loop with slow speed.
   * @property {Function} normal Iterates "some" loop with default speed.
   * @property {Function} fast   Iterates "some" loop with fast speed.
   * @property {Function} rapid  Iterates "some" loop with faster speed.
   * @property {Function} ninja  Iterates "some" loop with fastest speed.
   */
  some : createHashIterator(function(speedKey) {
    var func = function(callback, context) {
      var that = func.instance || this, result = false;
      Pot.forEach[speedKey](that._rawData, function(val, k, object) {
        var key;
        if (k && k.charAt(0) === PREFIX) {
          key = k.substring(1);
          if (callback.call(context, val, key, object)) {
            result = true;
            throw PotStopIteration;
          }
        }
      });
      return result;
    };
    return func;
  })
});

delete PotTmp.createHashIterator;
Hash.fn.init.prototype = Hash.fn;
}());

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Collection.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Collection.
   * Array utilities.
   *
   * Treated as an array of arguments given then
   *  return it as an array.
   *
   * @see Pot.Collection.arrayize
   *
   * @param  {*}       object   A target object.
   * @param  {Number}  (index)  Optional, The first index to
   *                              slice the array.
   * @return {Array}            Return an array of result.
   *
   * @name Pot.Collection
   * @type Function
   * @function
   * @class
   * @static
   * @public
   */
  Collection : function(/*object[, index]*/) {
    return arrayize.apply(null, arguments);
  }
});

update(Pot.Collection, {
  /**
   * @lends Pot.Collection
   */
  /**
   * Treated as an array of arguments given then
   *  return it as an array.
   *
   *
   * @example
   *   debug(arrayize(null));               // [null]
   *   debug(arrayize((void 0)));           // [undefined]
   *   debug(arrayize(true));               // [true]
   *   debug(arrayize(false));              // [false]
   *   debug(arrayize(new Boolean(true)));  // [Boolean(false)]
   *   debug(arrayize(Boolean));            // [Boolean]
   *   debug(arrayize(''));                 // ['']
   *   debug(arrayize('hoge'));             // ['hoge']
   *   debug(arrayize(new String('hoge'))); // [String {'hoge'}]
   *   debug(arrayize(String));             // [String]
   *   debug(arrayize(100));                // [100]
   *   debug(arrayize(-100));               // [-100]
   *   debug(arrayize(NaN));                // [NaN]
   *   debug(arrayize(12410.505932095032)); // [12410.505932095032]
   *   debug(arrayize(new Number(100)));    // [Number {100}]
   *   debug(arrayize(Number));             // [Number]
   *   debug(arrayize(Error('error')));     // [Error {'error'}]
   *   debug(arrayize(new Error('error'))); // [Error {'error'}]
   *   debug(arrayize(Error));              // [Error]
   *   debug(arrayize(/(foo|bar)/i));       // [/(foo|bar)/i]
   *   debug(arrayize(new RegExp('hoge'))); // [/hoge/]
   *   debug(arrayize(new RegExp()));       // [/(?:)/]
   *   debug(arrayize(RegExp));             // [RegExp]
   *   debug(arrayize(TypeError));          // [TypeError]
   *   debug(arrayize(encodeURI));          // [encodeURI]
   *   debug(arrayize(window));             // [window]
   *   debug(arrayize(document));           // [document]
   *   debug(arrayize(document.body));      // [body]
   *   debug(arrayize([]));                 // []
   *   debug(arrayize(new Array(1, 2, 3))); // [1, 2, 3]
   *   debug(arrayize([1, 2, 3]));          // [1, 2, 3]
   *   debug(arrayize(Array));              // [Array]
   *   debug(arrayize(Array.prototype));    // [Array.prototype]
   *   debug(arrayize([[]]));               // [[]]
   *   debug(arrayize([[100]]));            // [[100]]
   *   debug(arrayize({}));                 // [{}]
   *   debug(arrayize({foo: 'bar'}));       // [{foo: 'bar'}]
   *   debug(arrayize(new Object()));       // [Object {}]
   *   debug(arrayize(new Object('foo')));  // [Object {'foo'}]
   *   debug(arrayize(Object));             // [Object]
   *   debug(arrayize(document.getElementsByTagName('div')));
   *   // @results  [<div/>, <div/>, <div/> ...]
   *   (function(a, b, c) {
   *     debug(arrayize(arguments));
   *     // @results  [1, 2, 3]
   *   })(1, 2, 3);
   *   (function(a, b, c) {
   *     debug(arrayize(arguments, 2));
   *     // @results  [3]
   *   })(1, 2, 3);
   *
   *
   * @param  {*}       object   A target object.
   * @param  {Number}  (index)  Optional, The first index to
   *                              slice the array.
   * @return {Array}            Return an array of result.
   * @type Function
   * @function
   * @public
   * @static
   */
  arrayize : arrayize,
  /**
   * Merge some arrays or objects to base object.
   * The type of first argument will be to base type.
   *
   *
   * @example
   *   var array1 = [1, 2, 3];
   *   var array2 = [4, 5, 6];
   *   var result = merge(array1, array2);
   *   debug(result);
   *   // @results  [1, 2, 3, 4, 5, 6]
   *   var result = merge([], 1, 2, 'foo', {bar: 3});
   *   debug(result);
   *   // @results  [1, 2, 'foo', {bar: 3}]
   *
   *
   * @example
   *   var obj1 = {foo: 1, bar: 2};
   *   var obj2 = {baz: 3};
   *   var result = merge(obj1, obj2);
   *   debug(result);
   *   // @results  {foo: 1, bar: 2, baz: 3}
   *   var result = merge({}, {foo: 1}, {bar: 2});
   *   debug(result);
   *   // @results  {foo: 1, bar: 2}
   *
   *
   * @example
   *   var s1 = 'foo';
   *   var s2 = 'bar';
   *   var result = merge(s1, s2);
   *   debug(result);
   *   // @results  'foobar'
   *
   *
   * @param  {Array|*}  (...)  Array(s) to merge.
   * @return {Array|*}         Result of merged.
   * @type  Function
   * @function
   * @static
   * @public
   */
  merge : function(/*[...args]*/) {
    var result = null, args = arrayize(arguments), arg = args[0];
    switch (args.length) {
      case 0:
          break;
      case 1:
          result = arrayize(arg);
          break;
      default:
          if (isArrayLike(arg)) {
            result = concat.apply([], args);
          } else if (isObject(arg)) {
            args.unshift({});
            result = update.apply(null, args);
          } else if (isString(arg)) {
            result = ArrayProto.join.call(args, '');
          } else {
            result = args;
          }
    }
    return result;
  },
  /**
   * Returns an array with the given unique array.
   * Keep order without sorting.
   *
   *
   * @example
   *   debug(unique(
   *               [1, 2, 3, 4, 5, 3, 5, 'a', 3, 'b', 'a', 'c', 2, 5]
   *   ));
   *   // @results [1, 2, 3, 4, 5, 'a', 'b', 'c']
   *
   * @example
   *   debug(unique(
   *               [5, 7, 8, 3, 6, 1, 7, 2, 3, 8, 4, 2, 9, 5]
   *   ));
   *   // @results [5, 7, 8, 3, 6, 1, 2, 4, 9]
   *
   * @example
   *   debug(unique(
   *               ['1', 1, '2', 2, 0, '0', '', null, false, (void 0)],
   *               true
   *   ));
   *   // @results ['1', '2', 0, null]
   *
   * @example
   *   debug(unique(
   *               ['abc', 'ABC', 'Foo', 'bar', 'foO', 'BaR'],
   *               false, true
   *   ));
   *   // @results ['abc', 'Foo', 'bar']
   *
   *
   * @example
   *   debug(unique(
   *               {a: 1, b: 2, c: 3, d: 1, e: 3, f: 2}
   *   ));
   *   // @results {a: 1, b: 2, c: 3}
   *
   * @example
   *   debug(unique(
   *               {foo: 1, bar: 2, FOo: 3, Bar: '1', baZ: '2'},
   *               true, true
   *   ));
   *   // @results {foo: 1, bar: 2, FOo: 3}
   *
   * @example
   *   debug(unique(
   *               {a: 1, b: 2, c: 3, d: '1', e: '3', f: 5},
   *               true
   *   ));
   *   // @results {a: 1, b: 2, c: 3, f: 5}
   *
   *
   * @example
   *   debug(unique('abcABCabc-----foobarBaZ'));
   *   // @results  'abcABC-forZ'
   *   debug(unique('abcABCabc-----foobarBaZ', true, true));
   *   // @results  'abc-forZ'
   *
   *
   * @example
   *   debug(unique(
   *                [1, 1, [123], (function(a) { return a;}),
   *                 [123], {a: 5}, (function(a) { return a; }), {a: 5}]
   *   ));
   *   // @results  [1, [123], (function() { return a; }), {a: 5}]
   *
   *
   * @param  {Array|Object|String|*}  object   Target object.
   *                                             (no change in this object).
   * @param  {Boolean}                (loose)  If passed TRUE then
   *                                             will be compared by
   *                                             loose operator (==),
   *                                             the default is
   *                                             strict comparison (===).
   * @param  {Boolean}           (ignoreCase)  If passed TRUE then will be
   *                                             ignored case sensitive.
   * @return {Array|Object|String|*}           Array with unique values.
   * @type  Function
   * @function
   * @static
   * @public
   */
  unique : (function() {
    var
    iCase, useStrict,
    /**@ignore*/
    cmpCase = function (c1, c2) {
      var value1, value2;
      if (iCase &&
          c1 != null && c1.toLowerCase &&
          c2 != null && c2.toLowerCase) {
        value1 = c1.toLowerCase();
        value2 = c2.toLowerCase();
      } else {
        value1 = c1;
        value2 = c2;
      }
      return useStrict && value1 === value2 || value1 == value2;
    },
    /**@ignore*/
    cmp = function(a, b) {
      var v1, v2;
      if (iCase) {
        v1 = stringify(a).toLowerCase();
        v2 = stringify(b).toLowerCase();
      } else {
        v1 = a;
        v2 = b;
      }
      if (useStrict && v1 === v2 || v1 == v2) {
        return true;
      } else if (Pot.Struct && Pot.Struct.equals) {
        return Pot.Struct.equals(a, b, cmpCase);
      } else {
        return false;
      }
    };
    return function(object, loose, ignoreCase) {
      var results = [], args = arguments,
          me = Pot.Collection.unique, i, j, len,
          array, dups = [];
      args = arrayize(args);
      useStrict = !loose;
      iCase = !!ignoreCase;
      if (object) {
        if (isArray(object)) {
          len = object.length;
          if (len) {
            for (i = 0; i < len; i++) {
              for (j = i + 1; j < len; j++) {
                try {
                  if (cmp(object[i], object[j])) {
                    dups[j] = i;
                  }
                } catch (e) {}
              }
              if (!(i in dups)) {
                try {
                  results[results.length] = object[i];
                } catch (e) {}
              }
            }
          }
        } else if (isObject(object)) {
          results = {};
          array = [];
          each(object, function(val, key) {
            array[array.length] = [key, val];
          });
          len = array.length;
          for (i = 0; i < len; i++) {
            for (j = i + 1; j < len; j++) {
              try {
                if (cmp(array[i][1], array[j][1])) {
                  dups[j] = i;
                }
              } catch (e) {}
            }
            if (!(i in dups)) {
              try {
                results[array[i][0]] = array[i][1];
              } catch (e) {}
            }
          }
        } else if (isString(object)) {
          args[0] = object.split('');
          results = me.apply(null, args).join('');
        } else {
          results = object;
        }
      }
      return results;
    };
  }()),
  /**
   * @lends Pot.Collection
   */
  /**
   * Convert to one-dimensional array from multi-dimensional array.
   *
   *
   * @example
   *   debug(flatten(
   *               [1,2,3,[4,5,6,[7,8,[9],10],11],12]
   *   ));
   *   // @results [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
   *
   *
   * @param  {Array}   array   A target array.
   * @return {Array}           An array which has only one dimension.
   * @type  Function
   * @function
   * @static
   * @public
   */
  flatten : function flatten(array) {
    var results = [], i, len, item, items;
    if (!isArray(array)) {
      results[results.length] = array;
    } else {
      items = arrayize(array);
      len = items.length;
      for (i = 0; i < len; i++) {
        item = items[i];
        if (isArray(item)) {
          push.apply(results, flatten(item));
        } else {
          results[results.length] = item;
        }
      }
    }
    return results;
  },
  /**
   * Sorting with humaneness. (natural sort)
   *
   * Based: alphanum-sorting library that is below link.
   * @link http://www.davekoelle.com/alphanum.html
   *
   *
   * @example
   *   debug(alphanumSort(
   *               ['a10', 'a2', 'a100', 'a1', 'a12']
   *   ));
   *   // @results ['a1', 'a2', 'a10', 'a12', 'a100']
   *
   *
   * @example
   *   var arr = [{v: 'a10'}, {v: 'a2'}, {v: 'a100'}, {v: 'a1'}];
   *   debug(alphanumSort(arr, function(item) {
   *     // Specify variable (property name).
   *     return item.v;
   *   }));
   *   // @results [{v: 'a1'}, {v: 'a2'}, {v: 'a10'}, {v: 'a100'}]
   *
   *
   * @param  {Array}     array  A target array.
   * @param  {Function} (func)  Callback function if need specify arguments.
   * @return {Array}            An array of result `array`.
   * @type  Function
   * @function
   * @static
   * @public
   */
  alphanumSort : (function() {
    /**@ignore*/
    function chunkify(t) {
      var tz = [], x = 0, y = -1, n = 0, i, j, m;
      while ((i = (j = t.charAt(x++)).charCodeAt(0))) {
        m = (i == 46 || (i >= 48 && i <= 57));
        if (m !== n) {
          tz[++y] = '';
          n = m;
        }
        tz[y] += j;
      }
      return tz;
    }
    /**@ignore*/
    function alphanumCase(a, b) {
      var aa, bb, c, d, i;
      aa = chunkify(stringify(a).toLowerCase());
      bb = chunkify(stringify(b).toLowerCase());
      for (i = 0; (aa[i] && bb[i]); i++) {
        if (aa[i] !== bb[i]) {
          c = +aa[i];
          d = +bb[i];
          if (c == aa[i] && d == bb[i]) {
            return c - d;
          } else {
            return (aa[i] > bb[i]) ? 1 : -1;
          }
        }
      }
      return aa.length - bb.length;
    }
    return function(array, func) {
      if (isArray(array)) {
        if (isFunction(func)) {
          array.sort(function(a, b) {
            return alphanumCase(func(a), func(b));
          });
        } else {
          array.sort(alphanumCase);
        }
      }
      return array;
    };
  }())
});

// Update Pot object,
Pot.update({
  arrayize     : Pot.Collection.arrayize,
  merge        : Pot.Collection.merge,
  unique       : Pot.Collection.unique,
  flatten      : Pot.Collection.flatten,
  alphanumSort : Pot.Collection.alphanumSort
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Struct.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Struct.
   * Object and Function object utilities.
   *
   * @name Pot.Struct
   * @type Object
   * @class
   * @static
   * @public
   */
  Struct : {}
});

update(Pot.Struct, {
  /**
   * @lends Pot.Struct
   */
  /**
   * Call the function with unknown number arguments.
   * That is for cases where JavaScript sucks
   *   built-in function like alert() on IE or other-browser when
   *   calls the Function.apply.
   *
   *
   * @example
   *   debug(invoke(window, 'alert', 100));
   *   debug(invoke(document, 'getElementById', 'container'));
   *   debug(invoke(window, 'setTimeout', function() { debug(1); }, 2000));
   *
   *
   * @param  {Object}      object  The context object (e.g. window)
   * @param  {String}      method  The callable function name.
   * @param  {Array|...*}  (args)  The function arguments.
   * @return {*}                   The result of the called function.
   * @type Function
   * @function
   * @public
   * @static
   */
  invoke : invoke,
  /**
   * Clone an object.
   *
   * @example
   *   var obj1 = {key: 'value'};
   *   var obj2 = clone(obj1);
   *   obj2.hoge = 'fuga';
   *   debug(obj1.hoge);  // undefined
   *   debug(obj2.hoge);  // 'fuga'
   *
   *
   * @param  {*}  o  Target object.
   * @return {*}     Cloned object.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  clone : function(x) {
    var result, f, c;
    if (x == null) {
      return x;
    }
    c = x.constructor;
    switch (typeLikeOf(x)) {
      case 'array':
          result = arrayize(x);
          break;
      case 'function':
          result = update(function() {
            return x.apply(this, arguments);
          }, x);
          result.prototype = update({}, x.prototype);
          break;
      case 'object':
          if (Pot.isDOMLike(x)) {
            if (x.cloneNode) {
              result = x.cloneNode(true);
              break;
            } else if (!PotSystem.canCloneDOM) {
              result = update({}, x);
              break;
            }
          }
          if (PotSystem.canProtoClone) {
            /**@ignore*/
            f = function() {};
            f.prototype = x;
            result = new f();
          } else {
            // Some environments cannot clone object by function prototype.
            //XXX: frozen object
            result = {};
            each(x, function(v, k) {
              result[k] = v;
            });
          }
          break;
      case 'error':
          result = new Error(Pot.getErrorMessage(x));
          update(result, x);
          break;
      case 'date':
          result = new Date(x.getTime());
          break;
      case 'regexp':
          result = new RegExp(x);
          break;
      case 'boolean':
      case 'number':
      case 'string':
          if (typeof x === 'object') {
            result = new c(c(x));
          } else {
            result = c((function() {
              return this;
            }).call(x));
          }
          break;
      default:
          result = x;
    }
    return result;
  },
  /**
   * Creates a new function with specified context and arguments.
   *
   *
   * @example
   *   var Hoge = function() {
   *     this.msg = 'Hello Hoge!';
   *   };
   *   Hoge.prototype.sayHoge = function() {
   *     debug(this.msg);
   *   };
   *   var hoge = new Hoge();
   *   //
   *   // direct
   *   setTimeout(hoge.sayHoge, 1000); // undefined
   *   //
   *   // bind
   *   setTimeout(bind(hoge.sayHoge, hoge), 1000); // Hello Hoge!
   *   //
   *   // use arguments
   *   Hoge.prototype.sayHoges = function(msg) {
   *     debug(this.msg + msg);
   *   };
   *   //
   *   // direct
   *   setTimeout(hoge.sayHoges, 1000); // NaN
   *   //
   *   // bind
   *   setTimeout(bind(hoge.sayHoges, hoge, 'Hi!'), 1000); // Hello Hoge!Hi!
   *
   *
   * @param  {Function}   func    A function to partially apply.
   * @param  {*}          self    Specifies the object as "this".
   *                              If the value is unspecified,
   *                               it will default to the global object.
   * @param  {...*}      (...)    Additional arguments that are partially
   *                               applied to the function.
   * @return {Function}           A new function that will invoked with
   *                               original context and
   *                               partially-applied arguments.
   * @type  Function
   * @function
   * @static
   * @public
   */
  bind : function(func, self/*[, ...args]*/) {
    var args = arguments, bounds, context = self || null;
    if (args.length > 2) {
      bounds = arrayize(args, 2);
      return function() {
        var a = arrayize(arguments);
        unshift.apply(a, bounds);
        return func.apply(context, a);
      };
    } else {
      return function() {
        return func.apply(context, arguments);
      };
    }
  },
  /**
   * Create a new function like Function.bind,
   *  except that a "this" is not required.
   * That is useful when the target function is already bound.
   *
   * @example
   *   function add(a, b) {
   *     return a + b;
   *   }
   *   var add2 = partial(add, 2);
   *   var result = add2(5);
   *   debug(result);
   *   // @results 7
   *
   *
   * @param  {Function}   func    A function to partially apply.
   * @param  {...*}       (...)   Additional arguments that are partially
   *                                applied to `func`.
   * @return {Function}           A new function that will invoked with
   *                                partially-applied arguments.
   * @type  Function
   * @function
   * @static
   * @public
   */
  partial : function(func/*[, ...args]*/) {
    var args = arrayize(arguments, 1);
    return function() {
      var a = arrayize(arguments);
      a.unshift.apply(a, args);
      return func.apply(this, a);
    };
  },
  /**
   * Collect the object key names like ES5's Object.keys().
   *
   *
   * @example
   *   var obj = {foo: 1, bar: 2, baz: 3};
   *   debug(keys(obj));
   *   // @results ['foo', 'bar', 'baz']
   *   var array = [10, 20, 30, 40, 50];
   *   debug(keys(array));
   *   // @results [0, 1, 2, 3, 4]
   *   delete array[2];
   *   debug(keys(array));
   *   // @results [0, 1, 3, 4]
   *
   *
   * @param  {Object}  o  The target object.
   * @return {Array}      The collected key names as an array.
   * @type  Function
   * @function
   * @static
   * @public
   */
  keys : Pot.keys,
  /**
   * Collect the object values.
   *
   *
   * @example
   *   var obj = {foo: 1, bar: 2, baz: 3};
   *   debug(values(obj));
   *   // @results [1, 2, 3]
   *   var array = ['foo', 'bar', 'baz'];
   *   debug(values(array));
   *   // @results ['foo', 'bar', 'baz'];
   *   delete array[1];
   *   debug(values(array));
   *   // @results ['foo', 'baz']
   *
   *
   * @param  {Object}  o  The target object.
   * @return {Array}      The collected values as an array.
   * @type  Function
   * @function
   * @static
   * @public
   */
  values : function(o) {
    var r = [];
    if (o) {
      if (isObject(o) || isArrayLike(o)) {
        each(o, function(v) {
          r[r.length] = v;
        });
      }
    }
    return r;
  },
  /**
   * Revert to an object from items() format array.
   *
   *
   * @example
   *   var array = [['foo', 1], ['bar', 2], ['baz', 3]];
   *   debug(tuple(array));
   *   // @results {foo: 1, bar: 2, baz: 3}
   *
   *
   * @example
   *   var array = [['foo', 1, 'bar', 2], {baz: 3}, ['A', 4, 'B']];
   *   debug(tuple(array));
   *   // @results {foo: 1, bar: 2, baz: 3, A: 4, B: (void 0)}
   *
   *
   * @example
   *   // Callback function usage:
   *   var array = [['A', 1], ['B', 2], ['C', 3]];
   *   var func = function(key, val) {
   *     return ['[' + key + ']', '{' + val + '}'];
   *   };
   *   debug(tuple(array, func));
   *   // @results {'[A]': '{1}', '[B]': '{2}', '[C]': '{3}'}
   *
   *
   * @example
   *   // Example to specify the type of result:
   *   var array = [['prototype', 1], ['__iterator__', 2], ['__proto__', 3]];
   *   debug(tuple(array, new Pot.Hash()).toJSON());
   *   // @results {"prototype": 1, "__iterator__": 2, "__proto__": 3}
   *
   *
   * @example
   *   // Example to specify the type of result
   *   //   (enables Array, Object, Pot.Hash etc.):
   *   var array = [['A', 1], ['B', 2], ['C', 3]];
   *   var func = function(key, val) {
   *     return '(' + key + ':' + val + ')';
   *   };
   *   debug(tuple(array, func, []));
   *   // @results ['(A:1)', '(B:2)', '(C:3)']
   *
   *
   * @param  {Array}       items        The target object.
   * @param  {Function|*} (callback)    (Optional) Callback function.
   * @param  {*}          (defaultType) (Optional) An object literal to
   *                                      specify the type of result.
   * @return {Object}                   The collected object.
   * @type  Function
   * @function
   * @static
   * @public
   */
  tuple : function(items, callback, defaultType) {
    var result = {}, fn, args = arguments, type = null;
    if (args.length >= 2) {
      if (isFunction(callback)) {
        fn   = callback;
        type = defaultType;
      } else {
        fn   = defaultType;
        type = callback;
      }
    }
    if (!isFunction(fn)) {
      fn = null;
    }
    if (type == null) {
      type = 'object';
    } else if (isHash(type) || (type && type === Hash)) {
      type = 'hash';
    } else {
      type = typeOf(type);
    }
    if (items) {
      if (isArray(items)) {
        result = null;
        each(items, function(item) {
          var i, len, v, k, pairs = [];
          if (item) {
            if (isArrayLike(item)) {
              i = 0;
              len = item.length;
              if (len) {
                do {
                  try {
                    k = stringify(item[i++], true);
                    v = item[i++];
                    pairs[pairs.length] = [k, v];
                  } catch (e) {}
                } while (i < len);
              }
            } else if (isObject(item)) {
              each(item, function(val, p) {
                pairs[pairs.length] = [p, val];
              });
            }
            each(pairs, function(pair) {
              var rv;
              try {
                switch (type) {
                  case 'hash':
                      if (result === null) {
                        result = new Hash();
                      }
                      if (fn) {
                        rv = fn.apply(pair, pair);
                        if (isArray(rv)) {
                          result.set(rv[0], rv[1]);
                        } else if (isObject(rv)) {
                          result.set(rv);
                        } else {
                          result.set(pair[0], rv);
                        }
                      } else {
                        result.set(pair[0], pair[1]);
                      }
                      break;
                  case 'array':
                      if (result === null) {
                        result = [];
                      }
                      result[result.length] = fn ? fn.apply(pair, pair)
                                                 : pair;
                      break;
                  case 'string':
                      if (result === null) {
                        result = '';
                      }
                      result += fn ? fn.apply(pair, pair)
                                   : (stringify(pair[0]) + stringify(pair[1]));
                      break;
                  case 'number':
                      if (result === null) {
                        result = 0;
                      }
                      result += fn ? fn.apply(pair, pair)
                                   : ((+pair[0] || 0) + (+pair[1] || 0));
                      break;
                  case 'object':
                  default:
                      if (result === null) {
                        result = {};
                      }
                      if (fn) {
                        rv = fn.apply(pair, pair);
                        if (isArray(rv)) {
                          result[rv[0]] = rv[1];
                        } else if (isObject(rv)) {
                          each(rv, function(val, prop) {
                            result[prop] = val;
                          });
                        } else {
                          result[pair[0]] = rv;
                        }
                      } else {
                        result[pair[0]] = pair[1];
                      }
                }
              } catch (ex) {}
            });
          }
        });
      }
    }
    return result;
  },
  /**
   * Revert to an object from zip() format array.
   *
   * <pre>
   * Example:
   *
   *   arguments:  [[1, 4],
   *                [2, 5],
   *                [3, 6]]
   *
   *   results:    [1, 2, 3],
   *               [4, 5, 6]
   *
   * Example:
   *
   *   arguments:  [[{a: 1}, {d: 4}],
   *                [{b: 2}, {e: 5}],
   *                [{c: 3}, {f: 6}]]
   *
   *   results:    {a: 1, b: 2, c: 3},
   *               {d: 4, e: 5, f: 6}
   * </pre>
   *
   *
   * @link http://docs.python.org/library/functions.html#zip
   *
   *
   * @example
   *   debug(unzip([[1, 4], [2, 5], [3, 6]]));
   *   // @results
   *   //   [[1, 2, 3], [4, 5, 6]]
   *   //
   *   debug(unzip([[{a: 1}, {d: 4}], [{b: 2}, {e: 5}], [{c: 3}, {f: 6}]]));
   *   // @results
   *   //   [{a:1, b:2, c:3}, {d:4, e:5, f:6}]
   *   //
   *   var callback = function(a, b, c) { return a + b + c; };
   *   debug(unzip([[1, 4], [2, 5], [3, 6]], callback));
   *   // @results
   *   //   [6, 15]
   *   //
   *
   *
   * @see Pot.zip
   *
   * @param  {Array}       zipped       Target array.
   * @param  {Function|*} (callback)    (Optional) Callback function.
   * @return {Array}                    The collected array object.
   * @type  Function
   * @function
   * @static
   * @public
   */
  unzip : function(zipped, callback) {
    var result = [], max, len, fn, i, j, lists, val, tail;
    if (isFunction(callback)) {
      fn = callback;
    }
    if (zipped && zipped.length && isArray(zipped)) {
      max = 0;
      each(zipped, function(z) {
        if (z && z.length > max) {
          max = z.length;
        }
      });
      len = zipped.length;
      for (i = 0; i < max; i++) {
        lists = [];
        for (j = 0; j < len; j++) {
          try {
            val = zipped[j][i];
          } catch (ex) {
            continue;
          }
          tail = lists.length - 1;
          if (val && tail >= 0 && isObject(lists[tail]) && isObject(val)) {
            each(val, function(v, k) {
              try {
                lists[tail][k] = v;
              } catch (ex) {}
            });
          } else {
            lists[lists.length] = val;
          }
        }
        if (lists.length === 1 && isObject(lists[0])) {
          lists = lists.shift();
        }
        result[result.length] = fn ? fn.apply(lists, arrayize(lists)) : lists;
      }
    }
    return result;
  },
  /**
   * Creates an object from a key-value pairs.
   *
   *
   * @example
   *   debug(pairs('key', 'value'));
   *   // @results {key : 'value'}
   *   debug(pairs('key1', 'value1', 'key2', 'value2'));
   *   // @results {key1: 'value1', key2: 'value2'}
   *   debug(pairs('key'));
   *   // @results {key: undefined}
   *   debug(pairs(['key', 'value']));
   *   // @results {key: 'value'}
   *   debug(pairs('key1', 1, ['key2', 2], 'key3', 3));
   *   // @results {key1: 1, key2: 2, key3: 3}
   *   debug(pairs(['a', 1, ['b', 2, [{c: 3}, 'd', 4]]]));
   *   // @results {a: 1, b: 2, c: 3, d: 4}
   *
   *
   * @param  {String|*}  (...)  The key-value pairs.
   * @return {Object}           The created object.
   * @type  Function
   * @function
   * @static
   * @public
   */
  pairs : function(/*key, value[, ...args]*/) {
    var result = {}, args = arrayize(arguments),
        len = args.length, i = 0;
    do {
      if (isArray(args[i])) {
        args[i] = Pot.Struct.pairs.apply(null, args[i]);
      }
      if (isObject(args[i])) {
        each(args[i++], function(v, k) {
          result[k] = v;
        });
      } else {
        result[stringify(args[i++], true)] = args[i++];
      }
    } while (i < len);
    return result;
  },
  /**
   * Count the object items then return total number.
   *
   *
   * @example
   *   debug(count({a: 1, b: 2, c: 3}));              // 3
   *   debug(count({}));                              // 0
   *   debug(count([1, 2, 3, 4, 5]));                 // 5
   *   debug(count([]));                              // 0
   *   debug(count(new Object('foo', 'bar', 'baz'))); // 3
   *   debug(count(new Array(100)));                  // 100
   *   debug(count(null));                            // 0
   *   debug(count((void 0)));                        // 0
   *   debug(count('hoge'));                          // 4
   *   debug(count(''));                              // 0
   *   debug(count(new String('hoge')));              // 4
   *   debug(count(100));                             // 100
   *   debug(count(0));                               // 0
   *   debug(count(-1));                              // 1
   *   debug(count((function() {})));                 // 0
   *   var f = function() {};
   *   f.foo = 1;
   *   f.bar = 2;
   *   debug(count(f));  // 2
   *
   *
   * @param  {Object|*}  o  The target object.
   * @return {Number}       The total count.
   * @type  Function
   * @function
   * @static
   * @public
   */
  count : function(o) {
    var c = 0;
    if (o != null) {
      switch (typeLikeOf(o)) {
        case 'array':
        case 'string':
            c = o.length;
            break;
        case 'object':
        case 'function':
            each(o, function() {
              c++;
            });
            break;
        case 'number':
            c = Math.abs(Math.round(o));
            break;
        default:
            try {
              c = o.toString().length;
            } catch (e) {
              c = 0;
            }
      }
    }
    return c - 0;
  },
  /**
   * Get the first orders value in object.
   *
   *
   * @example
   *   debug(first({a: 1, b: 2, c: 3}));   // 1
   *   debug(first({}));                   // undefined
   *   debug(first([1, 2, 3, 4, 5]));      // 1
   *   debug(first([]));                   // undefined
   *   debug(first({a: 'foo', b: 'bar'})); // 'foo'
   *   debug(first(new Array(100)));       // undefined
   *   debug(first(null));                 // undefined
   *   debug(first((void 0)));             // undefined
   *   debug(first('hoge'));               // 'h'
   *   debug(first(''));                   // ''
   *   debug(first(new String('hoge')));   // 'h'
   *   debug(first(123));                  // 3
   *   debug(first(0));                    // 0
   *   debug(first(-123));                 // 3
   *
   *
   * @param  {Object|Array|*}  o  The target object.
   * @return {*}                  The first value in object.
   * @type  Function
   * @function
   * @static
   * @public
   */
  first : function(o, keyOnly) {
    var r, p, len;
    if (o != null) {
      switch (typeLikeOf(o)) {
        case 'array':
            if (o) {
              len = o.length;
              for (p = 0; p < len; p++) {
                try {
                  if (p in o) {
                    if (keyOnly) {
                      r = p;
                    } else {
                      r = o[p];
                    }
                    break;
                  }
                } catch (e) {
                  continue;
                }
              }
            }
            break;
        case 'string':
            if (keyOnly) {
              r = o.length ? 0 : null;
            } else {
              r = o.length ? o.charAt(0) : '';
            }
            break;
        case 'number':
            if (keyOnly) {
              r = isNaN(o) ? null : 0;
            } else {
              r = Math.abs(o).toString().slice(-1) - 0;
            }
            break;
        case 'object':
            if (o) {
              for (p in o) {
                if (hasOwnProperty.call(o, p)) {
                  try {
                    if (keyOnly) {
                      r = p;
                    } else {
                      r = o[p];
                    }
                    break;
                  } catch (e) {
                    continue;
                  }
                }
              }
            }
      }
    }
    return r;
  },
  /**
   * Get the first orders key in object.
   *
   *
   * @example
   *   debug(firstKey({a: 1, b: 2, c: 3}));   // 'a'
   *   debug(firstKey({}));                   // undefined
   *   debug(firstKey([1, 2, 3, 4, 5]));      // 0
   *   debug(firstKey([]));                   // undefined
   *   debug(firstKey({a: 'foo', b: 'bar'})); // 'a'
   *   debug(firstKey(new Array(100)));       // undefined
   *   debug(firstKey(null));                 // undefined
   *   debug(firstKey((void 0)));             // undefined
   *   debug(firstKey('hoge'));               // 0
   *   debug(firstKey(''));                   // null
   *   debug(firstKey(new String('hoge')));   // 0
   *   debug(firstKey(123));                  // 0
   *   debug(firstKey(0));                    // 0
   *   debug(firstKey(-123));                 // 0
   *
   *
   * @param  {Object|Array|*}  o  The target object.
   * @return {*}                  The first key in object.
   * @type  Function
   * @function
   * @static
   * @public
   */
  firstKey : function(o) {
    return Pot.Struct.first(o, true);
  },
  /**
   * Get the last orders value in object.
   *
   *
   * @example
   *   debug(last({a: 1, b: 2, c: 3}));   // 3
   *   debug(last({}));                   // undefined
   *   debug(last([1, 2, 3, 4, 5]));      // 5
   *   debug(last([]));                   // undefined
   *   debug(last({a: 'foo', b: 'bar'})); // 'bar'
   *   debug(last(new Array(100)));       // undefined
   *   debug(last(null));                 // undefined
   *   debug(last((void 0)));             // undefined
   *   debug(last('hoge'));               // 'e'
   *   debug(last(''));                   // ''
   *   debug(last(new String('hoge')));   // 'e'
   *   debug(last(123));                  // 1
   *   debug(last(0));                    // 0
   *   debug(last(-123));                 // 1
   *
   *
   * @param  {Object|Array|*}  o  The target object.
   * @return {*}                  The last value in object.
   * @type  Function
   * @function
   * @static
   * @public
   */
  last : function(o, keyOnly) {
    var r, p;
    if (o != null) {
      switch (typeLikeOf(o)) {
        case 'array':
            p = o.length;
            while (--p >= 0) {
              try {
                if (p in o) {
                  if (keyOnly) {
                    r = p;
                  } else {
                    r = o[p];
                  }
                  break;
                }
              } catch (e) {
                continue;
              }
            }
            break;
        case 'string':
            if (keyOnly) {
              r = o.length ? o.length - 1 : null;
            } else {
              r = o.length ? o.slice(-1) : '';
            }
            break;
        case 'number':
            if (keyOnly) {
              r = isNaN(o) ? null : Math.abs(o).toString().length - 1;
            } else {
              r = Math.abs(o).toString().charAt(0) - 0;
            }
            break;
        case 'object':
            each(o, function(v, k) {
              if (keyOnly) {
                r = k;
              } else {
                r = v;
              }
            });
      }
    }
    return r;
  },
  /**
   * Get the last orders key in object.
   *
   *
   * @example
   *   debug(lastKey({a: 1, b: 2, c: 3}));   // 'c'
   *   debug(lastKey({}));                   // undefined
   *   debug(lastKey([1, 2, 3, 4, 5]));      // 4
   *   debug(lastKey([]));                   // undefined
   *   debug(lastKey({a: 'foo', b: 'bar'})); // 'b'
   *   debug(lastKey(new Array(100)));       // undefined
   *   debug(lastKey(null));                 // undefined
   *   debug(lastKey((void 0)));             // undefined
   *   debug(lastKey('hoge'));               // 3
   *   debug(lastKey(''));                   // null
   *   debug(lastKey(new String('hoge')));   // 3
   *   debug(lastKey(123));                  // 2
   *   debug(lastKey(0));                    // 0
   *   debug(lastKey(-123));                 // 2
   *
   *
   * @param  {Object|Array|*}  o  The target object.
   * @return {*}                  The last key in object.
   * @type  Function
   * @function
   * @static
   * @public
   */
  lastKey : function(o) {
    return Pot.Struct.last(o, true);
  },
  /**
   * Whether the object contains the given subject.
   *
   *
   * @example
   *   var obj = {foo: 10, bar: 20, baz: 30};
   *   debug(contains(obj, 20));    // true
   *   debug(contains(obj, 50));    // false
   *   var arr = [10, 20, 30, 'foo', 'bar'];
   *   debug(contains(arr, 20));    // true
   *   debug(contains(arr, 75));    // false
   *   debug(contains(arr, 'foo')); // true
   *   debug(contains(arr, 'FOO')); // false
   *   var str = 'foobarbaz';
   *   debug(contains(str, 'A'));   // false
   *   debug(contains(str, 'foo')); // true
   *   debug(contains(str, '123')); // false
   *   var num = 12345;
   *   debug(contains(num, 1));     // true
   *   debug(contains(num, 45));    // true
   *   debug(contains(num, 7));     // false
   *
   *
   * @param  {*}       object   The object to test for the
   *                              presence of the element.
   * @param  {*}       subject  The object for which to test.
   * @return {Boolean}          true if subject is present.
   * @type  Function
   * @function
   * @static
   * @public
   */
  contains : function(object, subject) {
    var result = false;
    switch (typeLikeOf(object)) {
      case 'string':
          result = ~object.indexOf(subject);
          break;
      case 'array':
          result = ~Pot.indexOf(object, subject);
          break;
      case 'object':
          result = ~Pot.indexOf(object, subject);
          break;
      case 'number':
          result = ~object.toString().indexOf(subject);
    }
    return !!result;
  },
  /**
   * Return the copy object that was removed a subject value.
   *
   *
   * @example
   *   // String
   *   debug(remove('foo bar baz', 'o'));            // 'fo bar baz'
   *   debug(remove('foo bar baz', 'bar'));          // 'foo  baz'
   *   // Array
   *   debug(remove([1, 2, 3, 4, 5], 2));            // [1, 3, 4, 5]
   *   debug(remove([1, 2, 3, 4, 5], '3'));          // [1, 2, 3, 4, 5]
   *   debug(remove([1, 2, 3, 4, 5], '3', true));    // [1, 2, 4, 5]
   *   // Object
   *   debug(remove({A: 1, B: 2, C: 3}, 2));         // {A: 1, C: 3}
   *   debug(remove({A: 1, B: 2, C: 3}, '3'));       // {A: 1, B: 2, C: 3}
   *   debug(remove({A: 1, B: 2, C: 3}, '3', true)); // {A: 1, B: 2}
   *   // Number
   *   debug(remove(1234512345, 2));                 // 134512345
   *   debug(remove(1234512345, 123));               // 4512345
   *
   *
   * @param  {*}       object   The target value.
   * @param  {*}       subject  The subject value.
   * @param  {Boolean} (loose)  Whether to use loose compare operator(==).
   *                              Default is strict operator(===).
   * @return {*}                The removed value.
   * @type  Function
   * @function
   * @static
   * @public
   */
  remove : function(object, subject, loose) {
    var result, i, len, index, done = false;
    result = object;
    if (object != null) {
      switch (typeLikeOf(object)) {
        case 'string':
            result = object.replace(subject, '');
            break;
        case 'array':
            if (!loose && PotSystem.isBuiltinArrayIndexOf) {
              index = indexOf.call(object, subject);
              if (~index) {
                result = Pot.Struct.removeAt(object, index);
              }
              break;
            }
            result = [];
            len = object.length;
            for (i = 0; i < len; i++) {
              try {
                if (!done &&
                    ((!loose && object[i] === subject) ||
                      (loose && object[i] ==  subject))) {
                  done = true;
                } else {
                  result[result.length] = object[i];
                }
              } catch (e) {}
            }
            break;
        case 'object':
            result = {};
            each(object, function(v, p) {
              if (!done &&
                  ((!loose && v === subject) ||
                    (loose && v ==  subject))) {
                done = true;
              } else {
                result[p] = v;
              }
            });
            break;
        case 'number':
            result = object.toString().replace(subject, '') - 0;
            break;
        default:
            result = object;
      }
    }
    return result;
  },
  /**
   * Return the copy object that was removed all subject value.
   *
   *
   * @example
   *   // String
   *   debug(removeAll('foo bar baz', 'o'));            // 'f bar baz'
   *   debug(removeAll('foo bar baz', 'ba'));           // 'foo r z'
   *   // Array
   *   debug(removeAll([1, 2, 3, 1, 2], 2));            // [1, 3, 1]
   *   debug(removeAll([1, 2, 3, 1, 2], '2'));          // [1, 2, 3, 1, 2]
   *   debug(removeAll([1, 2, 3, 1, 2], '2', true));    // [1, 3, 1]
   *   // Object
   *   debug(removeAll({A: 1, B: 2, C: 2}, 2));         // {A: 1}
   *   debug(removeAll({A: 1, B: 2, C: 2}, '2'));       // {A: 1, B: 2, C: 2}
   *   debug(removeAll({A: 1, B: 2, C: 2}, '2', true)); // {A: 1}
   *   // Number
   *   debug(removeAll(1234512345, 2));                 // 13451345
   *   debug(removeAll(1234512345, 123));               // 4545
   *
   *
   * @param  {*}       object   The target value.
   * @param  {*}       subject  The subject value.
   * @param  {Boolean} (loose)  Whether to use loose compare operator(==).
   *                              Default is strict operator(===).
   * @return {*}                The removed value.
   * @type  Function
   * @function
   * @static
   * @public
   */
  removeAll : function(object, subject, loose) {
    var result, i, len;
    result = object;
    if (object != null) {
      switch (typeLikeOf(object)) {
        case 'string':
            if (isRegExp(subject)) {
              if (!subject.global) {
                subject = new RegExp(
                  subject.source,
                  'g' + (subject.ignoreCase ? 'i' : '') +
                        (subject.multiline  ? 'm' : '')
                );
              }
            } else {
              subject = new RegExp(rescape(subject), 'g');
            }
            result = object.replace(subject, '');
            break;
        case 'array':
            result = [];
            len = object.length;
            for (i = 0; i < len; i++) {
              try {
                if ((!loose && object[i] === subject) ||
                     (loose && object[i] ==  subject)) {
                  continue;
                }
                result[result.length] = object[i];
              } catch (e) {}
            }
            break;
        case 'object':
            result = {};
            each(object, function(v, p) {
              if ((!loose && v === subject) ||
                   (loose && v ==  subject)) {
                return;
              }
              result[p] = v;
            });
            break;
        case 'number':
            result = object.toString().split(subject).join('') - 0;
            break;
        default:
            result = object;
      }
    }
    return result;
  },
  /**
   * Return the copy object that was removed a subject value.
   *
   *
   * @example
   *   // String
   *   debug(removeAt('foo bar baz', 2));         // 'fo bar baz'
   *   debug(removeAt('foo bar baz', 2, 5));      // 'fo baz'
   *   debug(removeAt('foo bar baz', 100));       // 'foo bar baz'
   *   // Array
   *   debug(removeAt([1, 2, 3, 4, 5], 2));       // [1, 2, 4, 5]
   *   debug(removeAt([1, 2, 3, 4, 5], 2, 2));    // [1, 2, 5]
   *   debug(removeAt([1, 2, 3, 4, 5], -1, 5));   // [1, 2, 3, 4]
   *   // Object
   *   debug(removeAt({A: 1, B: 2, C: 3}, 2));    // {A: 1, B: 2}
   *   debug(removeAt({A: 1, B: 2, C: 3}, 1, 5)); // {A: 1}
   *   debug(removeAt({A: 1, B: 2, C: 3}, 5));    // {A: 1, B: 2, C: 3}
   *   // Number
   *   debug(removeAt(1234512345, 2));            // 123451245
   *   debug(removeAt(1234512345, 2, 3));         // 1234545
   *   debug(removeAt(-1234512345, 2, 3));        // -1234545
   *
   *
   * @param  {*}        object   The target value.
   * @param  {Number}   index    The start index.
   * @param  {Number}  (length)  (Optional) The removal length (default=1).
   * @return {*}                 The removed value.
   * @type  Function
   * @function
   * @static
   * @public
   */
  removeAt : function(object, index, length) {
    var result, me = Pot.Struct.removeAt, idx, len, n, minus;
    result = object;
    if (object != null) {
      idx = index - 0;
      len = (length - 0) || 1;
      if (isNaN(idx)) {
        return result;
      }
      switch (typeLikeOf(object)) {
        case 'string':
            if (object) {
              if (idx >= 0 && len > 0) {
                if (idx === 0) {
                  result = object.substring(len);
                } else {
                  result = object.substring(0, idx) +
                          object.substring(idx + len);
                }
              }
            }
            break;
        case 'array':
            if (object.length) {
              result = arrayize(object);
              splice.call(result, idx, len);
            }
            break;
        case 'object':
            result = {};
            n = 0;
            each(object, function(v, p) {
              if (n < idx || n > idx + len) {
                result[p] = v;
              }
              n++;
            });
            break;
        case 'number':
            minus = (object < 0);
            result = me(
              Math.abs(object).toString().split('').reverse().join(''),
              idx,
              len
            ).toString().split('').reverse().join('') - 0;
            if (minus) {
              result = -result;
            }
            break;
        default:
            result = object;
      }
    }
    return result;
  },
  /**
   * Compares two objects for equality.
   * If two objects have same length and same scalar value then
   *   will return true. Otherwise will return false.
   *
   *
   * @example
   *   var obj1 = {foo: 10, bar: 20, baz: 30};
   *   var obj2 = {foo: 10, bar: 20, baz: 30};
   *   var obj3 = {a: 'hoge', b: 'fuga'};
   *   debug(equals(obj1, obj2)); // true
   *   debug(equals(obj1, obj3)); // false
   *   var obj4 = {};
   *   var obj5 = {};
   *   debug(equals(obj4, obj5)); // true
   *
   *
   * @example
   *   var arr1 = [1, 2, 3];
   *   var arr2 = [1, 2, 3];
   *   var arr3 = [1, 2, 10];
   *   debug(equals(arr1, arr2)); // true
   *   debug(equals(arr1, arr3)); // false
   *   var arr4 = [];
   *   var arr5 = [];
   *   debug(equals(arr4, arr5)); // true
   *   var cmp = function(a, b) {
   *     return a == b ||
   *       String(a).toLowerCase() == String(b).toLowerCase();
   *   };
   *   var arr6 = [1, 2, 'foo', 'bar'];
   *   var arr7 = ['1', 2, 'FOO', 'baR'];
   *   debug(equals(arr6, arr7, cmp)); // true
   *
   *
   * @example
   *   var func1 = (function() {});
   *   var func2 = (function() {});
   *   var func3 = (function() { return this; });
   *   debug(equals(func1, func2)); // true
   *   debug(equals(func1, func3)); // false
   *
   *
   * @example
   *   var date1 = new Date();
   *   var date2 = new Date(date1.getTime());
   *   var date3 = new Date(date1.getTime() + 100);
   *   debug(equals(date1, date2)); // true
   *   debug(equals(date1, date3)); // false
   *
   *
   * @example
   *   var str1 = 'foobarbaz';
   *   var str2 = 'foobarbaz';
   *   var str3 = 'hoge';
   *   debug(equals(str1, str2)); // true
   *   debug(equals(str1, str3)); // false
   *
   *
   * @example
   *   var num1 = 12345;
   *   var num2 = 12345;
   *   var num3 = 12345.455512;
   *   var num4 = 12345.443556;
   *   var num5 = 12345.443556999;
   *   debug(equals(num1, num2)); // true
   *   debug(equals(num1, num3)); // false
   *   debug(equals(num3, num4)); // false
   *   debug(equals(num4, num5)); // true
   *
   *
   *
   * @param  {Array|Object|*}   object    The first object to compare.
   * @param  {Array|Object|*}   subject   The second object to compare.
   * @param  {Function}         (func)    (Optional) The comparison function.
   *                                        e.g. function(a, b) {
   *                                               return a == b;
   *                                             }
   *                                        Should take 2 arguments to compare,
   *                                        and return true if the arguments
   *                                        are equal.
   *                                        Defaults to which compares the
   *                                        elements using the
   *                                        built-in '===' operator.
   * @return {Boolean}                      Whether the two objects are equal.
   * @type  Function
   * @function
   * @static
   * @public
   */
  equals : function(object, subject, func) {
    var result = false, cmp, empty, keys, i, len, k, doCmp;
    /**@ignore*/
    cmp = isFunction(func) ? func : (function(a, b) { return a === b; });
    /**@ignore*/
    doCmp = function(a, b) {
      try {
        return cmp(a, b);
      } catch (e) {
        return false;
      }
    };
    if (object == null) {
      if (cmp(object, subject)) {
        result = true;
      }
    } else if (object === subject || doCmp(object, subject)) {
      result = true;
    } else {
      switch (typeLikeOf(object)) {
        case 'array':
            if (subject && isArrayLike(subject)) {
              if (Pot.isEmpty(object) && Pot.isEmpty(subject)) {
                result = true;
              } else if (object && object.length === subject.length) {
                result = false;
                each(object, function(v, i) {
                  if (!(i in subject) || !Pot.Struct.equals(v, subject[i], cmp)) {
                    result = false;
                    throw PotStopIteration;
                  } else {
                    result = true;
                  }
                });
              }
            }
            break;
        case 'object':
            if (subject && isObject(subject)) {
              if (Pot.isEmpty(object) && Pot.isEmpty(subject)) {
                result = true;
              } else if (
                  (Pot.isDOMLike(object)  || !Pot.isPlainObject(object)) &&
                  (Pot.isDOMLike(subject) || !Pot.isPlainObject(subject))
              ) {
                result = (object === subject);
              } else {
                keys = Pot.keys(subject);
                len = keys.length;
                if (object && Pot.keys(object).length === len) {
                  i = 0;
                  result = true;
                  each(object, function(value, p) {
                    if (!(i in keys) || keys[i] !== p) {
                      result = false;
                      throw PotStopIteration;
                    }
                    try {
                      if (!Pot.Struct.equals(value, subject[p], cmp)) {
                        result = false;
                        throw PotStopIteration;
                      }
                    } catch (e) {}
                    i++;
                  });
                }
              }
            }
            break;
        case 'string':
            if (isString(subject)) {
              if (object.length === subject.length &&
                  cmp(object.toString(), subject.toString())
              ) {
                result = true;
              }
            }
            break;
        case 'number':
            if (isNumber(subject)) {
              if (isNaN(object) && isNaN(subject)) {
                result = true;
              } else if (!isFinite(object) && !isFinite(subject)) {
                result = true;
              } else {
                if (Pot.isInt(subject)) {
                  if (cmp(object, subject)) {
                    result = true;
                  }
                } else {
                  if (Math.abs(object - subject) <= 0.000001) {
                    result = true;
                  }
                }
              }
            }
            break;
        case 'function':
            if (isFunction(subject)) {
              if (cmp(Pot.getFunctionCode(object),
                      Pot.getFunctionCode(subject)) &&
                  object.constructor === subject.constructor) {
                /**@ignore*/
                empty = function(a) {
                  for (k in a) {
                    return false;
                  }
                  return true;
                };
                if (empty(object) && empty(subject)) {
                  result = true;
                } else {
                  result = false;
                  each(object, function(v, k) {
                    if (!Pot.Struct.equals(v, subject[k], cmp)) {
                      result = false;
                      throw PotStopIteration;
                    } else {
                      result = true;
                    }
                  });
                }
                if (result) {
                  if (empty(object.prototype) && empty(subject.prototype)) {
                    result = true;
                  } else {
                    result = false;
                    each(object.prototype, function(v, k) {
                      if (!Pot.Struct.equals(v, subject.prototype[k], cmp)) {
                        result = false;
                        throw PotStopIteration;
                      } else {
                        result = true;
                      }
                    });
                  }
                }
              }
            }
            break;
        case 'boolean':
            if (isBoolean(subject)) {
              if (cmp(object != false, subject != false)) {
                result = true;
              }
            }
            break;
        case 'date':
            if (isDate(subject)) {
              if (cmp(object.getTime(), subject.getTime())) {
                result = true;
              }
            }
            break;
        case 'error':
            if (isError(subject)) {
              if (Pot.Struct.equals(
                    Pot.getErrorMessage(object),
                    Pot.getErrorMessage(subject),
                    cmp
                  ) &&
                  cmp(object.constructor, subject.constructor)) {
                result = true;
              }
            }
            break;
        case 'regexp':
            if (isRegExp(subject)) {
              if (cmp(object.toString(), subject.toString())) {
                result = true;
              }
            }
            break;
        default:
            if (typeOf(object) === typeOf(subject) &&
                cmp(object, subject)) {
              result = true;
            }
      }
    }
    return result;
  },
  /**
   * Reverse the object.
   *
   *
   * @example
   *   debug(reverse({foo: 1, bar: 2, baz: 3}));
   *   // @results {baz: 3, bar: 2, foo: 1}
   *
   *
   * @example
   *   debug(reverse([1, 2, 3, 4, 5]));
   *   // @results [5, 4, 3, 2, 1]
   *
   *
   * @example
   *   debug(reverse('123abc'));
   *   // @results 'cba321'
   *
   *
   * @param  {Object|Array|*}  o   A target object.
   * @return {Object|*}            The result object.
   * @type  Function
   * @function
   * @static
   * @public
   */
  reverse : function(o) {
    var result, revs, i, p, val;
    switch (typeLikeOf(o)) {
      case 'object':
          result = {};
          revs = [];
          for (p in o) {
            try {
              if (hasOwnProperty.call(o, p)) {
                try {
                  val = o[p];
                } catch (ex) {
                  continue;
                }
                revs[revs.length] = [p, val];
              }
            } catch (e) {}
          }
          i = revs.length;
          while (--i >= 0) {
            result[revs[i][0]] = revs[i][1];
          }
          break;
      case 'array':
          try {
            if (isArray(o)) {
              result = o.reverse();
            } else {
              throw o;
            }
          } catch (e) {
            result = [];
            i = o.length;
            while (--i >= 0) {
              try {
                if (hasOwnProperty.call(o, i)) {
                  try {
                    val = o[i];
                  } catch (ex) {
                    continue;
                  }
                  result[result.length] = val;
                }
              } catch (err) {}
            }
          }
          break;
      case 'string':
          result = o.split('').reverse().join('');
          break;
      case 'number':
          result = -o;
          break;
      case 'boolean':
          result = (o == false);
          break;
      default:
          result = o;
    }
    return result;
  },
  /**
   * Flips the object.
   *
   *
   * @example
   *   debug(flip({foo: 'A', bar: 'B', baz: 'C'}));
   *   // @results {A: 'foo', B: 'bar', C: 'baz'}
   *
   *
   * @param  {Object|Array|*}  o   A target object.
   * @return {Object|*}            The result object.
   * @type  Function
   * @function
   * @static
   * @public
   */
  flip : function(o) {
    var result;
    switch (typeLikeOf(o)) {
      case 'object':
          result = {};
          each(o, function(v, k) {
            result[stringify(v, true)] = k;
          });
          break;
      case 'array':
          result = [];
          each(o, function(v, i) {
            if (isNumeric(v)) {
              result[(v - 0)] = i;
            }
          });
          break;
      case 'string':
          result = '';
          each(o.split(''), function(c) {
            result += fromUnicode(
              c.charCodeAt(0) ^ 0xFFFF
            );
          });
          break;
      case 'number':
          result = ~o;
          break;
      case 'boolean':
          result = (o == false);
          break;
      default:
          result = o;
    }
    return result;
  },
  /**
   * Shuffle an object and returns it.
   * This function keeps the original object intact.
   *
   *
   * @example
   *   debug(shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]));
   *   // @results  e.g. (uncertain)
   *   //   [8, 1, 6, 4, 3, 5, 2, 7, 9]
   *   //
   *   debug(shuffle(['foo', 'bar', 'baz']));
   *   // @results  e.g.
   *   //   ['bar', 'foo', 'baz']
   *   //
   *   debug(shuffle(12345));
   *   // @results  e.g.
   *   //   25143
   *   //
   *   debug(shuffle(-123456789.0839893));
   *   // @results  e.g.
   *   //   -276195348.9908833
   *   //
   *   debug(shuffle({a: 1, b: 2, c: 3, d: 4, e: 5}));
   *   // @results  e.g.
   *   //   {c: 3, b: 2, d: 4, e: 5, a: 1}
   *   //
   *   debug(shuffle('abcdef12345'));
   *   // @results  e.g.
   *   //   'ae2d135cb4f'
   *   //
   *
   *
   * @param  {Array}  array  A target array.
   * @return {Array}         An array of result.
   * @type  Function
   * @function
   * @static
   * @public
   */
  shuffle : function(o) {
    var result, i, j, tmp, points, sign, Struct = Pot.Struct;
    if (isArray(o)) {
      result = o.slice();
      i = result.length;
      while (i > 0) {
        j = Math.floor(Math.random() * i);
        tmp = result[--i];
        result[i] = result[j];
        result[j] = tmp;
      }
    } else if (o && isObject(o)) {
      result = Struct.tuple(Struct.shuffle(Pot.items(o)));
    } else if (o && isString(o)) {
      result = Struct.shuffle(o.split('')).join('');
    } else if (isNumber(o) && isNumeric(o)) {
      sign = ((o - 0) < 0) ? '-' : '';
      points = Math.abs(o).toString().split('.');
      result = Struct.shuffle(points.shift());
      if (points.length) {
        result += '.' + Struct.shuffle(points.pop());
      }
      result = result - 0;
      if (sign) {
        result = -result;
      }
    } else {
      result = o;
    }
    return result;
  },
  /**
   * Fill the first argument value with in the specific value.
   * The available first argument types are Array and String, and Object.
   *
   *
   * @example
   *   debug(fill([1, 2], 3, 5));
   *   // @results [1, 2, 3, 3, 3, 3, 3]
   *   debug(fill([], null, 3));
   *   // @results [null, null, null]
   *   debug(fill('foo', 'o', 10));
   *   // @results 'foooooooooooo'
   *   debug(fill('', 'hoge', 5));
   *   // @results 'hogehogehogehogehoge'
   *   debug(fill({}, 2, 5));
   *   // @results {'0': 2, '1': 2, '2': 2, '3': 2, '4': 2}
   *   debug(fill({a: 1, b: 2, c: 3}, null));
   *   // @results {a: null, b: null, c: null}
   *   debug(fill(100, 5, 10));
   *   // @results 5555555555100
   *
   *
   * @param  {Array|String|Object|Number|*}  defaults  The default value.
   *                                                   This object value does
   *                                                     not replace. use
   *                                                     returned value.
   * @param  {*}                             value     The value to fill
   *                                                     the object.
   * @param  {Number}                        count     The number of times to
   *                                                     fill the object.
   * @return {Array|String|Object|Number|*}            The result of filled.
   * @type  Function
   * @function
   * @static
   * @public
   */
  fill : function(defaults, value, count) {
    var result = null, args = arguments, i, j, val;
    if (args.length === 2) {
      count = value;
      value = defaults;
      switch (typeLikeOf(defaults)) {
        case 'string':
            defaults = '';
            break;
        case 'object':
            defaults = value;
            value = count;
            count = 0;
            break;
        case 'number':
            defaults = 0;
            break;
        case 'array':
            if (defaults.length === 1) {
              value = defaults[0];
            }
            defaults = [];
      }
    }
    if (isNumeric(count) || isObject(defaults)) {
      i = Math.floor(count - 0);
      switch (typeLikeOf(defaults)) {
        case 'array':
            result = arrayize(defaults);
            while (--i >= 0) {
              result[result.length] = value;
            }
            break;
        case 'string':
            result = stringify(defaults);
            val = stringify(value);
            while (--i >= 0) {
              result += val;
            }
            break;
        case 'object':
            result = {};
            each(defaults, function(v, k) {
              result[k] = value;
            });
            if (i) {
              j = 0;
              while (--i >= 0) {
                result[j++] = value;
              }
            }
            break;
        case 'number':
            result = ((defaults - 0) || 0).toString();
            val = Math.floor(Math.abs((value - 0) || 0)).toString();
            while (--i >= 0) {
              result = val + result;
            }
            result = result - 0;
            break;
        default:
            result = defaults;
      }
    }
    return result;
  },
  /**
   * Return a string that is joined by the object keys and values.
   *
   * Arguments can passed in any order.
   * (The first will be the `delimiter` as a string).
   *
   * If the `tail` is given as string
   *   then will be append the `tail` itself to string.
   *
   *
   * @example
   *   debug(implode({color: 'blue', margin: '5px'}, ':', ';', true));
   *   // @results 'color:blue;margin:5px;'
   *
   *
   * @example
   *   //
   *   // Arguments can passed in any order.
   *   // (The first will be the `delimiter` as a string).
   *   //
   *   debug(implode('+', {a: 1, b: 2, c: 3}, '*'));
   *   // @results 'a+1*b+2*c+3'
   *
   *
   * @example
   *   //
   *   // If the `tail` is given as string
   *   //  then will be append the `tail` itself to string.
   *   //
   *   debug(implode('>>', {a: 1, b: 2, c: 3}, '^', '==?'));
   *   // @results 'a>>1^b>>2^c>>3==?'
   *
   *
   * @param  {Object}   object      The target object.
   * @param  {String}  (delimiter)  The combining character of each
   *                                  property name and value.
   *                                  (default = ':').
   * @param  {String}  (separator)  The character string that
   *                                  will be combined by
   *                                  the following property and
   *                                  previous property.
   *                                  (default = ',').
   * @param  {Boolean} (tail)       If given "true" then will put
   *                                  `separator` to the end of the string.
   * @return {String}               The combined string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  implode : function(object/*[, delimiter[, separator[, tail]]]*/) {
    var
    result = '', ins = [], d, s, o, t, nop,
    args = arguments, len = args.length, i, params,
    defs = {
      delimiter : ':',
      separator : ','
    };
    for (i = 0; i < len; i++) {
      if (!o && isObject(args[i])) {
        o = args[i];
      } else if (!d && isString(args[i])) {
        d = args[i];
      } else if (!s && isString(args[i])) {
        s = args[i];
      } else if (isObject(o) && isString(d) && isString(s)) {
        t = args[i];
      } else if (!params && isObject(o) && isObject(args[i]) &&
                 (args[i].delimiter || args[i].separator || args[i].tail)) {
        params = args[i];
        d = d || stringify(params.delimiter, true);
        s = s || stringify(params.separator, true);
        t = t || params.tail;
      }
    }
    if (o && isObject(o)) {
      if (d === nop) {
        d = defs.delimiter;
      }
      if (s === nop) {
        s = defs.separator;
      }
      each(o, function(val, prop) {
        ins[ins.length] = prop + d + stringify(val);
      });
      result = ins.join(s);
      if (t) {
        result += isString(t) ? t : s;
      }
    }
    return result;
  },
  /**
   * Separate a string by specified delimiter and separator,
   *   then returns  a converted object.
   * This function works like the opposite "implode".
   *
   * @see Pot.Struct.implode
   *
   *
   * @example
   *   var string = 'color:blue;margin:5px;';
   *   var result = explode(string, ':', ';');
   *   debug(result);
   *   // @results {color: 'blue', margin: '5px'}
   *
   *
   * @example
   *   var string = 'foo=1&bar=2&baz=3';
   *   var result = explode(string, {delimiter: '=', separator: '&'});
   *   debug(result);
   *   // @results {foo: '1', bar: '2', baz: '3'}
   *
   *
   * @example
   *   var string = 'A : 1, B:2, C: 3;';
   *   var result = explode(string, {
   *         delimiter : /(?:\s*:\s*)/,
   *         separator : /(?:\s*[,;]\s*)/
   *   });
   *   debug(result);
   *   // @results {A: '1', B: '2', C: '3'}
   *
   *
   * @param  {String}          string      The subject string.
   * @param  {String|RegExp}  (delimiter)  The split character of each
   *                                         property name and value.
   *                                         (default = ':').
   * @param  {String|RegExp}  (separator)  The character string that
   *                                         will be split by
   *                                         the following property and
   *                                         previous property.
   *                                         (default = ',').
   * @return {Object}                      The result object that
   *                                         separated from a string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  explode : function(string/*[, delimiter[, separator]]*/) {
    var
    result = {}, args = arguments, argn = args.length, nop,
    s, delim, sep, n, params,
    defaults = {
      delimiter : ':',
      separator : ','
    };
    for (n = 0; n < argn; n++) {
      if (isObject(args[n]) &&
          (args[n].delimiter || args[n].separator)) {
        params = args[n];
        delim = delim || params.delimiter;
        sep   = sep   || params.separator;
      } else if (!s && isString(args[n])) {
        s = args[n];
      } else if (!delim && (isString(args[n]) || isRegExp(args[n]))) {
        delim = args[n];
      } else if (!sep && (isString(args[n]) || isRegExp(args[n]))) {
        sep = args[n];
      }
    }
    s = stringify(s);
    if (s) {
      if (delim === nop) {
        delim = defaults.delimiter;
      }
      if (sep === nop) {
        sep = defaults.separator;
      }
      each(s.split(sep), function(unit) {
        var parts, i, len;
        if (unit) {
          parts = unit.split(delim);
          len = parts.length;
          i = 0;
          do {
            result[stringify(parts[i++], true)] = parts[i++];
          } while (i < len);
        }
      });
    }
    return result;
  },
  /**
   * Joins the all arguments to a string.
   *
   *
   * @example
   *   debug(glue([1, 2, 3, 4, 5]));
   *   // @results '12345'
   *   debug(glue('foo', 'bar', 'baz'));
   *   // @results 'foobarbaz'
   *   debug(glue(1, [2, 3, ['foo']], ['bar', 'baz']));
   *   // @results '123foobarbaz'
   *
   *
   * @param  {Array|...*}  args  The target items.
   * @return {String}            The joined string from array.
   * @type  Function
   * @function
   * @static
   * @public
   */
  glue : function() {
    var result = '', args = arguments, arg, flatten = Pot.Collection.flatten;
    switch (args.length) {
      case 0:
          break;
      case 1:
          arg = args[0];
          if (isArray(arg)) {
            result = flatten(arg).join('');
          } else if (isObject(arg) || isArrayLike(arg)) {
            each(arg, function(v) {
              result += stringify(v);
            });
          } else {
            result = stringify(arg);
          }
          break;
      default:
          result = flatten(arrayize(args)).join('');
    }
    return result;
  },
  /**
   * Clears the object that is any types.
   *
   *
   * @example
   *   var obj = {foo: 1, bar: 2, baz: 3};
   *   clearObject(obj);
   *   debug(obj);
   *   // @results  obj = {}
   *   var arr = [1, 2, 3, 4, 5];
   *   clearObject(arr);
   *   debug(arr);
   *   // @results  arr = []
   *
   *
   * @param  {*}   o   A target object.
   * @return {*}       Return argument `o`.
   * @type  Function
   * @function
   * @static
   * @public
   */
  clearObject : function(o) {
    var p;
    if (o) {
      if (isArrayLike(o)) {
        p = o.length;
        while (--p >= 0) {
          try {
            delete o[p];
          } catch (e) {}
        }
        try {
          o.length = 0;
        } catch (e) {}
      } else if (isObject(o)) {
        for (p in o) {
          try {
            delete o[p];
          } catch (e) {}
        }
      } else {
        o = null; // noop
      }
    }
    return o;
  }
});

// Update Pot object.
Pot.update({
  invoke      : Pot.Struct.invoke,
  clone       : Pot.Struct.clone,
  bind        : Pot.Struct.bind,
  partial     : Pot.Struct.partial,
  keys        : Pot.Struct.keys,
  values      : Pot.Struct.values,
  tuple       : Pot.Struct.tuple,
  unzip       : Pot.Struct.unzip,
  pairs       : Pot.Struct.pairs,
  count       : Pot.Struct.count,
  first       : Pot.Struct.first,
  firstKey    : Pot.Struct.firstKey,
  last        : Pot.Struct.last,
  lastKey     : Pot.Struct.lastKey,
  contains    : Pot.Struct.contains,
  remove      : Pot.Struct.remove,
  removeAll   : Pot.Struct.removeAll,
  removeAt    : Pot.Struct.removeAt,
  equals      : Pot.Struct.equals,
  reverse     : Pot.Struct.reverse,
  flip        : Pot.Struct.flip,
  shuffle     : Pot.Struct.shuffle,
  fill        : Pot.Struct.fill,
  implode     : Pot.Struct.implode,
  explode     : Pot.Struct.explode,
  glue        : Pot.Struct.glue,
  clearObject : Pot.Struct.clearObject
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of DateTime.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * DateTime utilities.
   *
   * @param  {*}       x  The timestamp.
   * @return {Number}     The timestamp at that time.
   *
   * @name Pot.DateTime
   * @type Function
   * @class
   * @function
   * @static
   * @public
   */
  DateTime : function(x) {
    return +new Date(x);
  }
});

update(Pot.DateTime, {
  /**
   * @lends Pot.DateTime
   */
  /**
   * Get the current time as milliseconds.
   *
   *
   * @example
   *   var time = now(); // equals (new Date()).getTime();
   *   debug(time); // 1323446177282
   *
   *
   * @return {Number} Return the current time as milliseconds.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  now : now,
  /**
   * Get the current UNIX timestamp.
   *
   * @return {Number} Return the current UNIX timestamp.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  time : function() {
    return Math.round(now() / 1000);
  },
  /**
   * Return the formatted date.
   *
   * That works the same as PHP's date function probably.
   * (Refer the manual.)
   * @link http://php.net/function.date
   *
   * Use a backslash '\\' if escape the next character.
   *
   * <pre>
   * ------------------------------------------------
   * Extended formats:
   *   - J : Japanese weekday (日 ～ 土)
   *   - o : Old Japanese Month (霜月, 水無月, etc.)
   * ------------------------------------------------
   * </pre>
   *
   *
   * @example
   *   var result = Pot.DateTime.format('Y-m-d H:i:s');
   *   debug(result);
   *   // @results '2011-06-07 01:25:17'
   *
   *
   * @example
   *   var result = Pot.DateTime.format('Y/m/d (J) H:i [\\o=o]');
   *   debug(result);
   *   // @results '2011/06/08 (水) 11:30 [o=水無月]'
   *
   *
   * @example
   *   var result = Pot.DateTime.format(Pot.DateTime.format.RFC2822);
   *   debug(result);
   *   // @results 'Wed, 08 Jun 2011 02:34:21 +0900'
   *
   *
   * @param  {String}          format   A format string. (e.g. 'Y-m-d').
   * @param  {Date|Number|*}   (date)   (Optional) The specific timestamp.
   * @return {String}                   Return the formatted date string.
   *
   * @name  Pot.DateTime.format
   * @type  Function
   * @class
   * @function
   * @static
   * @public
   */
  format : (function() {
    /**
     * @private
     * @ignore
     */
    var DateTimeFormatter = function() {};
    update(DateTimeFormatter, {
      /**
       * @private
       * @ignore
       */
      TIMEZONE_MAPS : {
        GMT  :   0,               // Greenwich Mean
        UTC  :   0,               // Universal (Coordinated)
        WET  :   0,               // Western European
        WAT  :  -1 * 3600,        // West Africa
        AT   :  -2 * 3600,        // Azores
        NFT  :  -3 * 3600 - 1800, // Newfoundland
        AST  :  -4 * 3600,        // Atlantic Standard
        EST  :  -5 * 3600,        // Eastern Standard
        CST  :  -6 * 3600,        // Central Standard
        MST  :  -7 * 3600,        // Mountain Standard
        PST  :  -8 * 3600,        // Pacific Standard
        YST  :  -9 * 3600,        // Yukon Standard
        HST  : -10 * 3600,        // Hawaii Standard
        CAT  : -10 * 3600,        // Central Alaska
        AHST : -10 * 3600,        // Alaska-Hawaii Standard
        NT   : -11 * 3600,        // Nome
        IDLW : -12 * 3600,        // International Date Line West
        CET  :  +1 * 3600,        // Central European
        MET  :  +1 * 3600,        // Middle European
        MEWT :  +1 * 3600,        // Middle European Winter
        SWT  :  +1 * 3600,        // Swedish Winter
        FWT  :  +1 * 3600,        // French Winter
        EET  :  +2 * 3600,        // Eastern Europe, USSR Zone 1
        BT   :  +3 * 3600,        // Baghdad, USSR Zone 2
        IT   :  +3 * 3600 + 1800, // Iran
        ZP4  :  +4 * 3600,        // USSR Zone 3
        ZP5  :  +5 * 3600,        // USSR Zone 4
        IST  :  +5 * 3600 + 1800, // Indian Standard
        ZP6  :  +6 * 3600,        // USSR Zone 5
        SST  :  +7 * 3600,        // South Sumatra, USSR Zone 6
        WAST :  +7 * 3600,        // West Australian Standard
        JT   :  +7 * 3600 + 1800, // Java
        CCT  :  +8 * 3600,        // China Coast, USSR Zone 7
        JST  :  +9 * 3600,        // Japan Standard, USSR Zone 8
        CAST :  +9 * 3600 + 1800, // Central Australian Standard
        EAST : +10 * 3600,        // Eastern Australian Standard
        GST  : +10 * 3600,        // Guam Standard, USSR Zone 9
        NZT  : +12 * 3600,        // New Zealand
        NZST : +12 * 3600,        // New Zealand Standard
        IDLE : +12 * 3600         // International Date Line East
      },
      /**
       * @private
       * @ignore
       */
      WEEK : {
        en : [
          'Sunday',    'Monday',   'Tuesday',
          'Wednesday', 'Thursday', 'Friday',  'Saturday'
        ],
        ja : [
          '\u65e5', // 日
          '\u6708', // 月
          '\u706b', // 火
          '\u6c34', // 水
          '\u6728', // 木
          '\u91d1', // 金
          '\u571f'  // 土
        ]
      },
      /**
       * @private
       * @ignore
       */
      MONTH : {
        en : [
          'January',   'February', 'March',    'April',
          'May',       'June',     'July',     'August',
          'September', 'October',  'November', 'December'
        ],
        ja : [
          '\u7766\u6708',       // 睦月
          '\u5982\u6708',       // 如月
          '\u5f25\u751f',       // 弥生
          '\u536f\u6708',       // 卯月
          '\u7690\u6708',       // 皐月
          '\u6c34\u7121\u6708', // 水無月
          '\u6587\u6708',       // 文月
          '\u8449\u6708',       // 葉月
          '\u9577\u6708',       // 長月
          '\u795e\u7121\u6708', // 神無月
          '\u971c\u6708',       // 霜月
          '\u5e2b\u8d70'        // 師走
        ]
      },
      /**
       * @private
       * @ignore
       */
      DATE_SUFFIX : [
        'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
        'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
        'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'st'
      ],
      /**
       * @private
       * @ignore
       */
      TRANSLATE_PATTERN : /(?:\\.|[a-zA-Z])/g
    });
    DateTimeFormatter.prototype = update(DateTimeFormatter.prototype, {
      /**
       * @private
       * @ignore
       */
      format : function(pattern, date) {
        var result = '', that = this, t, fm, d, o, tr;
        if (!isString(pattern)) {
          t = pattern;
          pattern = date;
          date = t;
        }
        fm = stringify(pattern);
        if (isDate(date)) {
          d = date;
        } else if (isNumeric(date) || (date && isString(date))) {
          d = new Date(date);
        } else {
          d = new Date();
        }
        if (fm) {
          o = {
            self     : d,
            year     : d.getFullYear(),
            month    : d.getMonth(),
            date     : d.getDate(),
            day      : d.getDay(),
            hours    : d.getHours(),
            minutes  : d.getMinutes(),
            seconds  : d.getSeconds(),
            mseconds : d.getMilliseconds(),
            timezone : d.getTimezoneOffset(),
            time     : d.getTime()
          };
          /**@ignore*/
          tr = function(m) {
            return that.translate(m, o);
          };
          result = fm.replace(DateTimeFormatter.TRANSLATE_PATTERN, tr);
        }
        return result;
      },
      /**
       * @private
       * @ignore
       */
      translate : function(c, d) {
        switch (c.charAt(0)) {
            case '\\': return c.charAt(1);
            case 'A': return this.meridiem(d.hours).toUpperCase();
            case 'a': return this.meridiem(d.hours);
            case 'c': return this.format(Pot.DateTime.format.ATOM);
            case 'D': return DateTimeFormatter.WEEK.en[d.day].substr(0, 3);
            case 'd': return this.padding(d.date);
            case 'F': return DateTimeFormatter.MONTH.en[d.month];
            case 'G': return d.hours;
            case 'g': return this.to12Hour(d.hours);
            case 'H': return this.padding(d.hours);
            case 'h': return this.padding(this.to12Hour(d.hours));
            case 'i': return this.padding(d.minutes);
            case 'J': return DateTimeFormatter.WEEK.ja[d.day];
            case 'j': return d.date;
            case 'L': return String(this.isLeapYear(d.year) ? 1 : 0);
            case 'l': return DateTimeFormatter.WEEK.en[d.day];
            case 'M': return DateTimeFormatter.MONTH.en[d.month].substr(0, 3);
            case 'm': return this.padding(d.month + 1);
            case 'N': return this.isoDay(d.day);
            case 'n': return d.month + 1;
            case 'o': return DateTimeFormatter.MONTH.ja[d.month];
            case 'O': return this.getTimezone(d.timezone);
            case 'P': return this.getTimezone(d.timezone, true);
            case 'r': return this.format(Pot.DateTime.format.RFC2822);
            case 'S': return DateTimeFormatter.DATE_SUFFIX[d.date - 1];
            case 's': return this.padding(d.seconds);
            case 'T': return this.getTimezoneName(d.timezone);
            case 't': return this.lastDayOfMonth(d.self);
            case 'U': return Math.round(d.time / 1000);
            case 'u': return this.padding(d.mseconds, 6);
            case 'w': return d.day;
            case 'Y': return d.year;
            case 'y': return d.year.toString().substr(2, 2);
            case 'z': return this.countDate(d.year, d.month, d.date);
            case 'Z': return this.getTimezoneSec(d.timezone);
            default : break;
        }
        return c;
      },
      /**
       * @private
       * @ignore
       */
      padding : function(n, size, ch) {
        var s = String(n), len = (size || 2) - 0, c = String(ch || 0);
        while (s.length < len) {
          s = c + s;
        }
        return s;
      },
      /**
       * @private
       * @ignore
       */
      to12Hour : function(hours) {
        return (hours > 12) ? hours - 12 : hours;
      },
      /**
       * @private
       * @ignore
       */
      meridiem : function(hours) {
        return (((hours - 0) < 12) ? 'a' : 'p') + 'm';
      },
      /**
       * @private
       * @ignore
       */
      isoDay : function(day) {
        return ((day - 0) === 0) ? '7' : day;
      },
      /**
       * @private
       * @ignore
       */
      lastDayOfMonth : function(date) {
        var t = new Date(date.getFullYear(), date.getMonth() + 1, 1);
        t.setTime(t.getTime() - 1);
        return t.getDate();
      },
      /**
       * @private
       * @ignore
       */
      isLeapYear : function(year) {
        var d = new Date(year, 0, 1), sum = 0, i;
        for (i = 0; i < 12; i++) {
          d.setMonth(i);
          sum += this.lastDayOfMonth(d);
        }
        return sum != 365;
      },
      /**
       * @private
       * @ignore
       */
      countDate : function(year, month, date) {
        var d = new Date(year, 0, 1), sum = -1, i, max = (month - 0);
        for (i = 0; i < max; i++) {
          d.setMonth(i);
          sum += this.lastDayOfMonth(d);
        }
        return sum + date;
      },
      /**
       * @private
       * @ignore
       */
      getTimezone : function(offset, colon) {
        var o = (offset - 0) || 0,
            a = Math.abs(o),
            sign = (o < 0) ? '+' : '-';
        return [
          sign,
          this.padding(Math.floor(a / 60)),
          colon ? ':' : '',
          this.padding(a % 60)
        ].join('');
      },
      /**
       * @private
       * @ignore
       */
      getTimezoneSec : function(offset) {
        var o = (offset - 0) || 0;
        return ((o < 0) ? '' : '-') + Math.abs(o * 60);
      },
      /**
       * @private
       * @ignore
       */
      getTimezoneName : function(offset) {
        var result, name,
            maps = DateTimeFormatter.TIMEZONE_MAPS;
            def = maps[1],
            o = (offset - 0) || 0;
            time = Math.floor(-o / 60 * 3600);
        if (time === 0) {
          result = def;
        } else {
          for (name in maps) {
            if (maps[name] === time) {
              result = name;
              break;
            }
          }
        }
        return result || def;
      }
    });
    return update(function(/*format[, date]*/) {
      var d = new DateTimeFormatter();
      return d.format.apply(d, arguments);
    }, {
      /**
       * @lends Pot.DateTime.format
       */
      /**
       * A constant string of the date format for ATOM.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      ATOM : 'Y-m-d\\TH:i:sP',
      /**
       * A constant string of the date format for COOKIE.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      COOKIE : 'l, d-M-y H:i:s T',
      /**
       * A constant string of the date format for ISO8601.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      ISO8601 : 'Y-m-d\\TH:i:sO',
      /**
       * A constant string of the date format for RFC822.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      RFC822 : 'D, d M y H:i:s O',
      /**
       * A constant string of the date format for RFC850.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      RFC850 : 'l, d-M-y H:i:s T',
      /**
       * A constant string of the date format for RFC1036.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      RFC1036 : 'D, d M y H:i:s O',
      /**
       * A constant string of the date format for RFC1123.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      RFC1123 : 'D, d M Y H:i:s O',
      /**
       * A constant string of the date format for RFC2822.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      RFC2822 : 'D, d M Y H:i:s O',
      /**
       * A constant string of the date format for RFC3339.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      RFC3339 : 'Y-m-d\\TH:i:sP',
      /**
       * A constant string of the date format for RSS.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      RSS : 'D, d M Y H:i:s O',
      /**
       * A constant string of the date format for W3C.
       *
       * @type  String
       * @const
       * @static
       * @public
       */
      W3C : 'Y-m-d\\TH:i:sP'
    });
  }()),
  /**
   * Return the formatted relative date string.
   *
   *
   * @example
   *   debug(Pot.prettyDate('Fri Mar 16 2012 06:42:50 GMT+0900'));
   *   // @results e.g. 'just now'
   *   debug(Pot.prettyDate('Fri Mar 16 2012 08:42:50 GMT+0900'));
   *   // @results e.g. 'an hour ago'
   *   debug(Pot.prettyDate('Fri Mar 16 2012 00:42:50 GMT+0900'));
   *   // @results e.g. '6 hours ago'
   *
   *
   * @example
   *   debug(Pot.prettyDate(new Date().getTime() + 10));
   *   // @results e.g. 'just now'
   *   debug(Pot.prettyDate(new Date().getTime() - 1000 * 60 - 10));
   *   // @results e.g. 'a minute ago'
   *   debug(Pot.prettyDate(new Date().getTime() - 1000 * 60 * 60 - 10));
   *   // @results e.g. 'an hour ago'
   *   debug(Pot.prettyDate(new Date().getTime() - 1000 * 60 * 60 * 24 - 10));
   *   // @results e.g. 'yesterday'
   *   debug(
   *     Pot.prettyDate(new Date().getTime() - 1000 * 60 * 60 * 24 * 7 - 10)
   *   );
   *   // @results e.g. 'last week'
   *   debug(Pot.prettyDate(new Date().getTime() + 1000 * 60 + 10));
   *   // @results e.g. 'a minute from now'
   *   debug(Pot.prettyDate(new Date().getTime() + 1000 * 60 * 60 + 10));
   *   // @results e.g. 'an hour from now'
   *   debug(Pot.prettyDate(new Date().getTime() + 1000 * 60 * 60 * 24 + 10));
   *   // @results e.g. 'tomorrow'
   *   debug(
   *     Pot.prettyDate(new Date().getTime() + 1000 * 60 * 60 * 24 * 7 + 10)
   *   );
   *   // @results e.g. 'next week'
   *
   *
   * @param  {Date|Number|*}    date   The specific timestamp.
   * @param  {String}          (lang)  (optional)The language (default='en').
   * @return {String}                  Return the formatted date string.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  prettyDate : (function() {
    var
    MINUTE  = 60,
    HOUR    = 60 * MINUTE,
    DAY     = 24 * HOUR,
    WEEK    = 7 * DAY,
    MONTH   = 4 * WEEK,
    YEAR    = 365 * DAY,
    CENTURY = 100 * YEAR,
    isJa    = /^j[ap]/i,
    suffix  = {
      past   : {en : 'ago',      ja : '\u524d'}, // 前
      future : {en : 'from now', ja : '\u5f8c'}  // 後
    },
    glue    = {en : ' ', ja : ''},
    formats = [
      [
        MINUTE,
        {en : 'just now', ja : '\u305f\u3063\u305f\u4eca'}, // たった今
        1
      ],
      [
        2 * MINUTE,
        {
          en : 'a minute ' + suffix.past.en,
          ja : '1\u5206' + suffix.past.ja    // 1分
        },
        {
          en : 'a minute ' + suffix.future.en,
          ja : '1\u5206' + suffix.future.ja  // 1分
        }
      ],
      [
        HOUR,
        {en : 'minutes', ja : '\u5206'}, // 分
        MINUTE
      ],
      [
        2 * HOUR,
        {
          en : 'an hour ' + suffix.past.en,
          ja : '1\u6642\u9593' + suffix.past.ja // 1時間
        },
        {
          en : 'an hour ' + suffix.future.en,
          ja : '1\u6642\u9593' + suffix.future.ja // 1時間
        }
      ],
      [
        DAY,
        {en : 'hours', ja : '\u6642\u9593'}, // 時間
        HOUR
      ],
      [
        2 * DAY,
        {en : 'yesterday', ja : '\u6628\u65e5'}, // 昨日
        {en : 'tomorrow',  ja : '\u660e\u65e5'}  // 明日
      ],
      [
        WEEK,
        {en : 'days', ja : '\u65e5'}, // 日
        DAY
      ],
      [
        2 * WEEK,
        {en : 'last week', ja : '\u5148\u9031'}, // 先週
        {en : 'next week', ja : '\u6765\u9031'}  // 来週
      ],
      [
        MONTH,
        {en : 'weeks', ja : '\u9031\u9593'}, // 週間
        WEEK
      ],
      [
        2 * MONTH,
        {en : 'last month', ja : '\u5148\u6708'}, // 先月
        {en : 'next month', ja : '\u6765\u6708'}  // 来月
      ],
      [
        YEAR,
        {en : 'months', ja : '\u30f6\u6708'}, // ヶ月
        MONTH
      ],
      [
        2 * YEAR,
        {en : 'last year', ja : '\u53bb\u5e74'}, // 去年
        {en : 'next year', ja : '\u6765\u5e74'}  // 来年
      ],
      [
        CENTURY,
        {en : 'years', ja : '\u5e74'}, // 年
        YEAR
      ],
      [
        2 * CENTURY,
        {en : 'last century', ja : '\u524d\u4e16\u7d00'}, // 前世紀
        {en : 'next century', ja : '\u6765\u4e16\u7d00'}  // 来世紀
      ],
      [
        Number.MAX_VALUE,
        {en : 'centuries', ja : '\u4e16\u7d00'}, // 世紀
        CENTURY
      ]
    ],
    /**@ignore*/
    relativeDate = function(date, language) {
      var result = '', d, seconds, tail, index, i = 0, f,
          lang = isJa.test(language) ? 'ja' : 'en';
      if (isDate(date)) {
        d = date;
      } else if (isNumeric(date) || (date && isString(date))) {
        d = new Date(date);
      } else {
        d = new Date();
      }
      seconds = (new Date - d.getTime()) / 1000;
      if (seconds < 0) {
        seconds = Math.abs(seconds);
        tail = suffix.future[lang];
        index = 2;
      } else {
        tail = suffix.past[lang];
        index = 1;
      }
      while ((f = formats[i++])) {
        if (seconds < f[0]) {
          if (isObject(f[2])) {
            result = f[index][lang];
          } else if (i > 1) {
            result = [
              Math.floor(seconds / f[2]),
              f[1][lang],
              tail
            ].join(glue[lang]);
          } else {
            result = f[1][lang];
          }
          break;
        }
      }
      return result;
    };
    each(['en', 'ja'], function(lang) {
      /**@ignore*/
      relativeDate[lang] = function(date) {
        return relativeDate(date, lang);
      };
    });
    return relativeDate;
  }())
});

// Update Pot object.
Pot.update({
  time       : Pot.DateTime.time,
  date       : Pot.DateTime.format,
  prettyDate : Pot.DateTime.prettyDate
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Complex.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Complex.
   * Comp + Lex.
   * Math and Numeric, lexical compare utilities.
   *
   * @name Pot.Complex
   * @type Object
   * @class
   * @static
   * @public
   */
  Complex : {}
});

update(Pot.Complex, {
  /**
   * @lends Pot.Complex
   */
  /**
   * Cast the value to numerical value.
   * All type of object can be convert.
   *
   *
   * @example
   *   debug(numeric(0));               // 0
   *   debug(numeric(1234567890));      // 1234567890
   *   debug(numeric(new Number(25)));  // 25
   *   debug(numeric(null));            // 0
   *   debug(numeric((void 0)));        // 0
   *   debug(numeric(true));            // 1
   *   debug(numeric(false));           // 0
   *   debug(numeric('abc'));           // 2748
   *   debug(numeric('0xFF'));          // 255
   *   debug(numeric('1e8'));           // 100000000
   *   debug(numeric('10px'));          // 10
   *   debug(numeric('1,000,000ms.'));  // 1000000
   *   debug(numeric('-512 +1'));       // -512
   *   debug(numeric([]));              // 0
   *   debug(numeric(['hoge']));        // 1
   *   debug(numeric(new Date()));      // 1323446177282
   *
   *
   * @param  {String|*}   value    The target value to convert numeric value.
   * @param  {Number}   (defaults) The default value if `value` is not numeric.
   * @return {Number}              Return the numeric value.
   * @type Function
   * @function
   * @static
   * @public
   */
  numeric : numeric,
  /**
   * Returns a random number. (supports float)
   *
   *
   * @example
   *   debug(rand(0, 1));
   *   // @results  1  (first tried)
   *
   * @example
   *   debug(rand(5, 5));
   *   // @results  5
   *
   * @example
   *   debug(rand(10, 1));
   *   // @results  7  (first tried)
   *
   * @example
   *   debug(rand(2.5, 5.75));
   *   // @results  4.64  (first tried)
   *
   * @example
   *   debug(rand(1, 1.8765));
   *   // @results  1.5087  (first tried)
   *
   *
   * @param  {Number|String}  (min)  Minimum or maximum numbers
   * @param  {Number|String}  (max)  Maximum or minimum numbers
   * @return {Number|String}         Random number between
   *                                   min and max.
   *                                   (including min and max)
   * @class
   * @name  Pot.Complex.rand
   * @type  Function
   * @function
   * @static
   * @public
   */
  rand : update(function(min, max) {
    var result = 0, args = arguments, me = Pot.Complex.rand,
        t, n, x, scale, forString = false;
    if (!me.getScale) {
      /**@ignore*/
      me.getScale = function(a) {
        var dot = '.', s = a.toString();
        return ~s.indexOf(dot) ? s.split(dot).pop().length : 0;
      };
    }
    if (isString(min) && isString(max)) {
      forString = true;
      min = min.charCodeAt(0);
      max = max.charCodeAt(0);
    }
    switch (args.length) {
      case 0: // Int32
          x = 0x7FFFFFFF;
          n = ~x;
          break;
      case 1:
          n = 0;
          x = min - 0;
          break;
      default:
          n = min - 0;
          x = max - 0;
    }
    if (n > x) {
      t = x;
      x = n;
      n = t;
    }
    if (isNaN(n)) {
      if (isNaN(x)) {
        result = 0;
      } else {
        result = x;
      }
    } else if (isNaN(x)) {
      if (isNaN(n)) {
        result = 0;
      } else {
        result = n;
      }
    } else if (!isFinite(n)) {
      if (isFinite(x)) {
        result = x;
      } else {
        result = 0;
      }
    } else if (!isFinite(x)) {
      if (isFinite(n)) {
        result = n;
      } else {
        result = 0;
      }
    } else {
      scale = Math.max(me.getScale(n), me.getScale(x));
      if (scale) {
        result = (Math.random() * (x - n) + n).toFixed(scale);
      } else {
        result = Math.floor(Math.random() * (x - n + 1)) + n;
      }
    }
    if (forString) {
      result = fromUnicode(result);
    } else {
      result = result - 0;
    }
    return result;
  }, (function() {
    var ALPHAS    = LOWER_ALPHAS + UPPER_ALPHAS,
        ALPHANUMS = ALPHAS + DIGITS;
    /**@ignore*/
    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    return {
      /**
       * @lends Pot.Complex.rand
       */
      /**
       * Returns the random alphabet(s).
       *
       * @param  {Number}  (length)  Length.
       * @return {String}            The random alphabet(s).
       *
       * @name Pot.Complex.rand.alpha
       * @class
       * @type  Function
       * @function
       * @static
       * @public
       */
      alpha : update(function(length) {
        var result = '', c, len, max;
        len = isNumeric(length) ? length - 0 : 1;
        if (len > 0) {
          c = [];
          max = ALPHAS.length - 1;
          while (--len >= 0) {
            c[c.length] = ALPHAS.charAt(randInt(0, max));
          }
          result = c.join('');
        }
        return result;
      }, {
        /**
         * @lends Pot.Complex.rand.alpha
         */
        /**
         * Returns the random alphabet(s) as lowercase.
         *
         * @param  {Number}  (length)  Length.
         * @return {String}            The random alphabet(s).
         *
         * @type  Function
         * @function
         * @static
         * @public
         */
        lower : function(/*[length]*/) {
          return Pot.Complex.rand.alpha.apply(null, arguments).toLowerCase();
        },
        /**
         * Returns the random alphabet(s) as uppercase.
         *
         * @param  {Number}  (length)  Length.
         * @return {String}            The random alphabet(s).
         *
         * @type  Function
         * @function
         * @static
         * @public
         */
        upper : function(/*[length]*/) {
          return Pot.Complex.rand.alpha.apply(null, arguments).toUpperCase();
        }
      }),
      /**
       * @lends Pot.Complex.rand
       */
      /**
       * Returns the random alphabet(s) and digit(s).
       *
       * @param  {Number}  (length)  Length.
       * @param  {Boolean} (valid)   Whether the first character to
       *                               specify a alphabet.
       * @return {String}            The random alphabet(s) and digit(s).
       *
       * @name Pot.Complex.rand.alnum
       * @class
       * @type  Function
       * @function
       * @static
       * @public
       */
      alnum : update(function(length, valid) {
        var result = '', len, max, c;
        len = isNumeric(length) ? length - 0 : 1;
        if (len > 0) {
          c = [];
          max = ALPHANUMS.length - 1;
          if (valid) {
            c[c.length] = Pot.Complex.rand.alpha(1);
            len--;
          }
          while (--len >= 0) {
            c[c.length] = ALPHANUMS.charAt(randInt(0, max));
          }
          result = c.join('');
        }
        return result;
      }, {
        /**
         * @lends Pot.Complex.rand.alnum
         */
        /**
         * Returns the random alphabet(s) and digit(s) as lowercase.
         *
         * @param  {Number}  (length)  Length.
         * @param  {Boolean} (valid)   Whether the first character to
         *                               specify a alphabet.
         * @return {String}            The random alphabet(s) and digit(s).
         *
         * @type  Function
         * @function
         * @static
         * @public
         */
        lower : function(/*[length[, valid]]*/) {
          return Pot.Complex.rand.alnum.apply(null, arguments).toLowerCase();
        },
        /**
         * Returns the random alphabet(s) and digit(s) as uppercase.
         *
         * @param  {Number}  (length)  Length.
         * @param  {Boolean} (valid)   Whether the first character to
         *                               specify a alphabet.
         * @return {String}            The random alphabet(s) and digit(s).
         *
         * @type  Function
         * @function
         * @static
         * @public
         */
        upper : function(/*[length[, valid]]*/) {
          return Pot.Complex.rand.alnum.apply(null, arguments).toUpperCase();
        }
      }),
      /**
       * @lends Pot.Complex.rand
       */
      /**
       * Returns the random color part.
       *
       * @param  {Boolean}  (addSharp)  (Optional) Whether add the
       *                                  sharp '#' to prefix.
       * @return {String}               The random color part.
       *
       * @name Pot.Complex.rand.color
       * @class
       * @type  Function
       * @function
       * @static
       * @public
       */
      color : update(function(addSharp) {
        var col = Math.floor(Math.random() * 0xFFFFFF).toString(16);
        while (col.length < 6) {
          col += Math.floor(Math.random() * 0xF).toString(16);
        }
        while (col.length > 6) {
          col = col.substring(1);
        }
        return (addSharp ? '#' : '') + col;
      }, {
        /**
         * @lends Pot.Complex.rand.color
         */
        /**
         * Returns the random color part as lowercase.
         *
         * @param  {Boolean}  (addSharp)  (Optional) Whether add the
         *                                  sharp '#' to prefix.
         * @return {String}               The random color part.
         *
         * @type  Function
         * @function
         * @static
         * @public
         */
        lower : function(/*[addSharp]*/) {
          return Pot.Complex.rand.color.apply(null, arguments).toLowerCase();
        },
        /**
         * Returns the random color part as uppercase.
         *
         * @param  {Boolean}  (addSharp)  (Optional) Whether add the
         *                                  sharp '#' to prefix.
         * @return {String}               The random color part.
         *
         * @type  Function
         * @function
         * @static
         * @public
         */
        upper : function(/*[addSharp]*/) {
          return Pot.Complex.rand.color.apply(null, arguments).toUpperCase();
        }
      }),
      /**
       * @lends Pot.Complex.rand
       */
      /**
       * Returns a string that converted by random case-sensitive of
       *   the alphabet in a given string.
       *
       *
       * @example
       *   var s = 'd41d8cd98f00b204e9800998ecf8427e';
       *   debug(rand.caseOf(s));
       *   // @results
       *   // e.g. 'D41D8Cd98F00b204E9800998Ecf8427e'
       *
       *
       * @param  {String}  string  Target string.
       * @return {String}          The result string.
       *
       * @name Pot.Complex.rand.caseOf
       * @class
       * @type  Function
       * @function
       * @static
       * @public
       */
      caseOf : function(string) {
        var result = '', s, i, len, c;
        s = stringify(string);
        if (s) {
          len = s.length;
          for (i = 0; i < len; i++) {
            c = s.charAt(i);
            if ((c >= 'a' && c <= 'z') ||
                (c >= 'A' && c <= 'Z')) {
              if (Math.random() * 10 >>> 0 < 5) {
                c = c.toLowerCase();
              } else {
                c = c.toUpperCase();
              }
            }
            result += c;
          }
        }
        return result;
      }
    };
  })()),
  /**
   * @lends Pot.Complex
   */
  /**
   * Return the value that limited in the range of
   *  maximum value from minimum value.
   *
   *
   * @example
   *   var result = limit(5, 10, 50);
   *   debug(result);
   *   // @results 10
   *
   * @example
   *   var result = limit(80, 10, 50);
   *   debug(result);
   *   // @results 50
   *
   * @example
   *   var result = limit(5, 2, 8);
   *   debug(result);
   *   // @results 5
   *
   * @example
   *   var result = limit(-5, -10, -50);
   *   debug(result);
   *   // @results -10
   *
   * @example
   *   var result = limit(-80, -10, -50);
   *   debug(result);
   *   // @results -50
   *
   * @example
   *   var result = limit('F', 'A', 'C');
   *   debug(result);
   *   // @results 'C'
   *
   * @example
   *   var result = limit('b', 'a', 'z');
   *   debug(result);
   *   // @results 'b'
   *
   * @example
   *   var result = limit(1, 2, 4, 5, 10, 20);
   *   debug(result);
   *   // @results 2
   *
   * @example
   *   var result = limit(100, 2, 4, 5, 10, 20);
   *   debug(result);
   *   // @results 20
   *
   *
   * @param  {Number|String|*}  x    A target value.
   * @param  {Number|String|*}  min  The minimum value, or maximum value.
   * @param  {Number|String|*}  max  The maximum value, or minimum value.
   * @return {Number|String|*}       The value in the range of
   *                                   `max` from `min`.
   * @type  Function
   * @function
   * @static
   * @public
   */
  limit : function limit(x, min, max) {
    var result, tmp, args = arguments, values;
    switch (args.length) {
      case 0:
          result = void 0;
          break;
      case 1:
          result = x;
          break;
      case 2:
          if (x < min) {
            result = min;
          } else {
            result = x;
          }
          break;
      case 3:
          if (min > max) {
            tmp = min;
            min = max;
            max = tmp;
          }
          if (x < min) {
            result = min;
          } else if (x > max) {
            result = max;
          } else {
            result = x;
          }
          break;
      default:
          values = arrayize(args, 1);
          min = Math.min.apply(null, values);
          max = Math.max.apply(null, values);
          result = limit(x, min, max);
    }
    return result;
  },
  /**
   * Convert to the base 2 to 62 string from the base x string.
   * That can work for big scale integers.
   * The maximum base number is 62.
   * The base number '0' will be not converted.
   *
   *
   * @example
   *   var value = 'FFFFFFFF';
   *   var result = convertToBase(value, 16, 10);
   *   debug(result);
   *   // @results  result = '4294967295'
   *
   *
   * @example
   *   var value = '9223372036854775807';
   *   var result = convertToBase(value, 10, 16);
   *   debug(result);
   *   // @results  result = '7FFFFFFFFFFFFFFF'
   *
   *
   * @example
   *   var value = '11010100010011011010011101111' +
   *               '10110011001101101100111001101';
   *   var result = convertToBase(value, 2, 62);
   *   debug(result);
   *   // @results  result = 'HelloWorld'
   *
   *
   * @param  {Number|String}  value   the numeric or alphameric value.
   * @param  {Number}         from    the base number is in.
   * @param  {Number}         to      the base to convert number to.
   * @return {String}                 the numbers of result which was
   *                                    converted to base to base.
   * @type  Function
   * @function
   * @static
   * @public
   */
  convertToBase : function(value, from, to) {
    var BASE62MAP = DIGITS + UPPER_ALPHAS + LOWER_ALPHAS,
        result = '', numbers, end, i, pos, div, index,
        v = stringify(value, true),
        len = v.length,
        base = {
          from : from - 0,
          to   : to   - 0
        };
    if (!isNaN(base.from) && base.from > 0 && base.from < 63 &&
        !isNaN(base.to)   && base.to   > 0 && base.to   < 63) {
      numbers = [];
      for (i = 0; i < len; i++) {
        pos = BASE62MAP.indexOf(v.charAt(i));
        if (!~pos) {
          end = true;
          break;
        }
        numbers[i] = pos;
      }
      if (end) {
        return false;
      }
      do {
        div = index = i = 0;
        do {
          div = div * base.from + numbers[i];
          if (div >= base.to) {
            numbers[index++] = Math.floor(div / base.to);
            div = div % base.to;
          } else if (index > 0) {
            numbers[index++] = 0;
          }
        } while (++i < len);
        len = index;
        result = BASE62MAP.charAt(div) + result;
      } while (index !== 0);
    }
    return result;
  },
  /**
   * Compare two version strings.
   * Version strings are dot-separated sequences of
   *  version-parts.
   * Numbers are base-10, and are zero if left out.
   * Strings are compared basic
   *  textual versions (e.g., "beta" and "alpha" etc.).
   *
   *
   * @example
   *   function compareVersionsRepr(a, b) {
   *     var x = compareVersions(a, b);
   *     if (x == 0) {
   *       return a + ' == ' + b;
   *     } else if (x > 0) {
   *       return a + ' > '  + b;
   *     } else {
   *       return a + ' < '  + b;
   *     }
   *   }
   *   debug(compareVersionsRepr('1.0pre', '1.0'));
   *   // @results '1.0pre < 1.0'
   *
   *
   * @example
   *   debug(compareVersions('8.2.5rc', '8.2.5a'));
   *   // @results 1
   *   debug(compareVersions('8.2.50', '8.2.52'));
   *   // @results -1
   *   debug(compareVersions('5.3.0-dev', '5.3.0'));
   *   // @results -1
   *   debug(compareVersions('4.1.0.52', '4.01.0.51'));
   *   // @results 1
   *   debug(compareVersions('1.01a', '1.01'));
   *   // @results -1
   *   debug(compareVersions('1.0.0', '1.0.00'));
   *   // @results 0
   *   debug(compareVersions('2.1.0', '2.0.0', '<'));
   *   // @results false
   *   debug(compareVersions('2.1.0', '2.0.0', '>'));
   *   // @results true
   *   debug(compareVersions('2.1.0a', '2.1.0a', '=='));
   *   // @results true
   *
   *
   * @param  {String|Number}  ver1   The first version.
   * @param  {String|Number}  ver2   The second version.
   * @param  {String}   (operator)   (Optional) Comparison operator.
   * @return {Number}                If `ver1` and `ver2` are two version
   *                                   being compared, and the return value:
   *                                   - is smaller than 0, then A < B.
   *                                   - equals 0 then Version, then A == B.
   *                                   - is bigger than 0, then A > B.
   * @type  Function
   * @function
   * @static
   * @public
   */
  compareVersions : function(ver1, ver2, operator) {
    var result = 0, me = Pot.Complex.compareVersions, v1, v2, max, i;
    if (!me.prep) {
      update(me, {
        versionMapMin : -7,
        versionMaps   : {
          canary      : -7,
          dev         : -6,
          d           : -6,
          prealpha    : -6,
          pre         : -6,
          pa          : -6,
          nightly     : -6,
          n           : -6,
          minefield   : -6,
          trunk       : -6,
          aurora      : -5,
          alpha       : -5,
          a           : -5,
          beta        : -4,
          b           : -4,
          publicbeta  : -3,
          pb          : -3,
          rc          : -3,
          r           : -3,
          '#'         : -2,
          rtm         : -1,
          rt          : -1,
          stable      : -1,
          s           : -1,
          release     : -1,
          ga          : -1,
          g           : -1,
          pl          : -1,
          p           : -1
        },
        replaceMaps : [{
          from : /[\s\u00A0\u3000]+/g,
          to   : ''
        }, {
          from : /(\d*)([x*]+)(?:[.]|$)/g,
          to   : function(a, d, x) {
            return d + (new Array(x.length + 1).join('9')) + '.';
          }
        }, {
          from : /[_+-]/g,
          to   : '.'
        }, {
          from : /([^.0-9]+)/g,
          to   : '.$1.'
        }, {
          from : /[.]{2,}/g,
          to   : '.'
        }],
        prep : function(ver) {
          var v = stringify(ver, true).toLowerCase();
          each(this.replaceMaps, function(re) {
            v = v.replace(re.from, re.to);
          });
          return  (v.length === 0)   ?
            [this.versionMapMin - 2] : v.split(/[.]+/);
        },
        numbering : function(ver) {
          if (!ver) {
            return 0;
          } else if (isNaN(ver)) {
            return this.versionMaps[ver] || this.versionMapMin - 1;
          } else {
            return parseInt(ver, 10);
          }
        }
      });
    }
    v1 = me.prep(ver1);
    v2 = me.prep(ver2);
    max = Math.max(v1.length, v2.length);
    for (i = 0; i < max; i++) {
      if (v1[i] === v2[i]) {
        continue;
      }
      v1[i] = me.numbering(v1[i]);
      v2[i] = me.numbering(v2[i]);
      if (v1[i] < v2[i]) {
        result = -1;
        break;
      }
      if (v1[i] > v2[i]) {
        result = 1;
        break;
      }
    }
    if (operator) {
      switch (String(operator).toLowerCase()) {
        case '<':
        case 'lt':
            result = (result < 0);
            break;
        case '>':
        case 'gt':
            result = (result > 0);
            break;
        case '<=':
        case 'le':
            result = (result <= 0);
            break;
        case '>=':
        case 'ge':
            result = (result >= 0);
            break;
        case '<>':
        case '!==':
        case '!=':
        case 'ne':
            result = (result !== 0);
            break;
        case '===':
        case '==':
        case '=':
        case 'eq':
        default:
            result = (result === 0);
      }
    }
    return result;
  }
});

// Update Pot object.
Pot.update({
  numeric         : Pot.Complex.numeric,
  rand            : Pot.Complex.rand,
  limit           : Pot.Complex.limit,
  convertToBase   : Pot.Complex.convertToBase,
  compareVersions : Pot.Complex.compareVersions
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Sanitizer.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Sanitizer.
   *
   * This object escape the string or filename, and expressions,
   *  these will be sanitized safely.
   *
   * @name  Pot.Sanitizer
   * @type  Object
   * @class
   * @public
   * @static
   */
  Sanitizer : {}
});

update(Pot.Sanitizer, {
  /**
   * @lends Pot.Sanitizer
   */
  /**
   * Escape RegExp patterns.
   *
   *
   * @example
   *   var pattern = 'ﾑｷｭ*･ﾟ･*..:*･(≧∀≦)ﾟ･*:.｡.*ﾟ:!!';
   *   var regex = new RegExp('^(' + rescape(pattern) + ')$', 'g');
   *   debug(regex.toString());
   *   // @results /^(ﾑｷｭ\*･ﾟ･\*\.\.:\*･\(≧∀≦\)ﾟ･\*:\.｡\.\*ﾟ:!!)$/g
   *
   *
   * @param  {String}  s  A target string.
   * @return {String}     The escaped string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  rescape : rescape,
  /**
   * Alias for rescape.
   *
   * @see Pot.Sanitizer.rescape
   *
   * @param  {String}  s  A target string.
   * @return {String}     The escaped string.
   * @type   Function
   * @function
   * @alias  Pot.Sanitizer.rescape
   * @static
   * @public
   */
  escapeRegExp : rescape,
  /**
   * Escape the HTML string.
   * HTML entities will be escaped.
   *
   *
   * @example
   *   var string = '(>_<)/"< Hello World!';
   *   var result = escapeHTML(string);
   *   debug(result);
   *   // @results '(&gt;_&lt;)/&quot;&lt; Hello World!'
   *   //
   *   // for JSDoc: (@results)
   *   // '(&amp;gt;_&amp;lt;)/&amp;quot;&amp;lt; Hello World!'
   *
   *
   * @param  {String}  text  The target string.
   * @return {String}        The escaped string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  escapeHTML : function(text) {
    var me = Pot.Sanitizer.escapeHTML, s;
    if (!me.ENTITIES) {
      update(me, {
        ENTITIES : [
          {by: /&/g, to: '&amp;' },
          {by: /</g, to: '&lt;'  },
          {by: />/g, to: '&gt;'  },
          {by: /"/g, to: '&quot;'},
          {by: /'/g, to: '&#039;'}
        ]
      });
    }
    s = stringify(text);
    if (s) {
      if (!Pot.isHTMLEscaped(s)) {
        each(me.ENTITIES, function(o) {
          s = s.replace(o.by, o.to);
        });
      }
    }
    return s;
  },
  /**
   * Unescape the HTML string.
   * HTML entities will be unescaped.
   *
   *
   * @example
   *   var string = '(&gt;_&lt;)/&quot;&lt; Hello World!';
   *   // for JSDoc: (string)
   *   // '(&amp;gt;_&amp;lt;)/&amp;quot;&amp;lt; Hello World!'
   *   //
   *   var result = unescapeHTML(string);
   *   debug(result);
   *   // @results '(>_<)/"< Hello World!'
   *
   *
   * @param  {String}  text  The target string.
   * @return {String}        The unescaped string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  unescapeHTML : function(text) {
    var me = Pot.Sanitizer.unescapeHTML, result = '';
    if (!me.RE) {
      update(me, {
        /**@ignore*/
        RE : /&(?:[a-z]\w{0,24}|#(?:x[0-9a-f]{1,8}|[0-9]{1,10}));/gi,
        /**@ignore*/
        ENTITIES : {
          // Some are unable to convert by DOM.
          // White spaces are not converted strict for other processing.
          '&nbsp;'   : '\u0020', // U+00A0
          '&ensp;'   : '\u0020', // U+2002
          '&emsp;'   : '\u0020', // U+2003
          '&thinsp;' : '\u0020', // U+2009
          '&hellip;' : '\u2026', '&bull;'   : '\u2022', '&copy;'   : '\u00a9',
          '&reg;'    : '\u00ae', '&deg;'    : '\u00b0', '&trade;'  : '\u2122',
          '&euro;'   : '\u20ac', '&permil;' : '\u2030', '&Delta;'  : '\u0394',
          '&nabla;'  : '\u2207', '&laquo;'  : '\u226a', '&raquo;'  : '\u226b',
          '&ldquo;'  : '\u201c', '&rdquo;'  : '\u201d', '&lsquo;'  : '\u2018',
          '&rsquo;'  : '\u2019', '&ndash;'  : '\u2013', '&mdash;'  : '\u2014',
          '&sum;'    : '\u2211', '&Sigma;'  : '\u03a3', '&plusmn;' : '\u00b1',
          '&para;'   : '\u00b6', '&equiv;'  : '\u2261', '&dagger;' : '\u2020',
          '&Dagger;' : '\u2021', '&forall;' : '\u2200', '&beta;'   : '\u03b2',
          '&Lambda;' : '\u039b', '&lambda;' : '\u03bb', '&omega;'  : '\u03c9',
          '&middot;' : '\u30fb', '&OElig;'  : '\u0152', '&quot;'   : '\u0022',
          '&apos;'   : '\u0027', '&lt;'     : '\u003c', '&gt;'     : '\u003e'
        },
        /**@ignore*/
        decode : function(s) {
          var c = '';
          try {
            if (!me.elem) {
              me.elem = Pot.currentDocument().createElement('div');
            }
            me.elem.innerHTML = String(s);
            c = me.elem.childNodes[0].nodeValue;
            me.elem.removeChild(me.elem.firstChild);
            if (!c || String(s).length > String(c).length) {
              throw c;
            }
          } catch (e) {
            c = String(s);
          }
          if (c && c.charAt(0) === '&' && c.slice(-1) === ';') {
            if (me.ENTITIES[c]) {
              c = me.ENTITIES[c];
            } else {
              c = c.slice(1, -1);
              if (c.charAt(0) === '#') {
                c = c.substring(1).toLowerCase();
                if (c.charAt(0) === 'x') {
                  c = '0' + c;
                } else {
                  c = c - 0;
                }
                c = fromUnicode(c);
              } else {
                c = '';
              }
            }
          }
          return c;
        }
      });
    }
    result = stringify(text);
    if (result) {
      if (Pot.isHTMLEscaped(result)) {
        result = result.replace(me.RE, me.decode).replace(/&amp;/g, '&');
      }
    }
    return result;
  },
  /**
   * Escape the XPath expression.
   *
   *
   * @example
   *   var text = '"] | /foo/bar/baz | .["';
   *   var expr = '//*[@class=' + escapeXPathText(text) + ']';
   *   // e.g. var element = $x(expr, document, true);
   *   debug(expr);
   *   // @results //*[@class=concat('"',"] | /foo/bar/baz | .[",'"')]
   *
   *
   * @example
   *   var text = 'hoge-class';
   *   var expr = '//*[@class=' + escapeXPathText(text) + ']';
   *   debug(expr);
   *   // @results //*[@class="hoge-class"]
   *
   *
   * @param  {String}  text  A string to be escaped.
   * @return {String}        The escaped string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  escapeXPathText : function(text) {
    var result, re, matches, concats, esc, sq, wq;
    re = /[^"]+|"/g;
    wq = '"';
    sq = "'";
    /**@ignore*/
    esc = function(s) {
      return (s === wq) ? sq + s + sq : wq + s + wq;
    };
    matches = stringify(text).match(re);
    if (matches) {
      if (matches.length === 1) {
        result = esc(matches[0]);
      } else {
        concats = [];
        each(matches, function(match) {
          concats[concats.length] = esc(match);
        });
        result = 'concat(' + concats.join(',') + ')';
      }
    } else {
      result = wq + wq;
    }
    return result;
  },
  /**
   * Escape a string to use with AppleScript.
   *
   *
   * @example
   *   var file = escapeAppleScriptString('ヾ("ゝω・")ﾉ"');
   *   var command = [
   *     'tell application "Finder"',
   *     '  get exists of file "' + file + '" of desktop',
   *     'end tell'
   *   ].join('\n');
   *   debug(command);
   *   // @results
   *   //   tell application "Finder"
   *   //     get exists of file "ヾ(\"ゝω・\")ﾉ\"" of desktop
   *   //   end tell
   *
   *
   * @param  {String}  s  A target string.
   * @return {String}     The escaped string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  escapeAppleScriptString : function(s) {
    return stringify(s).replace(/(["\\])/g, '\\$1');
  },
  /**
   * Escape a string for basic code.
   *
   *
   * @example
   *   var result = 'id="' + escapeString('foo"bar"') + '"';
   *   debug(result);
   *   // @results id="foo\"bar\""
   *
   *
   * @param  {String}   s    A target string.
   * @return {String}        The escaped string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  escapeString : function(s) {
    return stringify(s).replace(/(["'\\])/g, '\\$1');
  },
  /**
   * Unescape a string for basic code.
   *
   *
   * @example
   *   var result = unescapeString('foo=\\"bar\\"');
   *   debug(result);
   *   // @results foo="bar"
   *
   *
   * @param  {String}   s    A target string.
   * @return {String}        The unescaped string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  unescapeString : function(s) {
    return stringify(s).replace(/\\(["'\\])/g, '$1');
  },
  /**
   * Escape the filename.
   * Escapes to be a safe filename for each OS.
   *
   * {@link http://mxr.mozilla.org/mozilla/source/toolkit/
   *        content/contentAreaUtils.js#818 }
   *
   *
   * @example
   *   var fileName = 'ﾟ･*:.｡..｡.:*･ﾟ(file)ﾟ･*:.｡. .｡.:*･ﾟ･*';
   *   var escaped = escapeFileName(fileName);
   *   debug(escaped);
   *   // @results 'ﾟ･ .｡..｡. ･ﾟ(file)ﾟ･ .｡. .｡. ･ﾟ･ ' (on Windows)
   *
   *
   * @param  {String}  fileName   A target filename.
   * @return {String}             A validated filename.
   * @type   Function
   * @function
   * @static
   * @public
   */
  escapeFileName : function(fileName) {
    var s, re;
    s = stringify(fileName);
    if (s) {
      re = [{from: /[\u0000-\u0008]+/g, to: ''}];
      if (PotOS.win) {
        re.push(
          {from: /[\/|\\]+/g, to: '_'},
          {from: /["]+/g,     to: "'"},
          {from: /[*:;?]+/g,  to: ' '},
          {from: /[<]+/g,     to: '('},
          {from: /[>]+/g,     to: ')'}
        );
      } else if (PotOS.mac) {
        re.push({from: /[\/:]+/g, to: '_'});
      }
      re.push(
        {from: /[*\/\\]+/g,      to: '_' },
        {from: /([_()])\1{2,}/g, to: '$1'}
      );
      each(re, function(r) {
        s = s.replace(r.from, r.to);
      });
    }
    return s;
  },
  /**
   * Convert a string that can be evaluated as JavaScript escape sequences.
   * This function converts more characters than JSON. (i.e. enabled as JSON)
   *
   *
   * @example
   *   var string = 'ほげabc ("ｗ")';
   *   var result = escapeSequence(string);
   *   debug(result);
   *   // @results  '\u307b\u3052abc\u0020(\"\uff57\")'
   *
   *
   * @param  {String}   text   A target string.
   * @return {String}          The escaped string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  escapeSequence : function(text) {
    var s, me = Pot.Sanitizer.escapeSequence;
    if (!me.re) {
      me.re = /[^\w!#$()*+,.:;=?@[\]^`|~-]/gi;
      /**@ignore*/
      me.meta = {
        // IE is not supported <VT> (\v).
        '\u0008': '\\b',  // <BS>
        '\u0009': '\\t',  // <HT> <TAB>
        '\u000A': '\\n',  // <LF>
        '\u000C': '\\f',  // <FF>
        '\u000D': '\\r',  // <CR>
        '\u0027': '\\\'',
        '\u0022': '\\"',
        '\u005C': '\\\\',
        '\u002F': '\\/'
      };
      /**@ignore*/
      me.rep = function(a) {
        var c = me.meta[a];
        return (typeof c === 'string') ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
      };
    }
    me.re.lastIndex = 0;
    s = stringify(text);
    return (s && me.re.test(s)) ? s.replace(me.re, me.rep) : s;
  },
  /**
   * Revert the converted string as JavaScript escape sequences.
   *
   *
   * @example
   *   var string = '\\u307b\\u3052abc\\u0020(\\"\\uff57\\")';
   *   var result = unescapeSequence(string);
   *   debug(result);
   *   // @results  'ほげabc ("ｗ")'
   *
   *
   * @param  {String}   text   A target string.
   * @return {String}          The unescaped string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  unescapeSequence : function(text) {
    var s, me = Pot.Sanitizer.unescapeSequence;
    if (!me.re) {
      /**@ignore*/
      me.re = {
        seq   : /\\([btnvfr'"\/\\]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|.|[\s\S])/g,
        quote : /^\s*(?:"(?:\\.|[^"\r\n\\])*"|'(?:\\.|[^'\r\n\\])*')\s*$/,
        bs    : /[\u005C]{2}/g
      };
      /**@ignore*/
      me.meta = {
        'b' : '\u0008',
        't' : '\u0009',
        'n' : '\u000A',
        'v' : '\u000B',
        'f' : '\u000C',
        'r' : '\u000D',
        '\'': '\u0027',
        '"' : '\u0022',
        '\\': '\u005C',
        '/' : '\u002F'
      };
      /**@ignore*/
      me.rep = function(m, a) {
        var r, c = me.meta[a];
        if (typeof c === 'string') {
          r = c;
        } else if (a.length === 3 && a.charAt(0) === 'x') {
          r = fromUnicode('0' + a);
        } else if (a.length === 5 && a.charAt(0) === 'u') {
          r = fromUnicode('0x' + a.substring(1));
        } else {
          r = a;
        }
        return r;
      };
    }
    me.re.seq.lastIndex = 0;
    s = stringify(text);
    // for JSON string.
    if (me.re.quote.test(s) && me.re.bs.test(s)) {
      s = s.replace(me.re.bs, '\u005C');
    }
    return (s && me.re.seq.test(s)) ? s.replace(me.re.seq, me.rep) : s;
  }
});

// Update Pot object.
Pot.update({
  rescape                 : Pot.Sanitizer.rescape,
  escapeRegExp            : Pot.Sanitizer.escapeRegExp,
  escapeHTML              : Pot.Sanitizer.escapeHTML,
  unescapeHTML            : Pot.Sanitizer.unescapeHTML,
  escapeXPathText         : Pot.Sanitizer.escapeXPathText,
  escapeAppleScriptString : Pot.Sanitizer.escapeAppleScriptString,
  escapeString            : Pot.Sanitizer.escapeString,
  unescapeString          : Pot.Sanitizer.unescapeString,
  escapeFileName          : Pot.Sanitizer.escapeFileName,
  escapeSequence          : Pot.Sanitizer.escapeSequence,
  unescapeSequence        : Pot.Sanitizer.unescapeSequence
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of UTF8.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * UTF-8 and UTF-16  utilities.
   *
   * Mutual conversion between UTF-8 and UTF-16.
   *
   * RFC 2044, RFC 2279: UTF-8, a transformation format of ISO 10646
   * @link http://www.ietf.org/rfc/rfc2279.txt
   *
   * Note that using "encodeURIComponent" or "decodeURIComponent" to
   *   convert a string that includes surrogate pair or characters
   *   U+FFFE or U+FFFF then will raise URIError.
   * U+FFFF and U+FFFE will convert unexpect result on SpiderMonkey.
   *
   * This methods implements convertion functions for
   *   UTF-8 and UTF-16 compatible with calling of
   *   "unescape(encodeURIComponent(string))" and
   *   "decodeURIComponent(escape(string))".
   *
   * <pre>
   * Example:
   *   decodeURIComponent(encodeURIComponent('\uFFFF')) === '\uFFFF';
   * Results:
   *   false (SpiderMonkey)
   *
   * Example:
   *   decodeURIComponent(encodeURIComponent('\uD811')) === '\uD811';
   * Results:
   *   URIError
   * </pre>
   *
   * @name Pot.UTF8
   * @type Object
   * @class
   * @static
   * @public
   * @based libxml/xml.c#xml_utf8_encode/xml_utf8_decode
   */
  UTF8 : {}
});

update(Pot.UTF8, {
  /**
   * @lends Pot.UTF8
   */
  /**
   * Convert to UTF-8 string from UTF-16 string.
   *
   *
   * @example
   *   var string = 'hogeほげ';
   *   var encoded = Pot.utf8Encode(string);
   *   var decoded = Pot.utf8Decode(encoded);
   *   var toCharCode = function(s) {
   *     return Pot.map(s.split(''), function(c) {
   *       return c.charCodeAt(0);
   *     });
   *   };
   *   Pot.debug(toCharCode(encoded));
   *   // [104, 111, 103, 101, 227, 129, 187, 227, 129, 146]
   *   Pot.debug(decoded); // 'hogeほげ'
   *   Pot.debug(decoded === string); // true
   *
   *
   * @param  {String}  string  UTF-16 string.
   * @return {String}          UTF-8 string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  encode : (function() {
    var sc = fromUnicode,
        /**@ignore*/
        add = function(b, c) {
          var l = b.length;
          if (c < 0x80) {
            b[l] = sc(c);
          } else if (c < 0x800) {
            b[l] = sc(0xC0 | ((c >>  6) & 0x1F)) +
                   sc(0x80 | ((c >>  0) & 0x3F));
          } else if (c < 0x10000) {
            b[l] = sc(0xE0 | ((c >> 12) & 0x0F)) +
                   sc(0x80 | ((c >>  6) & 0x3F)) +
                   sc(0x80 | ((c >>  0) & 0x3F));
          } else {
            b[l] = sc(0xF0 | ((c >> 18) & 0x0F)) +
                   sc(0x80 | ((c >> 12) & 0x3F)) +
                   sc(0x80 | ((c >>  6) & 0x3F)) +
                   sc(0x80 | ((c >>  0) & 0x3F));
          }
        };
    return function(string) {
      var chars = [],  len, i, j, ch, c2,
          s = stringify(string);
      if (s) {
        len = s.length;
        for (i = 0; i < len; i++) {
          ch = s.charCodeAt(i);
          if (0xD800 <= ch && ch <= 0xD8FF) {
            j = i + 1;
            if (j < len) {
              c2 = s.charCodeAt(j);
              if (0xDC00 <= c2 && c2 <= 0xDFFF) {
                ch = ((ch & 0x3FF) << 10) + (c2 & 0x3FF) + 0x10000;
                i = j;
              }
            }
          }
          add(chars, ch);
        }
      }
      return chars.join('');
    };
  }()),
  /**
   * Convert to UTF-16 string from UTF-8 string.
   *
   *
   * @example
   *   var string = 'hogeほげ';
   *   var encoded = Pot.utf8Encode(string);
   *   var decoded = Pot.utf8Decode(encoded);
   *   var toCharCode = function(s) {
   *     return Pot.map(s.split(''), function(c) {
   *       return c.charCodeAt(0);
   *     });
   *   };
   *   Pot.debug(toCharCode(encoded));
   *   // [104, 111, 103, 101, 227, 129, 187, 227, 129, 146]
   *   Pot.debug(decoded); // 'hogeほげ'
   *   Pot.debug(decoded === string); // true
   *
   *
   * @param  {String}  string  UTF-8 string.
   * @return {String}          UTF-16 string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  decode : function(string) {
    var result = '', chars = [], i = 0, len,
        n, c, c2, c3, c4, code, sc = fromUnicode,
        s = stringify(string);
    if (s) {
      len = s.length;
      while (i < len) {
        c = s.charCodeAt(i++);
        n = (c >> 4);
        if (0 <= n && n <= 7) {
          // 0xxx xxxx
          chars[chars.length] = sc(c);
        } else if (12 <= n && n <= 13) {
          // 110x xxxx
          // 10xx xxxx
          c2 = s.charCodeAt(i++);
          chars[chars.length] = sc(((c & 0x1F) << 6) | (c2 & 0x3F));
        } else if (n === 14) {
          // 1110 xxxx
          // 10xx xxxx
          // 10xx xxxx
          c2 = s.charCodeAt(i++);
          c3 = s.charCodeAt(i++);
          chars[chars.length] = sc(((c  & 0x0F) << 12) |
                                   ((c2 & 0x3F) <<  6) |
                                   ((c3 & 0x3F) <<  0));
        } else if (i + 2 < len) {
          // 1111 0xxx ...
          c2 = s.charCodeAt(i++);
          c3 = s.charCodeAt(i++);
          c4 = s.charCodeAt(i++);
          code = (((c  & 0x07) << 18) |
                  ((c2 & 0x3F) << 12) |
                  ((c3 & 0x3F) <<  6) |
                  ((c4 & 0x3F) <<  0));
          if (code <= 0xFFFF) {
            chars[chars.length] = sc(code);
          } else {
            chars[chars.length] = fromCharCode(
              (code >> 10)   + 0xD7C0,
              (code & 0x3FF) + 0xDC00
            );
          }
        }
      }
      result = chars.join('');
    }
    return result;
  },
  /**
   * Gets the byte size of string as UTF-8.
   *
   *
   * @example
   *   var string = 'abc123あいうえお';
   *   var length = string.length;
   *   var byteSize = Pot.UTF8.byteOf(string);
   *   debug(string + ' : length = ' + length + ', byteSize = ' + byteSize);
   *   // @results
   *   //   length   = 11
   *   //   byteSize = 21
   *
   *
   * @param  {String}   string   The target string.
   * @return {Number}            The UTF-8 byte size of string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  byteOf : (function() {
    var s, i, len,
        /**@ignore*/
        toCharCode = function() {
          var c1 = s.charCodeAt(i), c2, j;
          if (0xD800 <= c1 && c1 <= 0xD8FF) {
            j = i + 1;
            if (j < len) {
              c2 = s.charCodeAt(j);
              if (0xDC00 <= c2 && c2 <= 0xDFFF) {
                c1 = ((c1 & 0x3FF) << 10) + (c2 & 0x3FF) + 0x10000;
                i = j;
              } else {
                return false;
              }
            } else {
              return false;
            }
          }
          return c1;
        };
    return function(string) {
      var size = 0, c;
      s = stringify(string, true);
      if (s) {
        len = s.length;
        for (i = 0; i < len; i++) {
          c = toCharCode();
          if (c !== false) {
            if (c < 0x80) {
              size += 1;
            } else if (c < 0x800) {
              size += 2;
            } else if (c < 0x10000) {
              size += 3;
            } else if (c < 0x200000) {
              size += 4;
            } else if (c < 0x4000000) {
              size += 5;
            } else {
              size += 6;
            }
          }
        }
      }
      s = i = len = null;
      return size;
    };
  }()),
  /**
   * Convert encoding to Unicode string.
   * This function requires BlobBuilder and FileReader API.
   * If environment not supported HTML5 API, it will be raised by Deferred.
   *
   * @example
   *   // 'こんにちは。ほげほげ'
   *   var unicode = [
   *     12371, 12435, 12395, 12385, 12399, 12290,
   *     12411, 12370, 12411, 12370
   *   ];
   *   // Shift_JIS: 'こんにちは。ほげほげ'
   *   var sjis = [
   *     130, 177, 130, 241, 130, 201,
   *     130, 191, 130, 205, 129, 66,
   *     130, 217, 130, 176, 130, 217,
   *     130, 176
   *   ];
   *   // EUC-JP: 'こんにちは。ほげほげ'
   *   var eucjp = [
   *     164, 179, 164, 243, 164, 203,
   *     164, 193, 164, 207, 161, 163,
   *     164, 219, 164, 178, 164, 219,
   *     164, 178
   *   ];
   *   // UTF-8: 'こんにちは。ほげほげ'
   *   var utf8 = [
   *     227, 129, 147, 227, 130, 147,
   *     227, 129, 171, 227, 129, 161,
   *     227, 129, 175, 227, 128, 130,
   *     227, 129, 187, 227, 129, 146,
   *     227, 129, 187, 227, 129, 146
   *   ];
   *   Pot.convertEncodingToUnicode(sjis, 'Shift_JIS').then(function(res) {
   *     Pot.debug('SJIS to Unicode:');
   *     Pot.debug(res); // 'こんにちは。ほげほげ'
   *   }).then(function() {
   *     return Pot.convertEncodingToUnicode(eucjp, 'EUC-JP').
   *                                                     then(function(res) {
   *       Pot.debug('EUC-JP to Unicode:');
   *       Pot.debug(res); // 'こんにちは。ほげほげ'
   *     });
   *   }).then(function() {
   *     return Pot.convertEncodingToUnicode(utf8, 'UTF-8').
   *                                                    then(function(res) {
   *       Pot.debug('UTF-8 to Unicode:');
   *       Pot.debug(res); // 'こんにちは。ほげほげ'
   *     });
   *   });
   *
   *
   * @param  {TypedArray|Array|Blob}  data   The target data.
   * @param  {(String)}              (from)  (optional) Character
   *                                           encoding from.
   * @return {Pot.Deferred}                  A new instance of
   *                                           Pot.Deferred that has
   *                                           Unicode string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  convertEncodingToUnicode : (function() {
    var isAuto = /^\s*auto\s*$/i;
    return function(data, from) {
      var d, bb, fl, b, dfd;
      if (isString(data)) {
        d = ArrayBufferoid.binaryToBuffer.deferred(data);
      } else {
        d = Deferred.succeed(data);
      }
      return d.then(function(res) {
        dfd = new Deferred();
        try {
          fl = new FileReader();
          if (isArrayBufferoid(res)) {
            bb = res.toArrayBuffer();
          } else if (isArrayLike(res)) {
            bb = new ArrayBufferoid(res).toArrayBuffer();
          } else {
            bb = res;
          }
          /**@ignore*/
          fl.onload = function(ev) {
            fl.onload = fl.onerror = PotNoop;
            if (ev && ev.target) {
              dfd.begin(ev.target.result);
            } else {
              dfd.raise(ev);
            }
          };
          /**@ignore*/
          fl.onerror = function(er) {
            fl.onload = fl.onerror = PotNoop;
            dfd.raise(er);
          };
          b = Pot.createBlob(bb, 'text/plain');
          if (from == null || isAuto.test(from)) {
            fl.readAsText(b);
          } else {
            //XXX: Assign the encoding names.
            fl.readAsText(b, trim(from));
          }
        } catch (e) {
          dfd.raise(e);
        }
        return dfd;
      });
    };
  }())
});

// Update Pot object.
Pot.update({
  utf8Encode               : Pot.UTF8.encode,
  utf8Decode               : Pot.UTF8.decode,
  utf8ByteOf               : Pot.UTF8.byteOf,
  convertEncodingToUnicode : Pot.UTF8.convertEncodingToUnicode
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Base64.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Base64 encode/decode.
   *
   * RFC 3548 - Base64 Data Encodings
   * @link http://tools.ietf.org/html/rfc3548
   *
   * @name Pot.Base64
   * @type Object
   * @class
   * @static
   * @public
   */
  Base64 : (function() {
    // Base64 from: http://feel.happy.nu/test/base64.html
    var BASE64MAPS    = UPPER_ALPHAS + LOWER_ALPHAS + DIGITS + '+/=',
        BASE64URLMAPS = UPPER_ALPHAS + LOWER_ALPHAS + DIGITS + '-_=',
        /**@ignore*/
        Encoder = function(data, maps) {
          return new Encoder.prototype.init(data, maps);
        },
        /**@ignore*/
        Decoder = function(string, maps) {
          return new Decoder.prototype.init(string, maps);
        };
    Encoder.prototype = update(Encoder.prototype, {
      /**
       * @private
       * @ignore
       * @internal
       */
      constructor : Encoder,
      /**
       * @private
       * @ignore
       * @internal
       */
      data : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      raw : false,
      /**
       * @private
       * @ignore
       * @internal
       */
      len : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      results : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      pos : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      att : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      index : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      vol : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      maps : null,
      /**
       * Initialize properties.
       *
       * @private
       * @ignore
       */
      init : function(data, maps) {
        this.maps = maps;
        if (isArrayLike(data)) {
          this.data = arrayize(data);
          this.raw = true;
        } else {
          this.data = stringify(data, true);
          this.raw = false;
        }
        this.len = this.data.length;
        this.results = [];
        this.pos = -6;
        this.att = 0;
        this.index = 0;
        this.vol = 0;
        return this;
      },
      /**
       * @private
       * @ignore
       */
      execute : function() {
        var r = this.results, m = this.maps;
        if (!this.raw) {
          this.data = Pot.UTF8.encode(this.data);
        }
        if (this.data) {
          this.len = this.data.length;
          while (this.index < this.len || this.pos > -6) {
            if (this.pos < 0) {
              this.peek();
            }
            r[r.length] = m.charAt(
              (this.vol > 0) ? (this.att >> this.pos & 63) : 64
            );
            this.pos -= 6;
            this.vol -= 6;
          }
        }
        return r.join('');
      },
      /**
       * @private
       * @ignore
       */
      deferred : function(speed) {
        var that = this, r = this.results, m = this.maps;
        if (!this.raw) {
          this.data = Pot.UTF8.encode(this.data);
        }
        this.len = this.data.length;
        return Deferred.forEver[speed](function() {
          if (that.index < that.len || that.pos > -6) {
            if (that.pos < 0) {
              that.peek();
            }
            r[r.length] = m.charAt(
              (that.vol > 0) ? (that.att >> that.pos & 63) : 64
            );
            that.pos -= 6;
            that.vol -= 6;
          } else {
            throw PotStopIteration;
          }
        }).then(function() {
          return r.join('');
        });
      },
      /**
       * @private
       * @ignore
       */
      peek : function() {
        var c;
        if (this.index < this.len) {
          if (this.raw) {
            c = this.data[this.index++];
          } else {
            c = this.data.charCodeAt(this.index++);
          }
          this.vol += 8;
        } else {
          c = 0;
        }
        this.att = ((this.att & 0xFF) << 8) | (c & 0xFF);
        this.pos += 8;
      }
    });
    Encoder.prototype.init.prototype = Encoder.prototype;
    Decoder.prototype = update(Decoder.prototype, {
      /**
       * @private
       * @ignore
       * @internal
       */
      constructor : Decoder,
      /**
       * @private
       * @ignore
       * @internal
       */
      string : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      asBuffer : false,
      /**
       * @private
       * @ignore
       * @internal
       */
      len : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      results : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      pos : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      att : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      vol : null,
      /**
       * @private
       * @ignore
       * @internal
       */
      maps : null,
      /**
       * Initialize properties.
       *
       * @private
       * @ignore
       */
      init : function(string, maps) {
        this.maps = maps;
        this.asBuffer = false;
        this.string = stringify(string, true);
        this.assign();
        this.len = this.string.length;
        this.results = [];
        this.pos = -8;
        this.att = 0;
        return this;
      },
      /**
       * @private
       * @ignore
       */
      assign : function() {
        var s = this.string;
        if (~s.indexOf('-') || ~s.indexOf('_')) {
          this.maps = BASE64URLMAPS;
        } else {
          this.maps = BASE64MAPS;
        }
      },
      /**
       * @private
       * @ignore
       */
      execute : function() {
        var i, n = this.len, c, m = this.maps;
        if (n) {
          for (i = 0; i < n; i++) {
            c = m.indexOf(this.string.charAt(i));
            if (~c) {
              this.decode(c);
            }
          }
        }
        return Pot.UTF8.decode(this.results.join(''));
      },
      /**
       * @private
       * @ignore
       */
      executeAsBuffer : function() {
        var i, n = this.len, c, m = this.maps;
        this.asBuffer = true;
        if (n) {
          for (i = 0; i < n; i++) {
            c = m.indexOf(this.string.charAt(i));
            if (~c) {
              this.decode(c);
            }
          }
        }
        return new ArrayBufferoid(this.results);
      },
      /**
       * @private
       * @ignore
       */
      deferred : function(speed) {
        var that = this, m = this.maps;
        return Deferred.repeat[speed](this.len, function(i) {
          var c = m.indexOf(that.string.charAt(i));
          if (~c) {
            that.decode(c);
          }
        }).then(function() {
          return Pot.UTF8.decode(that.results.join(''));
        });
      },
      /**
       * @private
       * @ignore
       */
      deferredAsBuffer : function(speed) {
        var that = this, m = this.maps;
        this.asBuffer = true;
        return Deferred.repeat[speed](this.len, function(i) {
          var c = m.indexOf(that.string.charAt(i));
          if (~c) {
            that.decode(c);
          }
        }).then(function() {
          return new ArrayBufferoid(that.results);
        });
      },
      /**
       * @private
       * @ignore
       */
      decode : function(c) {
        var code, r = this.results;
        this.att = (this.att << 6) | (c & 63);
        this.pos += 6;
        if (this.pos >= 0) {
          code = this.att >> this.pos & 0xFF;
          if (c !== 64) {
            r[r.length] = this.asBuffer ? code : fromUnicode(code);
          }
          this.att &= 63;
          this.pos -= 8;
        }
      }
    });
    Decoder.prototype.init.prototype = Decoder.prototype;
    return {
      /**
       * @lends Pot.Base64
       */
      /**
       * Encodes a string to base64.
       *
       *
       * @example
       *   var string = 'Hello World.';
       *   var result = Pot.base64Encode(string);
       *   debug(result);
       *   // @results 'SGVsbG8gV29ybGQu'
       *
       *
       * @example
       *   var string = 'にゃふん!';
       *   var encoded = Pot.base64Encode(string);
       *   var decoded = Pot.base64Decode(encoded);
       *   debug(
       *     'string  = ' + string + '\n' +
       *     'encoded = ' + encoded + '\n' +
       *     'decoded = ' + decoded
       *   );
       *   // @results
       *   //   string  = にゃふん!
       *   //   encoded = 44Gr44KD44G144KTIQ==
       *   //   decoded = にゃふん!
       *
       *
       * @param  {String|Array}  data   A target data.
       * @return {String}               A base64 string.
       * @type  Function
       * @function
       * @static
       * @public
       */
      encode : update(function(data) {
        var s;
        if (!data) {
          return '';
        }
        if (isArrayLike(data)) {
          s = arrayize(data);
        } else {
          s = stringify(data, true);
          try {
            if (typeof btoa !== 'undefined') {
              return btoa(Pot.UTF8.encode(s));
            }
          } catch (e) {}
        }
        return new Encoder(s, BASE64MAPS).execute();
      }, {
        /**
         * @lends Pot.Base64.encode
         */
        /**
         * Encodes a string to base64 with Deferred.
         *
         *
         * @example
         *   var string = 'Hello World.';
         *   Pot.base64Encode.deferred(string).then(function(encoded) {
         *     debug(encoded);
         *     // @results 'SGVsbG8gV29ybGQu'
         *     return Pot.base64Decode.deferred(encoded)
         *                            .then(function(decoded) {
         *       debug(decoded);
         *       // @results 'Hello World.'
         *     });
         *   });
         *
         *
         * @example
         *   var string = 'にゃふん!';
         *   Pot.base64Encode.deferred(string).then(function(encoded) {
         *     return Pot.base64Decode.deferred(encoded)
         *                            .then(function(decoded) {
         *       debug(
         *         'string  = ' + string + '\n' +
         *         'encoded = ' + encoded + '\n' +
         *         'decoded = ' + decoded
         *       );
         *       // @results
         *       //   string  = にゃふん!
         *       //   encoded = 44Gr44KD44G144KTIQ==
         *       //   decoded = にゃふん!
         *     });
         *   });
         *
         *
         * @param  {String|Array}  data   A target data.
         * @return {Pot.Deferred}         Returns new instance of
         *                                  Pot.Deferred with a
         *                                  base64 string.
         * @type  Function
         * @function
         * @static
         * @public
         *
         * @property {Function} limp   Run with slowest speed.
         * @property {Function} doze   Run with slower speed.
         * @property {Function} slow   Run with slow speed.
         * @property {Function} normal Run with default speed.
         * @property {Function} fast   Run with fast speed.
         * @property {Function} rapid  Run with faster speed.
         * @property {Function} ninja  Run fastest speed.
         */
        deferred : PotInternal.defineDeferrater(function(speed) {
          return function(data) {
            return new Encoder(data, BASE64MAPS).deferred(speed);
          };
        })
      }),
      /**
       * @lends Pot.Base64
       */
      /**
       * Decodes a string from base64.
       *
       *
       * @example
       *   var b64string = 'SGVsbG8gV29ybGQu';
       *   var result = Pot.base64Decode(b64string);
       *   debug(result);
       *   // @results 'Hello World.'
       *
       *
       * @example
       *   var string = 'にゃふん!';
       *   var encoded = Pot.base64Encode(string);
       *   var decoded = Pot.base64Decode(encoded);
       *   debug(
       *     'string  = ' + string + '\n' +
       *     'encoded = ' + encoded + '\n' +
       *     'decoded = ' + decoded
       *   );
       *   // @results
       *   //   string  = にゃふん!
       *   //   encoded = 44Gr44KD44G144KTIQ==
       *   //   decoded = にゃふん!
       *
       *
       * @param  {String}  string   A base64 string.
       * @return {String}           A result string.
       * @type  Function
       * @function
       * @static
       * @public
       */
      decode : update(function(string) {
        var result = '', s = stringify(string, true);
        if (s) {
          try {
            if (typeof atob === 'undefined') {
              throw false;
            }
            result = Pot.UTF8.decode(atob(s));
          } catch (e) {
            try {
              result = new Decoder(s, BASE64MAPS).execute();
            } catch (e) {}
          }
        }
        return result;
      }, {
        /**
         * @lends Pot.Base64.decode
         */
        /**
         * Decodes a string from base64 as ArrayBuffer.
         *
         *
         * @example
         *   var b64string = 'SGVsbG8gV29ybGQu';
         *   var buffer = Pot.base64Decode.asBuffer(b64string);
         *   Pot.debug(buffer);
         *   // [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 46]
         *   Pot.debug(Pot.ArrayBufferoid.bufferToString(buffer));
         *   // 'Hello World.'
         *
         *
         * @example
         *   var base64String = '776fK++9oToub++9pe++n++9peKUo8Ko' +
         *                      '77234pSjwqjvvbfimIbvvaXvvp/vvaU=';
         *   var buffer = Pot.base64Decode.asBuffer(base64String);
         *   Pot.debug(buffer);
         *   // [239, 190, 159,  43, 239, 189, 161,  58,  46, 111,
         *   //  239, 189, 165, 239, 190, 159, 239, 189, 165, 226,
         *   //  148, 163, 194, 168, 239, 189, 183, 226, 148, 163,
         *   //  194, 168, 239, 189, 183, 226, 152, 134, 239, 189,
         *   //  165, 239, 190, 159, 239, 189, 165]
         *   Pot.debug(Pot.ArrayBufferoid.bufferToString(buffer));
         *   // 'ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･'
         *
         *
         * @param  {String}              string   A base64 string.
         * @return {Pot.ArrayBufferoid}           A new instance of
         *                                          Pot.ArrayBufferoid.
         * @type  Function
         * @function
         * @static
         * @public
         */
        asBuffer : function(string) {
          return new Decoder(string, BASE64MAPS).executeAsBuffer();
        },
        /**
         * Decodes a string from base64 with Deferred.
         *
         *
         * @example
         *   var string = 'Hello World.';
         *   Pot.base64Encode.deferred(string).then(function(encoded) {
         *     debug(encoded);
         *     // @results 'SGVsbG8gV29ybGQu'
         *     return Pot.base64Decode.deferred(encoded)
         *                            .then(function(decoded) {
         *       debug(decoded);
         *       // @results 'Hello World.'
         *     });
         *   });
         *
         *
         * @example
         *   var string = 'にゃふん!';
         *   Pot.base64Encode.deferred(string).then(function(encoded) {
         *     return Pot.base64Decode.deferred(encoded)
         *                            .then(function(decoded) {
         *       debug(
         *         'string  = ' + string + '\n' +
         *         'encoded = ' + encoded + '\n' +
         *         'decoded = ' + decoded
         *       );
         *       // @results
         *       //   string  = にゃふん!
         *       //   encoded = 44Gr44KD44G144KTIQ==
         *       //   decoded = にゃふん!
         *     });
         *   });
         *
         *
         * @param  {String}        string   A base64 string.
         * @return {Pot.Deferred}           Returns new instance of
         *                                    Pot.Deferred with a string.
         * @type  Function
         * @function
         * @static
         * @public
         *
         * @property {Function} limp   Run with slowest speed.
         * @property {Function} doze   Run with slower speed.
         * @property {Function} slow   Run with slow speed.
         * @property {Function} normal Run with default speed.
         * @property {Function} fast   Run with fast speed.
         * @property {Function} rapid  Run with faster speed.
         * @property {Function} ninja  Run fastest speed.
         */
        deferred : PotInternal.defineDeferrater(function(speed) {
          return function(string) {
            return new Decoder(string, BASE64MAPS).deferred(speed);
          };
        }),
        /**
         * Decodes a string from base64 as ArrayBuffer with Deferred.
         *
         *
         * @example
         *   var b64string = 'SGVsbG8gV29ybGQu';
         *   Pot.base64Decode.deferredAsBuffer(b64string)
         *                                    .then(function(buffer) {
         *     Pot.debug(buffer);
         *     // [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 46]
         *     Pot.debug(Pot.ArrayBufferoid.bufferToString(buffer));
         *     // 'Hello World.'
         *   });
         *
         *
         * @example
         *   var base64String = '776fK++9oToub++9pe++n++9peKUo8Ko' +
         *                      '77234pSjwqjvvbfimIbvvaXvvp/vvaU=';
         *   Pot.base64Decode.deferredAsBuffer(base64String)
         *                               .then(function(res) {
         *     Pot.debug(res);
         *     // [239, 190, 159,  43, 239, 189, 161,  58,  46, 111,
         *     //  239, 189, 165, 239, 190, 159, 239, 189, 165, 226,
         *     //  148, 163, 194, 168, 239, 189, 183, 226, 148, 163,
         *     //  194, 168, 239, 189, 183, 226, 152, 134, 239, 189,
         *     //  165, 239, 190, 159, 239, 189, 165]
         *     Pot.debug(Pot.ArrayBufferoid.bufferToString(res));
         *     // 'ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･'
         *   });
         *
         *
         * @param  {String}        string   A base64 string.
         * @return {Pot.Deferred}           Returns new instance of
         *                                    Pot.Deferred with a
         *                                    new instance of
         *                                    Pot.ArrayBufferoid.
         * @type  Function
         * @function
         * @static
         * @public
         *
         * @property {Function} limp   Run with slowest speed.
         * @property {Function} doze   Run with slower speed.
         * @property {Function} slow   Run with slow speed.
         * @property {Function} normal Run with default speed.
         * @property {Function} fast   Run with fast speed.
         * @property {Function} rapid  Run with faster speed.
         * @property {Function} ninja  Run fastest speed.
         */
        deferredAsBuffer : PotInternal.defineDeferrater(function(speed) {
          return function(string) {
            return new Decoder(string, BASE64MAPS).deferredAsBuffer(speed);
          };
        })
      }),
      /**
       * @lends Pot.Base64
       */
      /**
       * Encodes a string to base64 for URL safely.
       *
       *
       * @example
       *   var string = '(*>_<*)';
       *   var result = Pot.base64URLEncode(string);
       *   debug(result);
       *   // @results 'KCo-XzwqKQ=='
       *
       *
       * @example
       *   var string = 'ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･';
       *   var encoded = Pot.base64URLEncode(string);
       *   var decoded = Pot.base64URLDecode(encoded);
       *   debug(
       *     'string  = ' + string + '\n' +
       *     'encoded = ' + encoded + '\n' +
       *     'decoded = ' + decoded
       *   );
       *   // @results
       *   //   string  = ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･ 
       *   //   encoded = 776fK--9oToub--9pe--n--9peKUo8Ko
       *   //             77234pSjwqjvvbfimIbvvaXvvp_vvaU=
       *   //   decoded = ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･
       *
       *
       * @param  {String|Array}  data   A target data.
       * @return {String}               A base64 string.
       * @type  Function
       * @function
       * @static
       * @public
       */
      urlEncode : update(function(data) {
        return new Encoder(data, BASE64URLMAPS).execute();
      }, {
        /**
         * @lends Pot.Base64.urlEncode
         */
        /**
         * Encodes a string to base64 for URL safely with Deferred.
         *
         *
         * @example
         *   var string = '(*>_<*)';
         *   Pot.base64URLEncode.deferred(string).then(function(encoded) {
         *     debug(encoded);
         *     // @results 'KCo-XzwqKQ=='
         *     return Pot.base64URLDecode.deferred(encoded)
         *                               .then(function(decoded) {
         *       debug(decoded);
         *       // @results '(*>_<*)'
         *     });
         *   });
         *
         *
         * @example
         *   var string = 'ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･';
         *   Pot.base64URLEncode.deferred(string).then(function(encoded) {
         *     return Pot.base64URLDecode.deferred(encoded)
         *                               .then(function(decoded) {
         *       debug(
         *         'string  = ' + string + '\n' +
         *         'encoded = ' + encoded + '\n' +
         *         'decoded = ' + decoded
         *       );
         *       // @results
         *       //   string  = ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･
         *       //   encoded = 776fK--9oToub--9pe--n--9peKUo8Ko
         *       //             77234pSjwqjvvbfimIbvvaXvvp_vvaU=
         *       //   decoded = ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･
         *     });
         *   });
         *
         *
         * @param  {String|Array}  data   A target data.
         * @return {Pot.Deferred}         Returns new instance of
         *                                  Pot.Deferred with a
         *                                  base64 string.
         * @type  Function
         * @function
         * @static
         * @public
         *
         * @property {Function} limp   Run with slowest speed.
         * @property {Function} doze   Run with slower speed.
         * @property {Function} slow   Run with slow speed.
         * @property {Function} normal Run with default speed.
         * @property {Function} fast   Run with fast speed.
         * @property {Function} rapid  Run with faster speed.
         * @property {Function} ninja  Run fastest speed.
         */
        deferred : PotInternal.defineDeferrater(function(speed) {
          return function(data) {
            return new Encoder(data, BASE64URLMAPS).deferred(speed);
          };
        })
      }),
      /**
       * @lends Pot.Base64
       */
      /**
       * Decodes a string from base64 for URL safely.
       *
       *
       * @example
       *   var string = 'KCo-XzwqKQ==';
       *   var result = Pot.base64URLDecode(string);
       *   debug(result);
       *   // @results '(*>_<*)'
       *
       *
       * @example
       *   var string = 'ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･';
       *   var encoded = Pot.base64URLEncode(string);
       *   var decoded = Pot.base64URLDecode(encoded);
       *   debug(
       *     'string  = ' + string + '\n' +
       *     'encoded = ' + encoded + '\n' +
       *     'decoded = ' + decoded
       *   );
       *   // @results
       *   //   string  = ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･ 
       *   //   encoded = 776fK--9oToub--9pe--n--9peKUo8Ko
       *   //             77234pSjwqjvvbfimIbvvaXvvp_vvaU=
       *   //   decoded = ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･
       *
       *
       * @param  {String}  string   A base64 string.
       * @return {String}           A result string.
       * @type  Function
       * @function
       * @static
       * @public
       */
      urlDecode : update(function(string) {
        return new Decoder(string, BASE64URLMAPS).execute();
      }, {
        /**
         * @lends Pot.Base64.urlDecode
         */
        /**
         * Decodes a string as ArrayBuffer from base64 for URL safely.
         *
         *
         * @example
         *   var b64string = 'SGVsbG8gV29ybGQu';
         *   var buffer = Pot.base64URLDecode.asBuffer(b64string);
         *   Pot.debug(buffer);
         *   // [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 46]
         *   Pot.debug(Pot.ArrayBufferoid.bufferToString(buffer));
         *   // 'Hello World.'
         *
         *
         * @example
         *   var base64String = '776fK--9oToub--9pe--n--9peKUo8Ko' +
         *                      '77234pSjwqjvvbfimIbvvaXvvp_vvaU=';
         *   var buffer = Pot.base64URLDecode.asBuffer(base64String);
         *   Pot.debug(buffer);
         *   // [239, 190, 159,  43, 239, 189, 161,  58,  46, 111,
         *   //  239, 189, 165, 239, 190, 159, 239, 189, 165, 226,
         *   //  148, 163, 194, 168, 239, 189, 183, 226, 148, 163,
         *   //  194, 168, 239, 189, 183, 226, 152, 134, 239, 189,
         *   //  165, 239, 190, 159, 239, 189, 165]
         *   Pot.debug(Pot.ArrayBufferoid.bufferToString(buffer));
         *   // 'ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･'
         *
         *
         * @param  {String}              string   A base64 string.
         * @return {Pot.ArrayBufferoid}           A new instance of
         *                                          Pot.ArrayBufferoid.
         * @type  Function
         * @function
         * @static
         * @public
         */
        asBuffer : function(string) {
          return new Decoder(string, BASE64URLMAPS).executeAsBuffer();
        },
        /**
         * Decodes a string from base64 for URL safely with Deferred.
         *
         *
         * @example
         *   var string = '(*>_<*)';
         *   Pot.base64URLEncode.deferred(string).then(function(encoded) {
         *     debug(encoded);
         *     // @results 'KCo-XzwqKQ=='
         *     return Pot.base64URLDecode.deferred(encoded)
         *                               .then(function(decoded) {
         *       debug(decoded);
         *       // @results '(*>_<*)'
         *     });
         *   });
         *
         *
         * @example
         *   var string = 'ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･';
         *   Pot.base64URLEncode.deferred(string).then(function(encoded) {
         *     return Pot.base64URLDecode.deferred(encoded)
         *                               .then(function(decoded) {
         *       debug(
         *         'string  = ' + string + '\n' +
         *         'encoded = ' + encoded + '\n' +
         *         'decoded = ' + decoded
         *       );
         *       // @results
         *       //   string  = ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･
         *       //   encoded = 776fK--9oToub--9pe--n--9peKUo8Ko
         *       //             77234pSjwqjvvbfimIbvvaXvvp_vvaU=
         *       //   decoded = ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･
         *     });
         *   });
         *
         *
         * @param  {String}        string   A base64 string.
         * @return {Pot.Deferred}           Returns new instance of
         *                                    Pot.Deferred with a string.
         * @type  Function
         * @function
         * @static
         * @public
         *
         * @property {Function} limp   Run with slowest speed.
         * @property {Function} doze   Run with slower speed.
         * @property {Function} slow   Run with slow speed.
         * @property {Function} normal Run with default speed.
         * @property {Function} fast   Run with fast speed.
         * @property {Function} rapid  Run with faster speed.
         * @property {Function} ninja  Run fastest speed.
         */
        deferred : PotInternal.defineDeferrater(function(speed) {
          return function(string) {
            return new Decoder(string, BASE64URLMAPS).deferred(speed);
          };
        }),
        /**
         * Decodes a string as ArrayBuffer from base64 for
         *   URL safely with Deferred.
         *
         *
         * @example
         *   var b64string = 'SGVsbG8gV29ybGQu';
         *   Pot.base64URLDecode.deferredAsBuffer(b64string)
         *                                    .then(function(buffer) {
         *     Pot.debug(buffer);
         *     // [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 46]
         *     Pot.debug(Pot.ArrayBufferoid.bufferToString(buffer));
         *     // 'Hello World.'
         *   });
         *
         *
         * @example
         *   var base64String = '776fK--9oToub--9pe--n--9peKUo8Ko' +
         *                      '77234pSjwqjvvbfimIbvvaXvvp_vvaU=';
         *   Pot.base64URLDecode.deferredAsBuffer(base64String)
         *                      .then(function(res) {
         *     Pot.debug(res);
         *     // [239, 190, 159,  43, 239, 189, 161,  58,  46, 111,
         *     //  239, 189, 165, 239, 190, 159, 239, 189, 165, 226,
         *     //  148, 163, 194, 168, 239, 189, 183, 226, 148, 163,
         *     //  194, 168, 239, 189, 183, 226, 152, 134, 239, 189,
         *     //  165, 239, 190, 159, 239, 189, 165]
         *     Pot.debug(Pot.ArrayBufferoid.bufferToString(res));
         *     // 'ﾟ+｡:.o･ﾟ･┣¨ｷ┣¨ｷ☆･ﾟ･'
         *   });
         *
         *
         * @param  {String}        string   A base64 string.
         * @return {Pot.Deferred}           Returns new instance of
         *                                    Pot.Deferred with a new
         *                                    instance of Pot.ArrayBufferoid.
         * @type  Function
         * @function
         * @static
         * @public
         *
         * @property {Function} limp   Run with slowest speed.
         * @property {Function} doze   Run with slower speed.
         * @property {Function} slow   Run with slow speed.
         * @property {Function} normal Run with default speed.
         * @property {Function} fast   Run with fast speed.
         * @property {Function} rapid  Run with faster speed.
         * @property {Function} ninja  Run fastest speed.
         */
        deferredAsBuffer : PotInternal.defineDeferrater(function(speed) {
          return function(string) {
            return new Decoder(string, BASE64URLMAPS).deferredAsBuffer(speed);
          };
        })
      })
    };
  }())
});

// Update Pot object.
Pot.update({
  base64Encode    : Pot.Base64.encode,
  base64Decode    : Pot.Base64.decode,
  base64URLEncode : Pot.Base64.urlEncode,
  base64URLDecode : Pot.Base64.urlDecode
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Archive.
(function(ALPHAMERIC_BASE63MAPS) {

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Archive utilities.
   *
   * @name Pot.Archive
   * @type Object
   * @class
   * @static
   * @public
   */
  Archive : {}
});

update(Pot.Archive, {
  /**
   * @lends Pot.Archive
   */
  /**
   * Compress/Decompress the data using the LZ77 algorithm.
   *
   * cf. @link http://www.ietf.org/rfc/rfc1951.txt
   *
   * via AlphamericHTML
   *
   * @link http://nurucom-archives.hp.infoseek.co.jp/digital/
   *
   * @name  Pot.Archive.AlphamericString
   * @type  Object
   * @class
   * @static
   * @public
   */
  AlphamericString : {
    /**
     * @lends Pot.Archive.AlphamericString
     */
    /**
     * Compress with encode a string to
     *   the base 63 [a-zA-Z0-9_] format string.
     *
     *
     * @example
     *   var string = 'Hello Hello foooooooo baaaaaaaar';
     *   var result = Pot.Archive.AlphamericString.encode(string);
     *   var decode = Pot.Archive.AlphamericString.decode(result);
     *   debug('string = ' + string + ' : length = ' + string.length);
     *   debug('result = ' + result + ' : length = ' + result.length);
     *   debug('decode = ' + decode + ' : length = ' + decode.length);
     *   // @results
     *   //   string = 'Hello Hello foooooooo baaaaaaaar' : length = 32
     *   //   result = 'Y8Z5CCF_v56F__5X0Z21__5I'         : length = 24
     *   //   decode = 'Hello Hello foooooooo baaaaaaaar' : length = 32
     *
     *
     * @example
     *   // Example of compression that is include multibyte string.
     *   var string = 'Hello Hello こんにちは、こんにちは、にゃーにゃー';
     *   var result = Pot.Archive.AlphamericString.encode(string);
     *   var decode = Pot.Archive.AlphamericString.decode(result);
     *   // Note the change of byte size.
     *   var bytesS = utf8ByteOf(string);
     *   var bytesR = utf8ByteOf(result);
     *   var bytesD = utf8ByteOf(decode);
     *   debug('string=' + string + ', length=' + string.length +
     *         ', ' + bytesS + ' bytes');
     *   debug('result=' + result + ', length=' + result.length +
     *         ', ' + bytesR + ' bytes');
     *   debug('decode=' + decode + ', length=' + decode.length +
     *         ', ' + bytesD + ' bytes');
     *   // @results
     *   //   string = 'Hello Hello こんにちは、こんにちは、にゃーにゃー',
     *   //     length = 30,
     *   //     66 bytes
     *   //
     *   //   result = 'Y8Z5CCF_v5cJeJdB1Fa1_v4dBe3hS_y1',
     *   //     length = 32,
     *   //     32 bytes
     *   //
     *   //   decode = 'Hello Hello こんにちは、こんにちは、にゃーにゃー',
     *   //     length = 30,
     *   //     66 bytes
     *   //
     *
     *
     * @param  {String}  string  An input string.
     * @return {String}          A result string.
     * @type  Function
     * @function
     * @static
     * @public
     */
    encode : (function() {
      /**@ignore*/
      var AlphamericStringEncoder = function(string) {
        return new AlphamericStringEncoder.prototype.init(string);
      },
      encodeMaps = ALPHAMERIC_BASE63MAPS.split('');
      AlphamericStringEncoder.prototype =
        update(AlphamericStringEncoder.prototype, {
        /**
         * @private
         * @ignore
         * @internal
         */
        constructor : AlphamericStringEncoder,
        /**
         * @private
         * @ignore
         * @internal
         */
        string : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        dic : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        maps : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        index : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        pos : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        size : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        point : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        last : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        results : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        max : null,
        /**
         * Initialize properties.
         *
         * @private
         * @ignore
         */
        init : function(string) {
          this.index = 0x03F6;
          this.maps = encodeMaps;
          this.string = this.createDic() + stringify(string);
          this.results = [];
          this.point = -1;
          this.max = 0x40;
          return this;
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        execute : function() {
          var buffer, max = this.max;
          while (true) {
            buffer = this.string.substr(this.index, max);
            if (!buffer) {
              break;
            }
            this.searchSlidingWindow(buffer);
            if (this.size === 2 ||
                this.size === 3 && this.last === this.point) {
              this.pushLite();
            } else {
              this.pushStep();
            }
          }
          return this.results.join('');
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        deferred : function(speed) {
          var that = this, max = this.max;
          return Deferred.forEver[speed](function() {
            var buffer = that.string.substr(that.index, max);
            if (!buffer) {
              throw PotStopIteration;
            }
            that.searchSlidingWindow(buffer);
            if (that.size === 2 ||
                that.size === 3 && that.last === that.point) {
              that.pushLite();
            } else {
              that.pushStep();
            }
          }).then(function() {
            return that.results.join('');
          });
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        createDic : function() {
          var dic = ' ';
          for (; this.index < 0x400; this.index++) {
            dic += dic;
          }
          return dic;
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        searchSlidingWindow : function(buffer) {
          var pos, len = buffer.length;
          for (this.size = 2; this.size <= len; this.size++) {
            pos = this.string.substring(
              this.index - 0x333,
              this.index + this.size - 1
            ).lastIndexOf(buffer.substring(0, this.size));
            if (!~pos) {
              break;
            }
            this.pos = pos;
          }
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        pushLite : function() {
          var c, x, r = this.results, m = this.maps;
          this.last = this.point;
          c = this.string.charCodeAt(this.index++);
          if (c < 0x80) {
            x = c;
            c %= 0x20;
            this.point = (x - c) / 0x20 + 0x40;
            if (this.last !== this.point) {
              r[r.length] = m[this.point - 0x20];
            }
            r[r.length] = m[c];
          } else if (0x3000 <= c && c < 0x3100) {
            c -= 0x3000;
            x = c;
            c %= 0x20;
            this.point = (x - c) / 0x20 + 0x44;
            if (this.last !== this.point) {
              r[r.length] = m[this.point - 0x20];
            }
            r[r.length] = m[c];
          } else if (0xFF00 <= c && c < 0xFFA0) {
            c -= 0xFF00;
            x = c;
            c %= 0x20;
            this.point = (x - c) / 0x20 + 0x4C;
            if (this.last !== this.point) {
              r[r.length] = m[this.point - 0x20];
            }
            r[r.length] = m[c];
          } else {
            x = c;
            c %= 0x7C0;
            this.point = (x - c) / 0x7C0;
            if (this.last !== this.point) {
              r[r.length] = m[0x31] + m[this.point];
            }
            x = c;
            c %= 0x3E;
            r[r.length] = m[(x - c) / 0x3E] + m[c];
          }
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        pushStep : function() {
          var x = this.pos, m = this.maps, r = this.results;
          this.pos %= 0x3F;
          r[r.length] = m[(x - this.pos) / 0x3F + 0x32] +
                        m[this.pos] +
                        m[this.size - 3];
          this.index += this.size - 1;
        }
      });
      AlphamericStringEncoder.prototype.init.prototype =
        AlphamericStringEncoder.prototype;
      return update(function(string) {
        return (new AlphamericStringEncoder(string)).execute();
      }, {
        /**
         * @lends Pot.Archive.AlphamericString.encode
         */
        /**
         * Compress with encode a string to
         *   the base 63 [a-zA-Z0-9_] format string with Deferred.
         *
         *
         * @example
         *   var string = 'Hello Hello foooooooo baaaaaaaar';
         *   var encoded, decoded;
         *   // Execute deferred.
         *   Pot.alphamericStringEncode.deferred(string).then(function(res) {
         *     encoded = res;
         *     return Pot.alphamericStringDecode.deferred(encoded);
         *   }).then(function(res) {
         *     decoded = res;
         *     debug('string = ' + string  + ' : length = ' + string.length);
         *     debug('result = ' + encoded + ' : length = ' + encoded.length);
         *     debug('decode = ' + decoded + ' : length = ' + decoded.length);
         *     // @results
         *     //   string = 'Hello Hello foooooooo baaaaaaaar' : length = 32
         *     //   result = 'Y8Z5CCF_v56F__5X0Z21__5I'         : length = 24
         *     //   decode = 'Hello Hello foooooooo baaaaaaaar' : length = 32
         *   });
         *
         *
         * @example
         *   // Example of compression that is include multibyte string.
         *   var string, encoded, decoded;
         *   string = 'Hello Hello こんにちは、こんにちは、にゃーにゃー';
         *   Pot.alphamericStringEncode.deferred(string).then(function(res) {
         *     encoded = res;
         *     Pot.alphamericStringDecode.deferred(res).then(function(res) {
         *       decoded = res;
         *       // Note the change of byte size.
         *       var bytesString  = utf8ByteOf(string);
         *       var bytesEncoded = utf8ByteOf(encoded);
         *       var bytesDecoded = utf8ByteOf(decoded);
         *       debug(
         *         'string=' + string +
         *         ', length=' + string.length +
         *         ', ' + bytesString + ' bytes'
         *       );
         *       debug(
         *         'result=' + encoded +
         *         ', length=' + encoded.length +
         *         ', ' + bytesEncoded + ' bytes'
         *       );
         *       debug(
         *         'decode=' + decoded +
         *         ', length=' + decoded.length +
         *         ', ' + bytesDecoded + ' bytes'
         *       );
         *       // @results
         *       // string='Hello Hello こんにちは、こんにちは、にゃーにゃー',
         *       //   length = 30,
         *       //   66 bytes
         *       //
         *       // result = 'Y8Z5CCF_v5cJeJdB1Fa1_v4dBe3hS_y1',
         *       //   length = 32,
         *       //   32 bytes
         *       //
         *       // decode='Hello Hello こんにちは、こんにちは、にゃーにゃー',
         *       //   length = 30,
         *       //   66 bytes
         *     });
         *   });
         *
         *
         * @param  {String}        string  An input string.
         * @return {Pot.Deferred}          Returns new instance of
         *                                   Pot.Deferred with
         *                                   a result string.
         * @type  Function
         * @function
         * @static
         * @public
         *
         * @property {Function} limp   Run with slowest speed.
         * @property {Function} doze   Run with slower speed.
         * @property {Function} slow   Run with slow speed.
         * @property {Function} normal Run with default speed.
         * @property {Function} fast   Run with fast speed.
         * @property {Function} rapid  Run with faster speed.
         * @property {Function} ninja  Run fastest speed.
         */
        deferred : PotInternal.defineDeferrater(function(speed) {
          return function(string) {
            return (new AlphamericStringEncoder(string)).deferred(speed);
          }
        })
      });
    }()),
    /**
     * @lends Pot.Archive.AlphamericString
     */
    /**
     * Decompress with decode a string from
     *   the AlphamericString (base 63 [a-zA-Z0-9_] format string).
     *
     *
     * @example
     *   var string = 'Hello Hello foooooooo baaaaaaaar';
     *   var result = Pot.Archive.AlphamericString.encode(string);
     *   var decode = Pot.Archive.AlphamericString.decode(result);
     *   debug('string = ' + string + ' : length = ' + string.length);
     *   debug('result = ' + result + ' : length = ' + result.length);
     *   debug('decode = ' + decode + ' : length = ' + decode.length);
     *   // @results
     *   //   string = 'Hello Hello foooooooo baaaaaaaar' : length = 32
     *   //   result = 'Y8Z5CCF_v56F__5X0Z21__5I'         : length = 24
     *   //   decode = 'Hello Hello foooooooo baaaaaaaar' : length = 32
     *
     *
     * @example
     *   // Example of compression that is include multibyte string.
     *   var string = 'Hello Hello こんにちは、こんにちは、にゃーにゃー';
     *   var result = Pot.Archive.AlphamericString.encode(string);
     *   var decode = Pot.Archive.AlphamericString.decode(result);
     *   // Note the change of byte size.
     *   var bytesS = utf8ByteOf(string);
     *   var bytesR = utf8ByteOf(result);
     *   var bytesD = utf8ByteOf(decode);
     *   debug('string=' + string + ', length=' + string.length +
     *         ', ' + bytesS + ' bytes');
     *   debug('result=' + result + ', length=' + result.length +
     *         ', ' + bytesR + ' bytes');
     *   debug('decode=' + decode + ', length=' + decode.length +
     *         ', ' + bytesD + ' bytes');
     *   // @results
     *   //   string = 'Hello Hello こんにちは、こんにちは、にゃーにゃー',
     *   //     length = 30,
     *   //     66 bytes
     *   //
     *   //   result = 'Y8Z5CCF_v5cJeJdB1Fa1_v4dBe3hS_y1',
     *   //     length = 32,
     *   //     32 bytes
     *   //
     *   //   decode = 'Hello Hello こんにちは、こんにちは、にゃーにゃー',
     *   //     length = 30,
     *   //     66 bytes
     *   //
     *
     *
     * @param  {String}  a  A input string.
     * @return {String}     A result string.
     * @type  Function
     * @function
     * @static
     * @public
     */
    decode : (function() {
      /**@ignore*/
      var AlphamericStringDecoder = function(string) {
        return new AlphamericStringDecoder.prototype.init(string);
      };
      AlphamericStringDecoder.prototype =
        update(AlphamericStringDecoder.prototype, {
        /**
         * @private
         * @ignore
         * @internal
         */
        constructor : AlphamericStringDecoder,
        /**
         * @private
         * @ignore
         * @internal
         */
        string : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        dics : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        result : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        isCentral : null,
        /**
         * @private
         * @ignore
         * @internal
         */
        code : null,
        /**
         * Initialize properties.
         *
         * @private
         * @ignore
         */
        init : function(string) {
          this.string = stringify(string);
          this.index = 0;
          this.dics = {};
          this.result = (new Array(5)).join(' ');
          this.createDic();
          return this;
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        execute : function() {
          var c;
          while (true) {
            c = this.peek();
            if (c < 0x3F) {
              this.decode(c);
            } else {
              break;
            }
          }
          return this.result.slice(0x400);
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        deferred : function(speed) {
          var that = this;
          return Deferred.forEver[speed](function() {
            var c = that.peek();
            if (c < 0x3F) {
              that.decode(c);
            } else {
              throw PotStopIteration;
            }
          }).then(function() {
            return that.result.slice(0x400);
          });
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        createDic : function() {
          for (; this.index < 0x3F; this.index++) {
            this.dics[ALPHAMERIC_BASE63MAPS.charAt(this.index)] = this.index;
          }
          while ((this.index -= 7)) {
            this.result += this.result;
          }
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        peek : function() {
          return this.dics[this.string.charAt(this.index++)];
        },
        /**
         * @private
         * @ignore
         * @internal
         */
        decode : function(c) {
          var code, pos, size, bounds, buffer;
          if (c < 0x20) {
            code = this.code * 0x20 + c;
            if (!this.isCentral) {
              code = code * 0x3E + this.peek();
            }
            this.result += fromUnicode(code);
          } else if (c < 0x31) {
            if (c < 0x24) {
              this.code = c - 0x20;
            } else if (c < 0x2C) {
              this.code = c + 0x15C;
            } else {
              this.code = c + 0x7CC;
            }
            this.isCentral = true;
          } else if (c < 0x32) {
            this.code = this.peek();
            this.isCentral = false;
          } else {
            buffer = this.result.slice(-0x333);
            pos = (c - 0x32) * 0x3F + this.peek();
            size = pos + this.peek() + 2;
            bounds = buffer.substring(pos, size);
            if (bounds) {
              while (buffer.length < size) {
                buffer += bounds;
              }
            }
            this.result += buffer.substring(pos, size);
          }
        }
      });
      AlphamericStringDecoder.prototype.init.prototype =
        AlphamericStringDecoder.prototype;
      return update(function(string) {
        return (new AlphamericStringDecoder(string)).execute();
      }, {
        /**
         * @lends Pot.Archive.AlphamericString.decode
         */
        /**
         * Decompress with decode a string from
         *   the AlphamericString (base 63 [a-zA-Z0-9_] format string)
         *   with Deferred.
         *
         *
         * @example
         *   var string = 'Hello Hello foooooooo baaaaaaaar';
         *   var encoded, decoded;
         *   // Execute deferred.
         *   Pot.alphamericStringEncode.deferred(string).then(function(res) {
         *     encoded = res;
         *     return Pot.alphamericStringDecode.deferred(encoded);
         *   }).then(function(res) {
         *     decoded = res;
         *     debug('string = ' + string  + ' : length = ' + string.length);
         *     debug('result = ' + encoded + ' : length = ' + encoded.length);
         *     debug('decode = ' + decoded + ' : length = ' + decoded.length);
         *     // @results
         *     //   string = 'Hello Hello foooooooo baaaaaaaar' : length = 32
         *     //   result = 'Y8Z5CCF_v56F__5X0Z21__5I'         : length = 24
         *     //   decode = 'Hello Hello foooooooo baaaaaaaar' : length = 32
         *   });
         *
         *
         * @example
         *   // Example of compression that is include multibyte string.
         *   var string, encoded, decoded;
         *   string = 'Hello Hello こんにちは、こんにちは、にゃーにゃー';
         *   Pot.alphamericStringEncode.deferred(string).then(function(res) {
         *     encoded = res;
         *     Pot.alphamericStringDecode.deferred(res).then(function(res) {
         *       decoded = res;
         *       // Note the change of byte size.
         *       var bytesString  = utf8ByteOf(string);
         *       var bytesEncoded = utf8ByteOf(encoded);
         *       var bytesDecoded = utf8ByteOf(decoded);
         *       debug(
         *         'string=' + string +
         *         ', length=' + string.length +
         *         ', ' + bytesString + ' bytes'
         *       );
         *       debug(
         *         'result=' + encoded +
         *         ', length=' + encoded.length +
         *         ', ' + bytesEncoded + ' bytes'
         *       );
         *       debug(
         *         'decode=' + decoded +
         *         ', length=' + decoded.length +
         *         ', ' + bytesDecoded + ' bytes'
         *       );
         *       // @results
         *       // string='Hello Hello こんにちは、こんにちは、にゃーにゃー',
         *       //   length = 30,
         *       //   66 bytes
         *       //
         *       // result = 'Y8Z5CCF_v5cJeJdB1Fa1_v4dBe3hS_y1',
         *       //   length = 32,
         *       //   32 bytes
         *       //
         *       // decode='Hello Hello こんにちは、こんにちは、にゃーにゃー',
         *       //   length = 30,
         *       //   66 bytes
         *     });
         *   });
         *
         *
         * @param  {String}        string  An input string.
         * @return {Pot.Deferred}          Returns new instance of
         *                                   Pot.Deferred with
         *                                   a result string.
         * @type  Function
         * @function
         * @static
         * @public
         *
         * @property {Function} limp   Run with slowest speed.
         * @property {Function} doze   Run with slower speed.
         * @property {Function} slow   Run with slow speed.
         * @property {Function} normal Run with default speed.
         * @property {Function} fast   Run with fast speed.
         * @property {Function} rapid  Run with faster speed.
         * @property {Function} ninja  Run fastest speed.
         */
        deferred : PotInternal.defineDeferrater(function(speed) {
          return function(string) {
            return (new AlphamericStringDecoder(string)).deferred(speed);
          }
        })
      });
    }())
  }
});

// Update Pot object.
Pot.update({
  alphamericStringEncode : Pot.Archive.AlphamericString.encode,
  alphamericStringDecode : Pot.Archive.AlphamericString.decode
});

}(DIGITS + UPPER_ALPHAS + LOWER_ALPHAS + '_'));

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Format.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Format utilities.
   *
   * @name Pot.Format
   * @type Object
   * @class
   * @static
   * @public
   */
  Format : {}
});

update(Pot.Format, {
  /**
   * @lends Pot.Format
   */
  /**
   * Formats to a string by arguments.
   *
   *
   * @example
   *   var result = format('#1 + #2 + #3', 10, 20, 30);
   *   debug(result);
   *   // @results '10 + 20 + 30'
   *
   *
   * @example
   *   var result = format('J#1v#1#2 ECMA#2', 'a', 'Script');
   *   debug(result);
   *   // @results 'JavaScript ECMAScript'
   *
   *
   * @param  {String}   fmt   A string format.
   * @param  {...*}    (...)  Format arguments.
   * @return {String}         Returns a formatted string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  format : Pot.format,
  /**
   * sprintf.
   *
   * This function is compatible with PHP sprintf function that
   *  was referenced from the PHP source code.
   *
   * @link http://php.net/function.sprintf
   *
   * <pre>
   * Extended type specifiers:
   *
   *   - a : Return the string in lowercase the result encoded in base 36.
   *   - A : Return the string in uppercase the result encoded in base 36.
   *   - n : Return the string that is formatted number with grouped thousands.
   *
   * </pre>
   *
   *
   * @example
   *   var num = 5;
   *   var place = 'tree';
   *   var result = sprintf('There are %d monkeys in the %s.', num, place);
   *   debug(result);
   *   // @results 'There are 5 monkeys in the tree.'
   *
   *
   * @example
   *   var n =  43951789;
   *   var u = -43951789;
   *   var c = 65; // ASCII 65 is 'A'
   *   // notice the double %%, this prints a literal '%' character
   *   debug(sprintf("%%b = '%b'", n)); // binary
   *   debug(sprintf("%%c = '%c'", c)); // print the ascii character
   *   debug(sprintf("%%d = '%d'", n)); // standard integer
   *   debug(sprintf("%%e = '%e'", n)); // scientific notation
   *   debug(sprintf("%%u = '%u'", n)); // unsigned integer (positive)
   *   debug(sprintf("%%u = '%u'", u)); // unsigned integer (negative)
   *   debug(sprintf("%%f = '%f'", n)); // floating point
   *   debug(sprintf("%%o = '%o'", n)); // octal
   *   debug(sprintf("%%s = '%s'", n)); // string
   *   debug(sprintf("%%x = '%x'", n)); // hexadecimal (lower-case)
   *   debug(sprintf("%%X = '%X'", n)); // hexadecimal (upper-case)
   *   debug(sprintf("%%+d = '%+d'", n)); // sign specifier (positive)
   *   debug(sprintf("%%+d = '%+d'", u)); // sign specifier (negative)
   *   debug(sprintf("%%a = '%a'", n)); // base 36 format (lower-case)
   *   debug(sprintf("%%A = '%A'", n)); // base 36 format (upper-case)
   *   // @results
   *   //   %b = '10100111101010011010101101'
   *   //   %c = 'A'
   *   //   %d = '43951789'
   *   //   %e = '4.395179e+7'
   *   //   %u = '43951789'
   *   //   %u = '4251015507'
   *   //   %f = '43951789.000000'
   *   //   %o = '247523255'
   *   //   %s = '43951789'
   *   //   %x = '29ea6ad'
   *   //   %X = '29EA6AD'
   *   //   %+d = '+43951789'
   *   //   %+d = '-43951789'
   *   //   %a = 'q61f1'
   *   //   %A = 'Q61F1'
   *
   *
   * @example
   *   var date  = new Date();
   *   var year  = date.getFullYear();
   *   var month = date.getMonth() + 1;
   *   var day   = date.getDate();
   *   var isoDate = sprintf('%04d-%02d-%02d', year, month, day);
   *   debug(isoDate);
   *   // @results '2011-09-01'
   *
   *
   * @example
   *   var s = 'monkey';
   *   var t = 'many monkeys';
   *   debug(sprintf("[%s]",      s)); // standard string output
   *   debug(sprintf("[%10s]",    s)); // right-justification with spaces
   *   debug(sprintf("[%-10s]",   s)); // left-justification with spaces
   *   debug(sprintf("[%010s]",   s)); // zero-padding works on strings too
   *   debug(sprintf("[%'#10s]",  s)); // use the custom padding character '#'
   *   debug(sprintf("[%10.10s]", t)); // left-justification but with a
   *                                   //   cutoff of 10 characters
   *   // @results
   *   //   [monkey]
   *   //   [    monkey]
   *   //   [monkey    ]
   *   //   [0000monkey]
   *   //   [####monkey]
   *   //   [many monke]
   *
   *
   * @example
   *   Pot.debug(Pot.sprintf('%n', 1234567890)); // 1,234,567,890
   *   Pot.debug(Pot.sprintf('%n', 12345678.9)); // 12,345,678.9
   *   Pot.debug(Pot.sprintf('%n', 123));        // 123
   *
   *
   * @param  {String}  format   The format string is composed of zero or
   *                              more directives: ordinary characters
   *                              (excluding %) that are copied directly
   *                              to the result, and conversion
   *                              specifications, each of which results
   *                              in fetching its own parameter.
   * @param  {...*}    (...)    The variable arguments that will be
   *                              conversion specifier value.
   * @return {String}           The result string.
   *
   * @type  Function
   * @function
   * @static
   * @public
   */
  sprintf : function(/*format[, ...args]*/) {
    var me = Pot.Format.sprintf;
    if (!me.formatProcedure) {
      /**@ignore*/
      me.formatProcedure = (function() {
        var args,
            re = /%%|%('?(?:[0\u0020+-]|[^%\w.-])+|)(\d*|)(\.\d*|)([%a-z])/gi,
            ren = /\d{1,3}(?=(?:\d{3})+(?:[.]\d+|)$)/g;
        /**@ignore*/
        function utf8(s) {
          return Pot.UTF8 && Pot.UTF8.encode(s) || stringify(s);
        }
        /**@ignore*/
        function parse(n, isFloat) {
          var r = isFloat ? parseFloat(n) : parseInt(n, 10);
          return isNaN(r) ? 0 : r;
        }
        /**@ignore*/
        function base(n, val) {
          var r, i, len, octets;
          if (isNumeric(val)) {
            r = (parse(val) >>> 0).toString(n);
          } else {
            r = '';
            octets = utf8(val);
            len = octets.length;
            for (i = 0; i < len; ++i) {
              r += octets.charCodeAt(i).toString(n);
            }
          }
          return String((r && r.length) ? r : 0);
        }
        /**@ignore*/
        function pad(value, mark, width, precision, left, numeric) {
          var glue;
          width = width - 0;
          precision = precision - 0;
          if (value.length < width) {
            mark = stringify(mark) || ' ';
            glue = new Array(width + 1).join(mark).split('');
            while (glue && (glue.length + value.length > width)) {
              if (left) {
                glue.pop();
              } else {
                glue.shift();
              }
            }
            glue = glue.join('');
            value = left ? glue + value : value + glue;
          }
          return value;
        }
        /**@ignore*/
        function justify(value, mark, width, precision, left, numeric) {
          var sign, orgn, index, i, prevIdx;
          if (numeric) {
            value = value.toString();
            if (mark.charAt(0) === '+') {
              if (value - 0 >= 0) {
                if (isFunction(numeric)) {
                  value = mark.charAt(0) + numeric(value);
                } else {
                  value = mark.charAt(0) + (value - 0);
                }
              }
              mark = mark.substring(1);
            }
            if (mark.charAt(0) === '-') {
              left = false;
              mark = '';
            }
            sign = value.charAt(0);
            if (!~'+-'.indexOf(sign)) {
              sign = null;
            } else {
              orgn = value.substring(1);
            }
          }
          width = String(width).length ? (width - 0) : -1;
          precision = String(precision).length ? (precision - 0) : -1;
          if (width === 0) {
            value = '';
          } else {
            if (precision > 0) {
              value = value.slice(0, precision);
            }
            if (width > 0 && width > value.length) {
              value = pad(value, mark, width, precision, left, numeric);
            }
          }
          if (numeric && orgn && sign) {
            i = 1;
            do {
              prevIdx = index;
              index = value.indexOf(sign + orgn.slice(0, i));
            } while (index > 0 && ++i < value.length);
            if (!~index) {
              index = prevIdx;
            }
            if (index > 0) {
              value = sign + value.slice(0, index) + value.slice(index + 1);
            }
          }
          return value;
        }
        /**@ignore*/
        function rep(all, mark, width, precision, type) {
          var result = '', v, left, numeric = false, point;
          if (all === '%%') {
            result = '%';
          } else {
            left = true;
            if (mark.slice(-1) === '-') {
              left = false;
              mark = mark.slice(0, -1);
            }
            if (mark.indexOf("'") === 0) {
              if (mark.length > 1) {
                mark = mark.substring(1);
              }
            }
            if (precision.indexOf('.') === 0) {
              precision = precision.substring(1);
            }
            v = stringify(args.shift());
            switch (type) {
              case 'b':
                  v = base(2, v);
                  break;
              case 'c':
                  try {
                    v = isNumeric(v) ? fromUnicode(v) : '';
                  } catch (e) {
                    v = '';
                  }
                  break;
              case 'd':
                  numeric = true;
                  v = parse(v);
                  break;
              case 'u':
                  numeric = true;
                  v = (parse(v) >>> 0);
                  break;
              case 'e':
                  numeric = true;
                  point = 6;
                  v = parse(v, true);
                  if (precision) {
                    if (isNumeric(precision)) {
                      point = Math.max(0, Math.min(20, precision));
                    }
                    precision = null;
                  }
                  /**@ignore*/
                  numeric = function(n) {
                    return (+n).toExponential(point);
                  };
                  v = numeric(v);
                  break;
              case 'f':
                  numeric = true;
                  point = 6;
                  v = parse(v, true);
                  if (precision) {
                    if (isNumeric(precision)) {
                      precision = ((v < 0) ? 1 : 0) + (precision - 0);
                      point = Math.max(0, Math.min(20, precision));
                    }
                    precision = null;
                  }
                  /**@ignore*/
                  numeric = function(n) {
                    return (n - 0).toFixed(point);
                  };
                  v = numeric(v);
                  break;
              case 'o':
                  v = base(8, v);
                  break;
              case 'x':
                  v = base(16, v).toLowerCase();
                  break;
              case 'X':
                  v = base(16, v).toUpperCase();
                  break;
              case 's':
                  break;
              case 'a':
                  v = base(36, v).toLowerCase();
                  break;
              case 'A':
                  v = base(36, v).toUpperCase();
                  break;
              case 'n':
                  v = ('' + parse(v, true)).replace(ren, '$&,');
            }
            result = justify(v, mark, width, precision, left, numeric);
          }
          return ('' + result);
        }
        return function(format) {
          args = arrayize(arguments, 1);
          return stringify(format).replace(re, rep);
        };
      }());
    }
    return me.formatProcedure.apply(me, arguments);
  }
});

// Update Pot object.
Pot.update({
  format  : Pot.Format.format,
  sprintf : Pot.Format.sprintf
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of MimeType.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * MIME Types utilities.
   *
   * This object is not use "navigator.mimeTypes"
   *   for x-browser and non-browser environment.
   *
   * @name Pot.MimeType
   * @type Object
   * @class
   * @static
   * @public
   */
  MimeType : {}
});

update(Pot.MimeType, {
  /**
   * @lends Pot.MimeType
   */
  /**
   * Gets the extension name from the MIME Type.
   *
   *
   * @example
   *   debug( getExtByMimeType('application/javascript') );
   *   // @results 'js'
   *
   *
   * @param  {String}  mimeType   MIME Type.
   * @return {String}             Extension name.
   * @type  Function
   * @function
   * @static
   * @public
   */
  getExtByMimeType : function(mimeType) {
    var result = '', ext, mime, mimes,
        mtype, ltype, part, i, len,
        maps = Pot.MimeType.MimeTypeMaps,
        type = trim(mimeType).toLowerCase();
    if (type) {
      each(maps, function(v, k) {
        ext = k;
        mime = String(v).toLowerCase();
        if (mime === type) {
          result = ext;
          throw PotStopIteration;
        }
      });
      if (!result) {
        each(maps, function(v, k) {
          ext = k;
          mime = String(v).toLowerCase().split('/').pop();
          if (~type.indexOf(mime)) {
            result = ext;
            throw PotStopIteration;
          }
        });
        if (!result) {
          try {
            // helper if not match.
            if (typeof navigator === 'object' && navigator.mimeTypes) {
              mimes = navigator.mimeTypes;
              if (type in mimes) {
                mime = mimes[type];
                if (mime && mime.suffixes) {
                  mtype = mime;
                }
              } else {
                part = type.split('/').pop();
                len = mimes.length;
                for (i = 0; i < len; i++) {
                  mime = mimes[i];
                  if (mime && mime.suffixes) {
                    ltype = String(mime.type).toLowerCase();
                    if (~ltype.indexOf(type) || ~type.indexOf(ltype) ||
                        ~part.indexOf(ltype.split('/').pop()) ||
                        ~ltype.split('/').pop().indexOf(part)) {
                      mtype = mime;
                      break;
                    }
                  }
                }
              }
              if (mtype) {
                result = String(mtype.suffixes).replace(/^\s*(\w+).*$/, '$1');
              }
            }
          } catch (e) {
            result = '';
          }
        }
      }
    }
    return stringify(result, true);
  },
  /**
   * Gets the MIME Type from the extension name.
   *
   *
   * @example
   *   debug( getMimeTypeByExt('js') );
   *   // @results 'application/javascript'
   *
   *
   * @param  {String}   extension   Extension name.
   * @return {String}               MIME Type.
   * @type  Function
   * @function
   * @static
   * @public
   */
  getMimeTypeByExt : function(extension) {
    var result = '', ext, mimes, mime, re, i, len,
        maps = Pot.MimeType.MimeTypeMaps;
    if (~String(extension).indexOf('.')) {
      if (Pot.URI) {
        ext = trim(Pot.URI.getExt(extension)).toLowerCase();
      } else {
        ext = trim(extension).toLowerCase().split('.').pop();
      }
    } else {
      ext = trim(extension).toLowerCase();
    }
    if (ext in maps) {
      result = maps[ext];
    }
    if (!result) {
      try {
        if (typeof navigator === 'object' && navigator.mimeTypes) {
          mimes = navigator.mimeTypes;
          re = new RegExp('(?:^|\\b)' + rescape(ext) + '(?:\\b|$)', 'i');
          len = mimes.length;
          for (i = 0; i < len; i++) {
            mime = mimes[i];
            if (mime && re.test(mime.suffixes)) {
              result = trim(mime.type);
              break;
            }
          }
        }
      } catch (e) {
        result = '';
      }
    }
    return stringify(result, true) || '*/*';
  },
  /**
   * A basic MIME Type object map.
   *
   * @type  Object
   * @const
   * @static
   * @public
   */
  MimeTypeMaps : {
    // text/basic
    ''   : 'application/octet-stream',
    bin  : 'application/octet-stream',
    txt  : 'text/plain',
    html : 'text/html',
    htm  : 'text/html',
    php  : 'text/html',
    css  : 'text/css',
    js   : 'application/javascript',
    json : 'application/json',
    xml  : 'application/xml',
    swf  : 'application/x-shockwave-flash',
    flv  : 'video/x-flv',
    rdf  : 'application/rdf+xml',
    xul  : 'application/vnd.mozilla.xul+xml',
    // images
    png  : 'image/png',
    jpg  : 'image/jpeg',
    jpe  : 'image/jpeg',
    jpeg : 'image/jpeg',
    gif  : 'image/gif',
    bmp  : 'image/bmp',
    ico  : 'image/vnd.microsoft.icon',
    tiff : 'image/tiff',
    tif  : 'image/tiff',
    svg  : 'image/svg+xml',
    svgz : 'image/svg+xml',
    // archives
    zip  : 'application/zip',
    rar  : 'application/x-rar-compressed',
    msi  : 'application/x-msdownload',
    exe  : 'application/x-msdownload',
    cab  : 'application/vnd.ms-cab-compressed',
    jar  : 'application/java-archive',
    lzh  : 'application/x-lzh-compressed',
    lha  : 'application/x-lzh-compressed',
    afa  : 'application/x-astrotite-afa',
    z    : 'application/x-compress',
    taz  : 'application/x-compress',
    bz2  : 'application/x-bzip',
    gz   : 'application/x-gzip',
    tgz  : 'application/x-gzip',
    tar  : 'application/x-tar',
    '7z' : 'application/x-7z-compressed',
    // audio/video
    au   : 'audio/basic',
    snd  : 'audio/basic',
    aif  : 'audio/x-aiff',
    aiff : 'audio/x-aiff',
    aifc : 'audio/x-aiff',
    m3u  : 'audio/x-mpegurl',
    ram  : 'audio/x-pn-realaudio',
    ra   : 'audio/x-pn-realaudio',
    rm   : 'application/vnd.rn-realmedia',
    wav  : 'audio/x-wav',
    midi : 'audio/midi',
    mid  : 'audio/midi',
    kar  : 'audio/midi',
    mp3  : 'audio/mpeg',
    mp2  : 'audio/mpeg',
    mpga : 'audio/mpeg',
    mp4  : 'video/mp4',
    mov  : 'video/quicktime',
    qt   : 'video/quicktime',
    mpeg : 'video/mpeg',
    mpg  : 'video/mpeg',
    mpe  : 'video/mpeg',
    mxu  : 'video/vnd.mpegurl',
    m4u  : 'video/vnd.mpegurl',
    avi  : 'video/x-msvideo',
    ogg  : 'application/ogg',
    // adobe
    pdf  : 'application/pdf',
    psd  : 'image/vnd.adobe.photoshop',
    ps   : 'application/postscript',
    ai   : 'application/postscript',
    eps  : 'application/postscript',
    // ms office
    doc  : 'application/msword',
    rtf  : 'application/rtf',
    xls  : 'application/vnd.ms-excel',
    ppt  : 'application/vnd.ms-powerpoint',
    // open office
    odt  : 'application/vnd.oasis.opendocument.text',
    ods  : 'application/vnd.oasis.opendocument.spreadsheet'
  }
});

// Update Pot object.
Pot.update({
  getExtByMimeType : Pot.MimeType.getExtByMimeType,
  getMimeTypeByExt : Pot.MimeType.getMimeTypeByExt
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Text.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Text.
   * String utilities.
   *
   * Evaluate a string can be a scalar value only.
   * Return "1" when argument was passed as Boolean's `true`.
   * This function can treat XML object that
   *  will be string by toString method.
   *
   * @see Pot.Text.stringify
   *
   * @param  {*}        x              Any value.
   * @param  {Boolean} (ignoreBoolean) Optional, Ignores Boolean value.
   * @return {String}                  Value as a string.
   *
   * @name Pot.Text
   * @type Function
   * @function
   * @class
   * @static
   * @public
   */
  Text : function() {
    return stringify.apply(null, arguments);
  }
});

update(Pot.Text, {
  /**
   * @lends Pot.Text
   */
  /**
   * Evaluate a string can be a scalar value only.
   * Return "1" when argument was passed as true.
   * This function can treat XML object that
   *  will be string by toString method.
   *
   *
   * @example
   *   debug(stringify({}));
   *   // @results ''
   *   debug(stringify([]));
   *   // @results ''
   *   debug(stringify(0));
   *   // @results '0'
   *   debug(stringify(-100.02));
   *   // @results '-100.02'
   *   debug(stringify(new Date()));
   *   // @results ''
   *   debug(stringify(null));
   *   // @results ''
   *   debug(stringify(void 0));
   *   // @results ''
   *   debug(stringify(false));
   *   // @results ''
   *   debug(stringify(true));
   *   // @results '1'
   *   debug(stringify(''));
   *   // @results ''
   *   debug(stringify('hoge'));
   *   // @results 'hoge'
   *   debug(stringify(new String('hoge')));
   *   // @results 'hoge'
   *   debug(stringify(new Boolean(false)));
   *   // @results ''
   *   debug(stringify(new Boolean(true)));
   *   // @results '1'
   *   debug(stringify([100]));
   *   // @results ''
   *
   *
   * @param  {*}        x              Any value.
   * @param  {Boolean} (ignoreBoolean) Optional, Ignores Boolean value.
   * @return {String}                  Value as a string.
   * @type Function
   * @function
   * @public
   * @static
   */
  stringify : stringify,
  /**
   * This class will be replace a particular string to temporary string,
   *  and execute the conventional process,
   *  and after back replace to the original string,
   *  these heavy step so just to make easier by this function.
   *
   *
   * @example
   *   // This sample code is process to leaving only the 'pre' tags,
   *   //  and replace all other HTML tags are escaped.
   *   var myProcess = function(string) {
   *     return string.replace(/&/g, '&amp;').
   *                   replace(/</g, '&lt;').
   *                   replace(/>/g, '&gt;');
   *   };
   *   var string =
   *     '<pre>\n' +
   *       '<b>var</b> foo = 1;\n' +
   *     '</pre>\n' +
   *     '<div>hoge</div>\n' +
   *     '<div>fuga</div>\n' +
   *     '<p onclick="alert(1)">piyo</p>\n' +
   *     '<pre>\n' +
   *       '<b>foo</b>\n' +
   *       'bar\n' +
   *       '<i>baz</i>\n' +
   *     '</pre>';
   *   var pattern = /<pre\b[^>]*>([\s\S]*?)<\/pre>/gi;
   *   // The string or Array that must not appear in the saved string.
   *   var reserve = ['<', '>'];
   *   var rs = new Pot.Text.ReplaceSaver(string, pattern, reserve);
   *   // Save and replace string for your replace process.
   *   var result = rs.save();
   *   // Execute your replace process.
   *   result = myProcess(result);
   *   // Load and replace from saved string.
   *   result = rs.load(result);
   *   debug(result);
   *   // @results
   *   //   <pre>
   *   //     <b>var</b> foo = 1;
   *   //   </pre>
   *   //   &lt;div&gt;hoge&lt;/div&gt;
   *   //   &lt;div&gt;fuga&lt;/div&gt;
   *   //   &lt;p onclick="alert(1)"&gt;piyo&lt;/p&gt;
   *   //   <pre>
   *   //     <b>foo</b>
   *   //     bar
   *   //     <i>baz</i>
   *   //   </pre>
   *
   *
   * @param  {String}               string   The target string.
   * @param  {String|RegExp|Array}  pattern  The pattern(s) to save string.
   * @param  {String|Array}        (reserve) The reserve keyword(s) for
   *                                         your replace process.
   * @return {Pot.ReplaceSaver}              Returns an instance of
   *                                           Pot.ReplaceSaver.
   * @name Pot.Text.ReplaceSaver
   * @constructor
   * @public
   */
  ReplaceSaver : (function() {
    /**@ignore*/
    var Saver = function(string, pattern, reserve) {
      return new Saver.fn.init(string, pattern, reserve);
    };
    Saver.fn = Saver.prototype = update(Saver.prototype, {
      /**
       * @lends Pot.Text.ReplaceSaver
       */
      /**
       * @ignore
       */
      constructor : Saver,
      /**
       * @const
       * @private
       * @ignore
       */
      id : PotInternal.getMagicNumber(),
      /**
       * @const
       * @private
       */
      serial : null,
      /**
       * @private
       * @readonly
       * @const
       * @ignore
       */
      NAME : 'ReplaceSaver',
      /**
       * toString.
       *
       * @return  Return formatted string of object.
       * @type Function
       * @function
       * @static
       * @public
       */
      toString : PotToString,
      /**
       * @ignore
       * @private
       */
      saving : null,
      /**
       * @ignore
       * @private
       */
      strings : null,
      /**
       * @ignore
       * @private
       */
      patterns : null,
      /**
       * @ignore
       * @private
       */
      reserves : null,
      /**
       * Initialize.
       *
       * @ignore
       * @private
       */
      init : function(string, pattern, reserve) {
        if (!this.serial) {
          this.serial = buildSerial(this);
        }
        this.saving = [];
        this.strings = [];
        this.patterns = [];
        this.reserves = [];
        this.setString(string);
        this.setPattern(pattern);
        this.setReserve(reserve);
        return this;
      },
      /**
       * Set the string.
       *
       * @param  {String}            string  The target string.
       * @return {Pot.ReplaceSaver}          Return this.
       * @type  Function
       * @function
       * @public
       */
      setString : function(string) {
        if (Pot.isScalar(string)) {
          this.strings[this.strings.length] = stringify(string);
        }
      },
      /**
       * Set the reserve keyword(s).
       *
       * @param  {String|Array}     reserve  The reserve keyword(s).
       * @return {Pot.ReplaceSaver}          Return this.
       * @type  Function
       * @function
       * @public
       */
      setReserve : function(reserve) {
        var rvs = this.reserves;
        each(arrayize(reserve), function(resv) {
          if (Pot.isScalar(resv)) {
            rvs[rvs.length] = stringify(resv);
          }
        });
      },
      /**
       * Generate the unique string.
       *
       * @return {String} The unique string.
       * @type  Function
       * @function
       * @ignore
       * @private
       */
      generateUniqString : function() {
        var s = this.strings.join(''),
            re = new RegExp('[' +
              rescape(this.reserves.join('')) +
            ']', 'g'),
            uniq, n = 0;
        do {
          uniq = fromCharCode(
            n, n, Math.random() * 0xFFFF >>> 0, n, n
          );
          uniq += uniq + uniq + fromCharCode(n, n);
          if (~s.indexOf(uniq)) {
            uniq += (+new Date) + uniq;
          }
          uniq = uniq.replace(re, '');
          if (++n >= 0xFFFE) {
            n = 0;
          }
        } while (~s.indexOf(uniq));
        return uniq;
      },
      /**
       * Set the pattern(s).
       *
       * @param  {String|RegExp|Array} pattern The pattern(s).
       * @return {Pot.ReplaceSaver}            Return this.
       * @type  Function
       * @function
       * @public
       */
      setPattern : function(pattern) {
        var pt = this.patterns;
        each(arrayize(pattern), function(p) {
          var item = arrayize(p), search, index, v, i;
          try {
            v = item[0];
            i = item[1];
            if (Pot.isScalar(v)) {
              search = stringify(v);
            } else if (isRegExp(v)) {
              search = v;
            }
            if (search != null) {
              if (!i) {
                index = 0;
              } else if (isNumeric(i)) {
                index = Math.floor(i - 0) || 0;
              } else if (isFunction(i)) {
                index = i;
              } else {
                index = 0;
              }
              pt[pt.length] = [search, index];
            }
          } catch (e) {}
        });
      },
      /**
       * Save the string by specified pattern(s).
       *
       *
       * @example
       *   // This sample code is process to leaving only the 'pre' tags,
       *   //  and replace all other HTML tags are escaped.
       *   var myProcess = function(string) {
       *     return string.replace(/&/g, '&amp;').
       *                   replace(/</g, '&lt;').
       *                   replace(/>/g, '&gt;');
       *   };
       *   var string =
       *     '<pre>\n' +
       *       '<b>var</b> foo = 1;\n' +
       *     '</pre>\n' +
       *     '<div>hoge</div>\n' +
       *     '<div>fuga</div>\n' +
       *     '<p onclick="alert(1)">piyo</p>\n' +
       *     '<pre>\n' +
       *       '<b>foo</b>\n' +
       *       'bar\n' +
       *       '<i>baz</i>\n' +
       *     '</pre>';
       *   var pattern = /<pre\b[^>]*>([\s\S]*?)<\/pre>/gi;
       *   // The string or Array that must not appear in the saved string.
       *   var reserve = ['<', '>'];
       *   var rs = new Pot.Text.ReplaceSaver(string, pattern, reserve);
       *   // Save and replace string for your replace process.
       *   var result = rs.save();
       *   // Execute your replace process.
       *   result = myProcess(result);
       *   // Load and replace from saved string.
       *   result = rs.load(result);
       *   debug(result);
       *   // @results
       *   //   <pre>
       *   //     <b>var</b> foo = 1;
       *   //   </pre>
       *   //   &lt;div&gt;hoge&lt;/div&gt;
       *   //   &lt;div&gt;fuga&lt;/div&gt;
       *   //   &lt;p onclick="alert(1)"&gt;piyo&lt;/p&gt;
       *   //   <pre>
       *   //     <b>foo</b>
       *   //     bar
       *   //     <i>baz</i>
       *   //   </pre>
       *
       *
       * @return {String} Returns a string that is replaced by
       *                  specified pattern(s).
       * @type  Function
       * @function
       * @public
       */
      save : function() {
        var result = '', that = this, args = arguments,
            saving = this.saving, patterns = this.patterns,
            pattern, search, index, uniq, s, i, len;
        if (args.length) {
          this.init.apply(this, args);
        }
        s = stringify(this.strings.pop());
        if (s) {
          len = patterns.length;
          for (i = 0; i < len; i++) {
            pattern = patterns[i];
            search  = pattern[0];
            index   = pattern[1];
            if (search == null) {
              continue;
            }
            s = s.replace(search, function() {
              var matches = arrayize(arguments), idx;
              if (isFunction(index)) {
                idx = index(matches) || 0;
              } else {
                idx = (index - 0) || 0;
              }
              uniq = that.generateUniqString();
              saving[saving.length] = [matches[idx], uniq];
              return uniq;
            });
          }
          result = s;
        }
        return result;
      },
      /**
       * Load the original string from saved string.
       *
       * @see Pot.Text.ReplaceSaver.save
       *
       * @param  {String}   result  The saved string.
       * @return {String}           Returns the original string.
       * @type  Function
       * @function
       * @public
       */
      load : function(result) {
        var r = stringify(result), saving = this.saving,
            i, sv, match, uniq;
        for (i = saving.length - 1; i >= 0; --i) {
          sv = saving[i];
          try {
            match = sv[0];
            uniq = sv[1];
            if (match == null || uniq == null) {
              throw match;
            }
          } catch (e) {
            continue;
          }
          r = r.split(uniq).join(match);
        }
        saving.splice(0, saving.length);
        return r;
      }
    });
    Saver.fn.init.prototype = Saver.fn;
    return Saver;
  }()),
  /**
   * @lends Pot.Text
   */
  /**
   * Shortcut of String.fromCharCode().
   * This function fixed an error on 'stack overflow' (or RangeError).
   * e.g. String.fromCharCode.apply(null, new Array(100000000));
   *
   *
   * @example
   *   debug(chr(97));
   *   // @results 'a'
   *   debug(chr(97, 98, 99));
   *   // @results 'abc'
   *   debug(chr(
   *          [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]
   *   ));
   *   // @results 'Hello World!'
   *
   *
   * @param  {...Number|Array}  (...)  Unicode numbers, or an array.
   * @return {String}                  Converted string from Unicode number.
   * @type  Function
   * @function
   * @static
   * @public
   */
  chr : function(/*[...args]*/) {
    var args = arguments, codes, chars, divs, i, len, limit = 0x2000;
    if (args.length === 1) {
      if (isArray(args[0])) {
        codes = arrayize(args[0]);
      } else {
        return fromUnicode(args[0]);
      }
    } else if (args.length > 1) {
      codes = arrayize(args);
    } else {
      return '';
    }
    chars = [];
    if (codes) {
      len = codes.length;
      if (len === 1 && codes[0] && codes[0].length < limit) {
        return fromCharCode.apply(null, codes);
      } else {
        for (i = 0; i < len; i += limit) {
          divs = codes.slice(i, i + limit);
          chars[chars.length] = fromCharCode.apply(null, divs);
        }
      }
    }
    return chars.join('');
  },
  /**
   * A shortcut of charCodeAt(0).
   *
   *
   * @example
   *   debug(ord('Hello'));
   *   // @results 72
   *
   *
   * @param  {String}  s  Target string.
   * @return {Number}     The first index Unicode number in `s`.
   * @type  Function
   * @function
   * @static
   * @public
   */
  ord : function(s) {
    return stringify(s, true).charCodeAt(0);
  },
  /**
   * Trim the white spaces including em (U+3000).
   *
   * White spaces will not removed when specified the second argument.
   *
   * @example
   *   debug( trim(' hoge  ') );
   *   // @results 'hoge'
   *
   *
   * @example
   *   //
   *   // White spaces will not removed when 
   *   //  specified the second argument.
   *   //
   *   debug( trim('abbbcc cc ', 'ab') );
   *   // @results 'cc cc '
   *
   *
   * @param  {String}   s            A target string.
   * @param  {String}  (chars)       (Optional) Removing characters.
   * @param  {Boolean} (ignoreCase)  (Optional) Whether ignore case on RegExp.
   * @return {String}                A result string.
   * @type Function
   * @function
   * @public
   * @static
   */
  trim : trim,
  /**
   * Trim the white spaces including em (U+3000) from left side.
   *
   * White spaces will not removed when specified the second argument.
   *
   * @example
   *   debug( ltrim(' hoge  ') );
   *   // @results 'hoge  '
   *
   *
   * @example
   *   //
   *   // White spaces will not removed when 
   *   //  specified the second argument.
   *   //
   *   debug( ltrim('a cba', 'ac') );
   *   // @results ' cba'
   *
   *
   * @param  {String}   s            A target string.
   * @param  {String}  (chars)       (Optional) Removing characters.
   * @param  {Boolean} (ignoreCase)  (Optional) Whether ignore case on RegExp.
   * @return {String}                A result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  ltrim : function(s, chars, ignoreCase) {
    var re;
    if (chars) {
      re = new RegExp(
        ['^[', ']+'].join(rescape(chars)),
        'g' + (ignoreCase ? 'i' : '')
      );
    } else {
      re = RE_LTRIM;
    }
    return stringify(s, true).replace(re, '');
  },
  /**
   * Trim the white spaces including em (U+3000) from right side.
   *
   * White spaces will not removed when specified the second argument.
   *
   * @example
   *   debug( rtrim(' hoge  ') );
   *   // @results ' hoge'
   *
   *
   * @example
   *   //
   *   // White spaces will not removed when 
   *   //  specified the second argument.
   *   //
   *   debug( rtrim('abc a', 'ac') );
   *   // @results 'abc '
   *
   *
   * @param  {String}   s            A target string.
   * @param  {String}  (chars)       (Optional) Removing characters.
   * @param  {Boolean} (ignoreCase)  (Optional) Whether ignore case on RegExp.
   * @return {String}                A result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  rtrim : function(s, chars, ignoreCase) {
    var re;
    if (chars) {
      re = new RegExp(
        ['[', ']+$'].join(rescape(chars)),
        'g' + (ignoreCase ? 'i' : '')
      );
    } else {
      re = RE_RTRIM;
    }
    return stringify(s, true).replace(re, '');
  },
  /**
   * Remove all whitespaces in a string.
   *
   *
   * @example
   *   var s = '   Hello  World ! \r\n.';
   *   debug(strip(s));
   *   // @results 'HelloWorld!.'
   *
   *
   * @example
   *   var s = 'foo looooooooool';
   *   debug(strip(s, 'o'));
   *   // @results 'f ll'
   *
   *
   * @param  {String}  s             The target string.
   * @param  {String}  (chars)       (Optional) Removing characters.
   * @param  {Boolean} (ignoreCase)  (Optional) Whether ignore case on RegExp.
   * @return {String}                A result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  strip : function(s, chars, ignoreCase) {
    var re;
    if (chars) {
      re = new RegExp(
        '[' + rescape(chars) + ']+',
        'g' + (ignoreCase ? 'i' : '')
      );
    } else {
      re = RE_STRIP;
    }
    return stringify(s, true).replace(re, '');
  },
  /**
   * Indent a string.
   *
   *
   * @example
   *   var s = 'foo bar baz';
   *   debug(indent(s));          // '  foo bar baz'
   *   debug(indent(s, 4));       // '    foo bar baz'
   *   debug(indent(s, 1, '\t')); // '\tfoo bar baz'
   *
   *
   * @example
   *   var s = 'foo\nbar\nbaz';
   *   debug(indent(s, 1, '\t')); // '\tfoo\n\tbar\n\tbaz'
   *
   *
   * @param  {String}  string  A target string.
   * @param  {Number}  (size)  (Optional) A length of indent (default=2).
   * @param  {String}  (ch)    (Optional) A character to indent (default=' ').
   * @return {String}          A result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  indent : function(string, size, ch) {
    var s = stringify(string),
        c, sz, unsz, i, j, len, line, lines, nl, m, space;
    if (s) {
      if (isString(size)) {
        c = size;
        sz = ch;
      } else {
        c = ch;
        sz = size;
      }
      c = stringify(c) || ' ';
      sz = isNumeric(sz) ? ((sz - 0) || 2) : 2;
      if (sz < 0) {
        unsz = -sz;
        space = new Array(unsz + 1).join(c);
      }
      m = s.match(RE_NL_GROUP);
      nl = (m && m[1]) ? m[1] : '\n';
      lines = s.split(RE_NL);
      len = lines.length;
      for (i = 0; i < len; i++) {
        line = lines[i];
        if (unsz) {
          if (line.substr(0, unsz) === space) {
            line = line.substring(unsz);
          }
        } else {
          j = 0;
          while (j++ < sz) {
            line = c + line;
          }
        }
        lines[i] = line;
      }
      s = lines.join(nl);
    }
    return s;
  },
  /**
   * Unindent a string.
   *
   *
   * @example
   *   var s = '  foo bar baz';
   *   debug(unindent(s));          // 'foo bar baz'
   *   debug(unindent(s, 4));       // '  foo bar baz'
   *   debug(unindent(s, 1, '\t')); // '  foo bar baz'
   *
   *
   * @example
   *   var s = '\tfoo\n\tbar\n\tbaz';
   *   debug(unindent(s, 1, '\t')); // 'foo\nbar\nbaz'
   *
   *
   * @param  {String}  string  A target string.
   * @param  {Number}  (size)  (Optional) A length of indent (default=2).
   * @param  {String}  (ch)    (Optional) A character to indent (default=' ').
   * @return {String}          A result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  unindent : function(string, size, ch) {
    var sz, c;
    if (isString(size)) {
      c = size;
      sz = ch;
    } else {
      c = ch;
      sz = size;
    }
    if (sz > 0) {
      sz = -sz;
    }
    return Pot.Text.indent.call(null, string, sz || -2, c);
  },
  /**
   * Normalize whitespaces.
   * One or more whitespaces will be converted into one space.
   * If passed any character to the second argument then
   *   convertion will use it.
   *
   *
   * @example
   *   var s = 'Hello  \r\n  World  \r\n  \t !';
   *   debug(normalizeSpace(s));
   *   // @results 'Hello World !'
   *
   *
   * @example
   *   var s = 'foo       bar     baz';
   *   debug(normalizeSpace(s, '+'));
   *   // @results 'foo+bar+baz'
   *
   *
   * @param  {String}   s        The target string.
   * @param  {String}  (spacer)  (Optional) Convertion character.
   * @return {String}            A result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  normalizeSpace : (function() {
    var re = /[\s\u00A0\u3000]+/g;
    return function(s, spacer) {
      return stringify(s, true).replace(re, spacer || ' ');
    };
  }()),
  /**
   * Split a string into an array by whitespace.
   * All empty items will be removed for the result array.
   *
   *
   * @example
   *   var s = '  Hello  \r\n  World  \r\n  \t !  ';
   *   debug(splitBySpace(s));
   *   // @results ['Hello', 'World', '!']
   *
   *
   * @param  {String}   s   The target string.
   * @return {Array}        The result array.
   * @type  Function
   * @function
   * @static
   * @public
   */
  splitBySpace : (function() {
    var re = /[\s\u00A0\u3000]+/;
    return function(s) {
      var array = stringify(s, true).split(re),
          a, i, len = array.length, results = [];
      for (i = 0; i < len; i++) {
        a = array[i];
        if (a && a.length) {
          results[results.length] = a;
        }
      }
      return results;
    };
  }()),
  /**
   * Replaces new lines with unix style (\n).
   *
   *
   * @example
   *   var string = 'foo\r\nbar\rbaz\n';
   *   var result = canonicalizeNL(string);
   *   debug(result);
   *   // @results  'foo\nbar\nbaz\n'
   *
   *
   * @param  {String}    s    The input string.
   * @return {String}         The result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  canonicalizeNL : (function() {
    // Includes U+2028 (Line Separator) and U+2029 (Paragraph Separator).
    var re = /\r\n|\r|\n|[\u2028\u2029]/g, nl = '\u000A';
    return function(s) {
      return stringify(s, true).replace(re, nl);
    };
  }()),
  /**
   * Wraps a string by specific character.
   * Wrapper string can specify an array.
   * That must has 2 or more items.
   *
   *
   * @example
   *   var s = 'hoge';
   *   debug(wrap(s, '"'));
   *   // @results '"hoge"'
   *
   *
   * @example
   *   var s = 'hoge';
   *   debug(wrap(s, ['(', ')']));
   *   // @results '(hoge)'
   *
   *
   * @example
   *   var s = 'hoge';
   *   debug(wrap(s, '()') + wrap(s, '[]'));
   *   // @results '(hoge)[hoge]'
   *
   *
   * @param  {String}         string   The target string.
   * @param  {String|Array}   wrapper  The wrapper character.
   * @param  {String}         right    (optional) The right wrapper.
   * @return {String}                  The result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  wrap : update(function(string, wrapper, right) {
    var w, s = stringify(string),
        me = Pot.Text.wrap, maps = me.PairMaps;
    if (right != null) {
      wrapper = [wrapper, right];
    }
    if (wrapper && wrapper.shift && wrapper.pop) {
      s = stringify(wrapper.shift()) + s + stringify(wrapper.pop());
    } else {
      w = stringify(wrapper);
      if (w in maps) {
        s = maps[w][0] + s + maps[w][1];
      } else {
        s = w + s + w;
      }
    }
    return s;
  }, {
    /**@ignore*/
    PairMaps : {
      '()'           : ['(',      ')'],
      '<>'           : ['<',      '>'],
      '[]'           : ['[',      ']'],
      '{}'           : ['{',      '}'],
      '\u300c\u300d' : ['\u300c', '\u300d'], // 「」
      '\u201c\u201d' : ['\u201c', '\u201d'], // “”
      '\u300e\u300f' : ['\u300e', '\u300f'], // 『』
      '\u2018\u2019' : ['\u2018', '\u2019'], // ‘’
      '\u226a\u226b' : ['\u226a', '\u226b'], // ≪≫
      '\uff1c\uff1e' : ['\uff1c', '\uff1e'], // ＜＞
      '\u3014\u3015' : ['\u3014', '\u3015'], // 〔〕
      '\uff3b\uff3d' : ['\uff3b', '\uff3d'], // ［］
      '\uff5b\uff5d' : ['\uff5b', '\uff5d'], // ｛｝
      '\u3008\u3009' : ['\u3008', '\u3009'], // 〈〉
      '\uff08\uff09' : ['\uff08', '\uff09'], // （）
      '\u300a\u300b' : ['\u300a', '\u300b'], // 《》
      '\u3010\u3011' : ['\u3010', '\u3011']  // 【】
    }
  }),
  /**
   * @lends Pot.Text
   */
  /**
   * Unwraps a string by specific character.
   * Unwrapper string can specify an array.
   * That must has 2 or more items.
   *
   *
   * @example
   *   var s = '"hoge"';
   *   debug(unwrap(s, '"'));
   *   // @results 'hoge'
   *
   *
   * @example
   *   var s = '(hoge)';
   *   debug(unwrap(s, ['(', ')']));
   *   // @results 'hoge'
   *
   *
   * @example
   *   var s = '(L(hoge)R)';
   *   debug(unwrap(unwrap(s, '()'), ['L(', ')R']));
   *   // @results 'hoge'
   *
   *
   * @param  {String}        string     The target string.
   * @param  {String|Array}  unwrapper  The unwrapper character.
   * @param  {String}        rightWrap  (optional) The right unwrapper.
   * @return {String}                   The result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  unwrap : function(string, unwrapper, rightWrap) {
    var s = stringify(string), w, left, right,
        Text = Pot.Text, maps = Text.wrap.PairMaps;
    if (rightWrap != null) {
      unwrapper = [unwrapper, rightWrap];
    }
    if (unwrapper && unwrapper.shift && unwrapper.pop) {
      left  = stringify(unwrapper.shift());
      right = stringify(unwrapper.pop());
    } else {
      w = stringify(unwrapper);
      if (w in maps) {
        left  = maps[w][0];
        right = maps[w][1];
      } else {
        left = right = w;
      }
    }
    if (!left && !right && s) {
      left  = s.charAt(0);
      right = s.slice(-1);
      w = left + right;
      if (w in maps) {
        left  = maps[w][0];
        right = maps[w][1];
      } else {
        if (left !== right) {
          return s;
        }
      }
    }
    if (left && Text.startsWith(s, left)) {
      s = s.substring(left.length);
    }
    if (right && Text.endsWith(s, right)) {
      s = s.substring(0, s.length - right.length);
    }
    return s;
  },
  /**
   * Check whether a string starts with prefix.
   *
   *
   * @example
   *   var result = startsWith('foo bar baz', 'foo');
   *   debug(result);
   *   // @results true
   *
   *
   * @example
   *   var result = startsWith('bar foo foo bar baz foo', 'foo');
   *   debug(result);
   *   // @results false
   *
   *
   * @example
   *   var result = startsWith('FoO bar foo foo bar baz foo', 'foo', true);
   *   debug(result);
   *   // @results true
   *
   *
   * @param  {String}    string      The string to check.
   * @param  {String}    prefix      The subject prefix.
   * @param  {Boolean} (ignoreCase)  Whether ignore case.
   * @return {Boolean}               True if `string` begins
   *                                   with `prefix`.
   * @type  Function
   * @function
   * @static
   * @public
   */
  startsWith : function(string, prefix, ignoreCase) {
    var s = stringify(string, true),
        p = stringify(prefix, true);
    if (ignoreCase) {
      s = s.toLowerCase();
      p = p.toLowerCase();
    }
    return s.lastIndexOf(p, 0) === 0;
  },
  /**
   * Check whether a string ends with suffix.
   *
   *
   * @example
   *   var result = endsWith('foo bar baz', 'baz');
   *   debug(result);
   *   // @results true
   *
   *
   * @example
   *   var result = endsWith('foo bar baz foo bar', 'foo');
   *   debug(result);
   *   // @results false
   *
   *
   * @example
   *   var result = endsWith('bar foo foo bar baz FOo', 'foo', true);
   *   debug(result);
   *   // @results true
   *
   *
   * @param  {String}    string      The string to check.
   * @param  {String}    suffix      The subject suffix.
   * @param  {Boolean} (ignoreCase)  Whether ignore case.
   * @return {Boolean}               True if `string` ends
   *                                   with `suffix`.
   * @type  Function
   * @function
   * @static
   * @public
   */
  endsWith : function(string, suffix, ignoreCase) {
    var n,
        s = stringify(string, true),
        x = stringify(suffix, true);
    if (ignoreCase) {
      s = s.toLowerCase();
      x = x.toLowerCase();
    }
    n = s.length - x.length;
    return n >= 0 && s.indexOf(x, n) === n;
  },
  /**
   * A shortcut function of .toLowerCase().
   * Convert a string to lowercase.
   *
   *
   * @example
   *   debug(lower('Hello World!'));
   *   // @results 'hello world!'
   *
   *
   * @param  {String}  s  A target string.
   * @return {String}     A result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  lower : function(s) {
    return stringify(s, true).toLowerCase();
  },
  /**
   * A shortcut function of .toUpperCase().
   * Convert a string to uppercase.
   *
   *
   * @example
   *  debug(upper('Hello World!'));
   *  // @results 'HELLO WORLD!'
   *
   *
   * @param  {String}  s  A target string.
   * @return {String}     A result string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  upper : function(s) {
    return stringify(s, true).toUpperCase();
  },
  /**
   * Convert a string to "Camelcase".
   *
   *
   * @example
   *   var result = camelize('font-size');
   *   debug(result);
   *   // @results 'fontSize'
   *
   *
   * @param  {String}  s  A target string.
   * @return {String}     A converted string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  camelize : (function() {
    var
    re = /[_-]+(\w)/g,
    /**@ignore*/
    rep = function(a, w) {
      return w.toUpperCase();
    };
    return function(s) {
      return stringify(s).replace(re, rep);
    };
  }()),
  /**
   * Convert a string to "hyphen-delimited syntax".
   *
   *
   * @example
   *   var result = hyphenize('fontSize');
   *   debug(result);
   *   // @results 'font-size'
   *
   *
   * @param  {String}  s  A target string.
   * @return {String}     A converted string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  hyphenize : (function() {
    var re = /([A-Z]+)/g;
    return function(s) {
      return stringify(s).replace(re, '-$1').toLowerCase();
    };
  }()),
  /**
   * Convert a string to "Underscore-syntax".
   *
   *
   * @example
   *   var result = underscore('rawInput');
   *   debug(result);
   *   // @results 'raw_input'
   *
   *
   * @param  {String}  s  A target string.
   * @return {String}     A converted string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  underscore : (function() {
    var re = /([A-Z]+)/g;
    return function(s) {
      return stringify(s).replace(re, '_$1').toLowerCase();
    };
  }()),
  /**
   * Extract a substring from string .
   *
   *
   * @example
   *   var result = extract('foo:bar', /:(\w+)$/);
   *   debug(result);
   *   // @results 'bar'
   *
   *
   * @example
   *   var result = extract('foo:bar', /^:(\w+)/);
   *   debug(result);
   *   // @results ''
   *
   *
   * @example
   *   var result = extract('foo.html', /(foo|bar)\.([^.]+)$/, 2);
   *   debug(result);
   *   // @results 'html'
   *
   *
   * @example
   *   var result = extract('foobar', 'foo');
   *   debug(result);
   *   // @results 'foo'
   *
   *
   * @example
   *   var result = extract('foobar', 'fo+');
   *   debug(result);
   *   // @results ''
   *
   *
   * @param  {String|*}       string    A target string.
   * @param  {RegExp|String}  pattern   A pattern for extract substring.
   * @param  {Number}         (index)   (Optional) Index number of
   *                                      captured group.
   * @return {String}                   Return extracted substring.
   * @type  Function
   * @function
   * @static
   * @public
   */
  extract : function(string, pattern, index) {
    var r = '', s = stringify(string), re, idx, m;
    if (s && pattern) {
      if (isRegExp(pattern)) {
        re = pattern;
      } else {
        re = new RegExp(rescape(pattern));
      }
      idx = (index != null && isNumeric(index)) ? index : 1;
      m = s.match(re);
      if (m) {
        r = r + m[(m[idx] == null) ? 0 : idx];
      }
    }
    return r;
  },
  /**
   * Increment the argument value.
   * This incrementation like Perl and PHP etc that
   *   uses alphabets [a-z] + [A-Z] and digits [0-9]
   *   as magic-increment,
   *   (i.e., different with c-style increment.).
   *
   *
   * @example
   *   debug(inc('99'));
   *   // @results '100'
   *   debug(inc('a0'));
   *   // @results 'a1'
   *   debug(inc('Az'));
   *   // @results 'Ba'
   *   debug(inc('zz'));
   *   // @results 'aaa'
   *
   *
   * @example
   *   var s = 'X';
   *   for (var i = 0; i < 10; i++) {
   *     s = inc(s);
   *     debug(s);
   *   }
   *   // @results
   *   //   Y
   *   //   Z
   *   //   AA
   *   //   AB
   *   //   AC
   *   //   AD
   *   //   AE
   *   //   AF
   *   //   AG
   *   //   AH
   *
   *
   * @see Pot.Text.dec
   * @param  {String|Number|Date|*}  value  The value to increment.
   * @return {String|Number|Date|*}         The incremented value.
   * @type  Function
   * @function
   * @static
   * @public
   */
  inc : function(value) {
    var LOWER = 1, UPPER = 2, NUMERIC = 3,
        pos, s, c, last, carry, add;
    if (isNumber(value)) {
      return ++value;
    }
    if (!isString(value)) {
      return value;
    }
    last = 0;
    carry = false;
    /**@ignore*/
    add = function(val) {
      return fromUnicode(val.charCodeAt(0) + 1);
    };
    s = value.toString().split('');
    if (s.length === 0) {
      return '1';
    }
    pos = s.length - 1;
    while (pos >= 0) {
      c = s[pos].charCodeAt(0);
      if (c >= 0x61/*'a'*/ && c <= 0x7A/*'z'*/) {
        if (c === 0x7A) {
          s[pos] = 'a';
          carry = true;
        } else {
          s[pos] = add(s[pos]);
          carry = false;
        }
        last = LOWER;
      } else if (c >= 0x41/*'A'*/ && c <= 0x5A/*'Z'*/) {
        if (c === 0x5A) {
          s[pos] = 'A';
          carry = true;
        } else {
          s[pos] = add(s[pos]);
          carry = false;
        }
        last = UPPER;
      } else if (c >= 0x30/*'0'*/ && c <= 0x39/*'9'*/) {
        if (c === 0x39) {
          s[pos] = '0';
          carry = true;
        } else {
          s[pos] = add(s[pos]);
          carry = false;
        }
        last = NUMERIC;
      } else {
        carry = false;
        break;
      }
      if (!carry) {
        break;
      }
      pos--;
    }
    if (carry) {
      switch (last) {
        case NUMERIC : s.unshift('1'); break;
        case UPPER   : s.unshift('A'); break;
        case LOWER   : s.unshift('a'); break;
      }
    }
    return s.join('');
  },
  /**
   * Decrement the argument value.
   * This decrementation like Perl and PHP etc that
   *   uses alphabets [a-z] + [A-Z] and digits [0-9] as
   *   magic-decrement,
   *   (i.e., different with c-style decrement.).
   * Note Magic-Decrement cannot works with perfectly,
   *  so that Perl and Ruby etc did not implemented magic-decerement.
   *
   *
   * @example
   *   debug(dec('100'));
   *   // @results '99'
   *   debug(dec('a1'));
   *   // @results 'a0'
   *   debug(dec('Ba'));
   *   // @results 'Az'
   *   debug(dec('aaa'));
   *   // @results 'zz'
   *
   *
   * @example
   *   var s = 'AC';
   *   for (var i = 0; i < 10; i++) {
   *     s = dec(s);
   *     debug(s);
   *   }
   *   // @results
   *   //   AB
   *   //   AA
   *   //   Z
   *   //   Y
   *   //   X
   *   //   W
   *   //   V
   *   //   U
   *   //   T
   *   //   S
   *
   *
   * @see Pot.Text.inc
   * @param  {String|Number|Date|*}  value  The value to decrement.
   * @return {String|Number|Date|*}         The decremented value.
   * @type  Function
   * @function
   * @static
   * @public
   */
  dec : function(value) {
    var LOWER = 1, UPPER = 2, NUMERIC = 3,
        i, len, s, c, t, n1, n2, carry, last, borrow;
    if (isNumber(value)) {
      return --value;
    }
    if (!isString(value)) {
      return value;
    }
    s = value.toString().split('').reverse();
    len = s.length;
    if (len === 0) {
      return '';
    }
    carry = false;
    for (i = 0; i < len; i++) {
      c = s[i].charCodeAt(0);
      if (!carry &&
           // a - z
          ((c >= 0x61 && c <= 0x7A) ||
           // A - Z
           (c >= 0x41 && c <= 0x5A) ||
           // 0 - 9
           (c >= 0x30 && c <= 0x39))
      ) {
        carry = true;
      }
      if (c === 0x61) {
        s[i] = 'z';
        last = LOWER;
      } else if (c === 0x41) {
        s[i] = 'Z';
        last = UPPER;
      } else if (c === 0x30) {
        s[i] = '9';
        last = NUMERIC;
      } else {
        break;
      }
    }
    if (!carry) {
      return value;
    }
    t = s[0];
    borrow = false;
    switch (last) {
      case LOWER:
          if (c === 0x61 &&
              (len <= 1 ||
               (len > 1 && s[len - 1] === s[len - 2]) ||
               (len === 2 && t === '0')
              )
          ) {
            borrow = true;
          }
          break;
      case UPPER:
          if (c === 0x41 &&
              (len <= 1 ||
               (len > 1 && s[len - 1] === s[len - 2]) ||
               (len === 2 && t === '0')
              )
          ) {
            borrow = true;
          }
          break;
      case NUMERIC:
          n1 = s[len - 1];
          n2 = s[len - 2];
          if ((c === 0x31 && n1 === '1' && n2 === '9') ||
              (c === 0x30 &&
               (len <= 1 ||
                (len > 1 && s[len - 1] === s[len - 2]) ||
                (len === 2 && t === '0')
               )
              )
          ) {
            borrow = true;
          }
    }
    if (i >= len) {
      i--;
    }
    s[i] = fromUnicode(s[i].charCodeAt(0) - 1);
    s = s.reverse();
    if (borrow) {
      s.shift();
    }
    return s.join('');
  },
  /**
   * Converts the new lines (\n) to <br>s or <br />s.
   *
   *
   * @example
   *   var string = '1. foo.\n2. bar.\n3. baz.';
   *   var result = br(string);
   *   debug(result);
   *   // @results '1. foo.<br>\n2. bar.<br>\n3. baz.'
   *
   *
   * @example
   *   var string = ' - foo.\n - bar.\n - baz.';
   *   var result = br(string, true);
   *   debug(result);
   *   // @results ' - foo.<br />\n - bar.<br />\n - baz.'
   *
   *
   * @example
   *   var string = '<ul><li>foo<br />fooo</li><li>bar\nbaaar</li></ul>';
   *   var result = br(string);
   *   debug(result);
   *   // @results '<ul><li>foo<br />fooo</li><li>bar<br />\nbaaar</li></ul>'
   *
   *
   * @example
   *   var string = [
   *     '<div>',
   *     '<h1>Hoge</h1>',
   *     '<p>',
   *     'foo',
   *     'bar',
   *     '</p>',
   *     '<span>baz</span>',
   *     '<b>qux</b>',
   *     '<pre>',
   *     'function hoge() {',
   *     '  return this;',
   *     '}',
   *     '</pre>',
   *     '<hr>',
   *     '</div>'
   *   ].join('\n');
   *   var result = br(string);
   *   debug(result);
   *   // @results
   *   //   <div>
   *   //   <h1>Hoge</h1>
   *   //   <p>
   *   //   foo<br>
   *   //   bar<br>
   *   //   </p>
   *   //   <span>baz</span><br>
   *   //   <b>qux</b><br>
   *   //   <pre>
   *   //   function hoge() {
   *   //     return this;
   *   //   }
   *   //   </pre>
   *   //   <hr>
   *   //   </div>
   *
   *
   * @example
   *   var string = [
   *     '<div>',
   *     '<div>foo</div>',
   *     '<div>bar</div>',
   *     '<div>baz</div>',
   *     '</div>'
   *   ].join('\n');
   *   var result = br(string, false, true);
   *   debug(result);
   *   // @results
   *   //   <div><br>
   *   //   <div>foo</div><br>
   *   //   <div>bar</div><br>
   *   //   <div>baz</div><br>
   *   //   </div>
   *
   *
   * @param  {String}    string   The string in which to convert newlines.
   * @param  {Boolean}  (useXML)  Whether to use XML compatible tags.
   * @param  {Boolean}   (all)    Whether convert all of the new lines.
   * @return {String}             A copy string of `string`
   *                                with converted newlines.
   * @type  Function
   * @function
   * @static
   * @public
   */
  br : update(function(string, useXML, all) {
    var result = '', me = Pot.Text.br, s, xml, tag;
    s = stringify(string);
    if (s) {
      xml = useXML;
      if (xml == null && me.patterns.xml.test(s)) {
        xml = true;
      }
      tag = xml ? '<br />' : '<br>';
      if (all) {
        result = s.replace(me.patterns.nlg, tag + '$1');
      } else {
        result = me.insertAdjust(s, tag);
      }
    }
    return result;
  }, {
    /**
     * @private
     * @ignore
     */
    patterns : {
      inline : new RegExp(['^(?:<|)(', ')(?:[^>]*>|)$'].join(
          '(?:a|b|i|q|s|u|abbr|acronym|applet|big|cite' +
            '|code|dfn|em|font|iframe|kbd|label|object' +
            '|samp|small|span|strike|strong|sub|sup|tt' +
            '|var|bdo|button|del|ruby|img|input|select' +
            '|embed|ins|keygen|textarea|map|canvas|svg' +
            '|audio|command|mark|math|meter|time|video' +
            '|datalist|progress|output|\\w+:\\w+' +
          ')\\b'
        ),
        'i'
      ),
      xml  : /<\s*\w+[^>]*\/>/,
      nl   : /\r\n|\r|\n/,
      nlg  : /(\r\n|\r|\n)/g,
      rt   : /[\s\u00A0\u3000]+$/,
      top  : /^[\s\u00A0\u3000]*<\s*(\/|)\s*(\w+(?::\w+|))\b[^>]*(\/|)>/,
      end  : /<\s*(\/|)\s*(\w+(?::\w+|))\b[^>]*(\/|)>[\s\u00A0\u3000]*$/,
      code : new RegExp(
        '(<(pre|style|script)\\b[^>]*>[\\s\\S]*?</\\2\\s*>' +
        '|<!--[\\s\\S]*?-->' +
        '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>' +
        ')',
        'gi'
      )
    },
    /**
     * @private
     * @ignore
     */
    insertAdjust : function(string, brTag) {
      var results = [], Text = Pot.Text, me = Text.br,
          value = stringify(string),
          lines, codes = [], mark = '', reset;
      if (value) {
        do {
          mark += 'Pot' + now();
        } while (~value.indexOf(mark));
        value = value.replace(me.patterns.code, function(a, code) {
          codes[codes.length] = code;
          return '<' + mark + codes.length + mark + '>';
        });
        lines = value.split(me.patterns.nl);
        each(lines, function(line, i) {
          var append = false, matches, closing, name, closed, nextName,
              next = stringify(lines[i + 1]),
              cur = line.replace(me.patterns.rt, '');
          if (~cur.indexOf(mark) || i >= lines.length - 1) {
            append = false;
          } else {
            if (!me.patterns.end.test(cur)) {
              append = true;
            } else {
              matches = cur.match(me.patterns.end);
              closing = matches[1];
              name    = matches[2];
              closed  = matches[3];
              if (me.patterns.inline.test(name)) {
                append = true;
              } else {
                if (closing || closed) {
                  if (next && me.patterns.top.test(next)) {
                    nextName = next.match(me.patterns.top)[2];
                    if (me.patterns.inline.test(cur) &&
                        me.patterns.inline.test(nextName)) {
                      append = true;
                    }
                  } else {
                    append = true;
                  }
                }
              }
            }
          }
          results[results.length] = line + (append ? brTag : '');
        });
        value = results.join('\n');
        if (codes && codes.length) {
          reset = new RegExp(
            ['<(', ')([0-9]+)\\1>'].join(rescape(mark)),
            'g'
          );
          value = value.replace(reset, function(a, mk, idx) {
            return codes[idx - 1];
          });
        }
      }
      return value;
    }
  }),
  /**
   * @lends Pot.Text
   */
  /**
   * Remove the HTML/XML tags from string.
   *
   *
   * @example
   *   var html = '<div>Hoge</div>foo<br>bar<i>baz</i>';
   *   var result = stripTags(html);
   *   debug(result);
   *   // @results 'Hoge foo bar baz'
   *
   *
   * @param  {String}  text  The target string.
   * @return {String}        A result string that
   *                           removed all of tags.
   * @type  Function
   * @function
   * @static
   * @public
   */
  stripTags : update(function(text) {
    var result = '', me = Pot.Text.stripTags, s, prev, i, limit = 5;
    s = stringify(text, true);
    if (s) {
      for (i = 0; i < limit; i++) {
        each(me.patterns, function(re) {
          s = s.replace(re.by, re.to);
        });
        if (prev === s) {
          break;
        }
        prev = s;
      }
      result = s;
    }
    return result;
  }, {
    /**@ignore*/
    patterns : [{
      by : /<([%?])[\s\S]*?\1>/g,
      to : ''
    }, {
      by : /<!--[\s\S]*?-->/g,
      to : ''
    }, {
      by : /<!-*\[CDATA\[[\s\S]*?\]\]-*>/gi,
      to : ''
    }, {
      by : /<!\s*\w+[^>]*>/g,
      to : ''
    }, {
      by : /<\s*(\w+)\b[^>]*>([\s\S]*?)<\s*\/\s*\1\s*>/g,
      to : ' $2 '
    }, {
      by : /<\s*\/?\s*\w+\b[^>]*>/g,
      to : ' '
    }, {
      by : /<[^>]*>|<[![\]-]*|[-[\]]*>/g,
      to : ' '
    }]
  }),
  /**
   * @lends Pot.Text
   */
  /**
   * Truncates a string to a certain length and
   *   adds ellipsis (e.g., '...') if necessary.
   *
   *
   * @example
   *   var string = 'Helloooooooooo Wooooooooorld!! Hellooooo Woooooorld!!';
   *   debug(string + ' (length = ' + string.length + ')');
   *   var result = truncate(string, 10);
   *   debug(result + ' (length = ' + result.length + ')');
   *   // @results  result = 'Hellooo...' (length = 10)
   *
   *
   * @example
   *   var string = 'foooooooo baaaaaaaaar baaaaaaaaaaz';
   *   debug(string + ' (length = ' + string.length + ')');
   *   var result = truncate(string, 16, '...more');
   *   debug(result + ' (length = ' + result.length + ')');
   *   // @results  result = 'foooooooo...more' (length = 16)
   *
   *
   * @param  {String}   string     A target string.
   * @param  {Number}  (maxLen)    The maximum number of
   *                                 characters to truncates.
   * @param  {String}  (ellipsis)  Optional ellipsis string.
   * @return {String}              The truncated string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  truncate : function(string, maxLen, ellipsis) {
    var result = '', s, max, ch, cl;
    s = stringify(string, true);
    max = isNumeric(maxLen) ? maxLen - 0 : 140;
    if (arguments.length < 3) {
      ch = '...';
    } else {
      ch = stringify(ellipsis, true);
    }
    if (s) {
      if (max <= 0) {
        s = '';
      } else {
        if (s.length > max) {
          if (ch.length >= max) {
            cl = Math.floor(max * 0.726) || 0;
            ch = ch.substring(0, cl);
          }
          s = s.substring(0, max - ch.length) + ch;
        }
      }
      result = s;
    }
    return result;
  },
  /**
   * Truncate a string in the middle,
   *   adds ellipsis(e.g., '...') if necessary.
   *
   *
   * @example
   *   var string = 'Helloooooooooo Wooooooooorld!! Hellooooo Woooooorld!!';
   *   debug(string + ' (length = ' + string.length + ')');
   *   var result = truncateMiddle(string, 15);
   *   debug(result + ' (length = ' + result.length + ')');
   *   // @results  result = 'Helloo...orld!!' (length = 15)
   *
   *
   * @example
   *   var string = 'foooooooo baaaaaaaaar baaaaaaaaaaz';
   *   debug(string + ' (length = ' + string.length + ')');
   *   var result = truncateMiddle(string, 18, '(...)');
   *   debug(result + ' (length = ' + result.length + ')');
   *   // @results  result = 'foooooo(...)aaaaaz' (length = 18)
   *
   *
   * @param  {String}   string     A target string.
   * @param  {Number}  (maxLen)    The maximum number of
   *                                 characters to truncates.
   * @param  {String}  (ellipsis)  Optional ellipsis string.
   * @return {String}              The truncated string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  truncateMiddle : function(string, maxLen, ellipsis) {
    var result, s, max, ch, half, pos;
    s = stringify(string, true);
    max = isNumeric(maxLen) ? maxLen - 0 : 140;
    if (arguments.length < 3) {
      ch = '...';
    } else {
      ch = stringify(ellipsis, true);
    }
    if (s) {
      if (max <= 0) {
        s = '';
      } else {
        if (s.length > max) {
          if (ch.length >= max) {
            cl = Math.floor(max * 0.726) || 0;
            ch = ch.substring(0, cl);
          }
          half = Math.floor((max - ch.length) / 2);
          pos = s.length - half;
          half += (max - ch.length) % 2;
          s = s.substring(0, half) + ch + s.substring(pos);
        }
      }
      result = s;
    }
    return result;
  },
  /**
   * Convert to character code array from a string.
   *
   *
   * @example
   *   var string = 'foo bar ほげ';
   *   var result = Pot.toCharCode(string);
   *   Pot.debug(result);
   *   // [102, 111, 111, 32, 98, 97, 114, 32, 12411, 12370]
   *
   *
   * @example
   *   var string = 'abc';
   *   var result = Pot.toCharCode(string, function(code) {
   *     return code.toString(16);
   *   });
   *   Pot.debug(result);
   *   // ['61', '62', '63']
   *
   *
   * @param  {String}    string     A target string.
   * @param  {Function} (callback)  (Optional) A callback function for code.
   * @return {Array} A result array.
   * @type  Function
   * @function
   * @static
   * @public
   */
  toCharCode : function(string, callback) {
    return Pot.map(stringify(string).split(''), function(c) {
      var code = c.charCodeAt(0);
      if (callback) {
        code = callback(code);
      }
      return code;
    });
  },
  /**
   * 全角英数記号文字を半角英数記号文字に変換
   * Convert the ascii symbols and alphanumeric characters to
   *   the zenkaku symbols and alphanumeric characters.
   *
   * Based:
   *   Hiragana/Katakana Library
   *   http://code.google.com/p/kanaxs/
   *
   *
   * @example
   *   debug(toHankakuCase('Ｈｅｌｌｏ Ｗｏｒｌｄ！ １２３４５'));
   *   // @results   'Hello World! 12345'
   *
   *
   * @param  {String}  text  The input string.
   * @return {String}        The conveted string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  toHankakuCase : function(text) {
    var r = [], c, s, i, len;
    s = stringify(text, true);
    if (s) {
      i = 0;
      len = s.length;
      while (i < len) {
        c = s.charCodeAt(i++);
        if (0xFF01 <= c && c <= 0xFF5E) {
          c -= 0xFEE0;
        }
        r[r.length] = c;
      }
    }
    return Pot.Text.chr(r);
  },
  /**
   * 半角英数記号文字を全角英数記号文字に変換
   * Convert the zenkaku symbols and alphanumeric characters to
   *   the ascii symbols and alphanumeric characters.
   *
   *
   * @example
   *   debug(toZenkakuCase('Hello World! 12345'));
   *   // @results  'Ｈｅｌｌｏ Ｗｏｒｌｄ！ １２３４５'
   *
   *
   * @param  {String}  text  The input string.
   * @return {String}        The converted string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  toZenkakuCase : function(text) {
    var r = [], c, s, i, len;
    s = stringify(text, true);
    if (s) {
      i = 0;
      len = s.length;
      while (i < len) {
        c = s.charCodeAt(i++);
        if (0x21 <= c && c <= 0x7E) {
          c += 0xFEE0;
        }
        r[r.length] = c;
      }
    }
    return Pot.Text.chr(r);
  },
  /**
   * 全角スペースを半角スペースに変換
   * Convert the em space(U+3000) to the single space(U+0020).
   *
   * @param  {String}  text  The input string.
   * @return {String}        The converted string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  toHanSpaceCase : (function() {
    var re = /[\u3000]/g, rep = ' ';
    return function(text) {
      return stringify(text, true).replace(re, rep);
    };
  }()),
  /**
   * 半角スペースを全角スペースに変換
   * Convert the single space(U+0020) to the em space(U+3000).
   *
   * @param  {String}  text  The input string.
   * @return {String}        The converted string.
   * @type  Function
   * @function
   * @static
   * @public
   */
  toZenSpaceCase : (function() {
    var re = /[\u0020]/g, rep = '\u3000';
    return function(text) {
      return stringify(text, true).replace(re, rep);
    };
  }()),
  /**
   * 全角カタカナを全角ひらがなに変換
   * Convert the zenkaku katakana to the zenkaku hiragana.
   *
   *
   * @example
   *   debug(toHiraganaCase('ボポヴァアィイゥウェエォオ'));
   *   // @results  'ぼぽう゛ぁあぃいぅうぇえぉお'
   *
   *
   * @param  {String}  text  The input string.
   * @return {String}        The converted string to hiragana.
   * @type  Function
   * @function
   * @static
   * @public
   */
  toHiraganaCase : function(text) {
    var r = [], c, i, s, len, code;
    s = stringify(text, true);
    if (s) {
      i = 0;
      len = s.length;
      while (i < len) {
        c = s.charCodeAt(i++);
        if (0x30A1 <= c && c <= 0x30F6) {
          code = c - 0x0060;
          // 「ヴ」を「う」+「゛」に変換
          if (c === 0x30F4) {
            r[r.length] = 0x3046;
            code = 0x309B;
          }
          c = code;
        }
        r[r.length] = c;
      }
    }
    return Pot.Text.chr(r);
  },
  /**
   * 全角ひらがなを全角カタカナに変換
   * Convert the zenkaku hiragana to the zenkaku katakana.
   *
   *
   * @example
   *   debug(toKatakanaCase('ぼぽう゛ぁあぃいぅうぇえぉお'));
   *   // @results  'ボポヴァアィイゥウェエォオ'
   *
   *
   * @param  {String}  text  The input string.
   * @return {String}        The converted string to katakana.
   * @type  Function
   * @function
   * @static
   * @public
   */
  toKatakanaCase : function(text) {
    var r = [], c, d, i, code, len, s;
    s = stringify(text, true);
    if (s) {
      i = 0;
      len = s.length;
      while (i < len) {
        c = s.charCodeAt(i++);
        if (0x3041 <= c && c <= 0x3096) {
          code = c + 0x0060;
          if (i < len && c === 0x3046) {
            d = s.charCodeAt(i);
            if (d === 0x309B || d === 0xFF9E) {
              // 「う」+「゛」を「ヴ」に変換
              code = 0x30F4;
              i++;
            }
          }
          c = code;
        }
        r[r.length] = c;
      }
    }
    return Pot.Text.chr(r);
  },
  /**
   * 全角カタカナを半角ｶﾀｶﾅに変換
   * Convert the zenkaku katakana to the hankaku katakana.
   *
   *
   * @example
   *   debug(toHankanaCase('ボポヴァアィイゥウェエォオ'));
   *   // @results  'ﾎﾞﾎﾟｳﾞｧｱｨｲｩｳｪｴｫｵ'
   *
   *
   * @param  {String}  text  The input string.
   * @return {String}        The converted string to hankaku katakana.
   * @type  Function
   * @function
   * @static
   * @public
   */
  toHankanaCase : (function() {
    var map = {
      0x30A1:0xFF67,0x30A3:0xFF68,0x30A5:0xFF69,0x30A7:0xFF6A,0x30A9:0xFF6B,
      0x30FC:0xFF70,0x30A2:0xFF71,0x30A4:0xFF72,0x30A6:0xFF73,0x30A8:0xFF74,
      0x30AA:0xFF75,0x30AB:0xFF76,0x30AD:0xFF77,0x30AF:0xFF78,0x30B1:0xFF79,
      0x30B3:0xFF7A,0x30B5:0xFF7B,0x30B7:0xFF7C,0x30B9:0xFF7D,0x30BB:0xFF7E,
      0x30BD:0xFF7F,0x30BF:0xFF80,0x30C1:0xFF81,0x30C4:0xFF82,0x30C6:0xFF83,
      0x30C8:0xFF84,0x30CA:0xFF85,0x30CB:0xFF86,0x30CC:0xFF87,0x30CD:0xFF88,
      0x30CE:0xFF89,0x30CF:0xFF8A,0x30D2:0xFF8B,0x30D5:0xFF8C,0x30D8:0xFF8D,
      0x30DB:0xFF8E,0x30DE:0xFF8F,0x30DF:0xFF90,0x30E0:0xFF91,0x30E1:0xFF92,
      0x30E2:0xFF93,0x30E3:0xFF6C,0x30E4:0xFF94,0x30E5:0xFF6D,0x30E6:0xFF95,
      0x30E7:0xFF6E,0x30E8:0xFF96,0x30E9:0xFF97,0x30EA:0xFF98,0x30EB:0xFF99,
      0x30EC:0xFF9A,0x30ED:0xFF9B,0x30EF:0xFF9C,0x30F2:0xFF66,0x30F3:0xFF9D,
      0x30C3:0xFF6F,0x300C:0xFF62,0x300D:0xFF63,0x3002:0xFF61,0x3001:0xFF64,
      0x30FB:0xFF65,0x309B:0xFF9E,0x309C:0xFF9F
    },
    exc = {
      0x30F4:0xFF73,0x30F7:0xFF9C,0x30FA:0xFF66
    };
    return function(text) {
      var r = [], i, s, len, c;
      s = stringify(text, true);
      if (s) {
        i = 0;
        len = s.length;
        while (i < len) {
          c = s.charCodeAt(i++);
          if (c in map) {
            r[r.length] = map[c];
          } else if (c in exc) {
            r.push(exc[c], 0xFF9E);
          } else if (0x30AB <= c && c <= 0x30C9) {
            r.push(map[c - 1], 0xFF9E);
          } else if (0x30CF <= c && c <= 0x30DD) {
            r.push(map[c - c % 3], [0xFF9E, 0xFF9F][c % 3 - 1]);
          } else {
            r[r.length] = c;
          }
        }
      }
      return Pot.Text.chr(r);
    };
  }()),
  /**
   * @lends Pot.Text
   */
  /**
   * 半角ｶﾀｶﾅを全角カタカナに変換 (濁音含む)
   * Convert the hankaku katakana to
   *   the zenkaku katakana (including dullness).
   *
   *
   * @example
   *   debug(toZenkanaCase('ﾎﾞﾎﾟｳﾞｧｱｨｲｩｳｪｴｫｵ'));
   *   // @results  'ボポヴァアィイゥウェエォオ'
   *
   *
   * @param  {String}  text  The input string.
   * @return {String}        The converted string to zenkaku katakana.
   * @type  Function
   * @function
   * @static
   * @public
   */
  toZenkanaCase : (function() {
    var maps = [
      // Unicode U+FF61 - U+FF9F Mapping
      0x3002, 0x300C, 0x300D, 0x3001, 0x30FB, 0x30F2, 0x30A1, 0x30A3,
      0x30A5, 0x30A7, 0x30A9, 0x30E3, 0x30E5, 0x30E7, 0x30C3, 0x30FC,
      0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA, 0x30AB, 0x30AD, 0x30AF,
      0x30B1, 0x30B3, 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD, 0x30BF,
      0x30C1, 0x30C4, 0x30C6, 0x30C8, 0x30CA, 0x30CB, 0x30CC, 0x30CD,
      0x30CE, 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x30DE, 0x30DF,
      0x30E0, 0x30E1, 0x30E2, 0x30E4, 0x30E6, 0x30E8, 0x30E9, 0x30EA,
      0x30EB, 0x30EC, 0x30ED, 0x30EF, 0x30F3, 0x309B, 0x309C
    ];
    return function(text) {
      var code, codes = [], i, len, s, c, next, last;
      s = stringify(text, true);
      if (s) {
        len = s.length;
        last = len - 1;
        for (i = 0; i < len; i++) {
          c = s.charCodeAt(i);
          // 半角カタカナの範囲
          if (c > 0xFF60 && c < 0xFFA0) {
            code = maps[c - 0xFF61];
            if (i < last) {
              next = s.charCodeAt(++i);
              // 濁音「ﾞ」 + 「ヴ」
              if (next === 0xFF9E && c === 0xFF73) {
                code = 0x30F4;
              // 濁音「ﾞ」 + 「カ」～「コ」 or 「ハ」～「ホ」
              } else if (next === 0xFF9E &&
                            ((c > 0xFF75 && c < 0xFF85) ||
                             (c > 0xFF89 && c < 0xFF8F))) {
                code++;
              // 濁音「ﾟ」 + 「ハ」～「ホ」
              } else if (next === 0xFF9F &&
                             (c > 0xFF89 && c < 0xFF8F)) {
                code += 2;
              } else {
                i--;
              }
            }
            c = code;
          }
          codes[codes.length] = c;
        }
      }
      return Pot.Text.chr(codes);
    };
  }())
});

// Update Pot object.
Pot.update({
  stringify      : Pot.Text.stringify,
  ReplaceSaver   : Pot.Text.ReplaceSaver,
  chr            : Pot.Text.chr,
  ord            : Pot.Text.ord,
  trim           : Pot.Text.trim,
  ltrim          : Pot.Text.ltrim,
  rtrim          : Pot.Text.rtrim,
  strip          : Pot.Text.strip,
  indent         : Pot.Text.indent,
  unindent       : Pot.Text.unindent,
  normalizeSpace : Pot.Text.normalizeSpace,
  splitBySpace   : Pot.Text.splitBySpace,
  canonicalizeNL : Pot.Text.canonicalizeNL,
  wrap           : Pot.Text.wrap,
  unwrap         : Pot.Text.unwrap,
  startsWith     : Pot.Text.startsWith,
  endsWith       : Pot.Text.endsWith,
  lower          : Pot.Text.lower,
  upper          : Pot.Text.upper,
  camelize       : Pot.Text.camelize,
  hyphenize      : Pot.Text.hyphenize,
  underscore     : Pot.Text.underscore,
  extract        : Pot.Text.extract,
  inc            : Pot.Text.inc,
  dec            : Pot.Text.dec,
  br             : Pot.Text.br,
  stripTags      : Pot.Text.stripTags,
  truncate       : Pot.Text.truncate,
  truncateMiddle : Pot.Text.truncateMiddle,
  toCharCode     : Pot.Text.toCharCode,
  toHankakuCase  : Pot.Text.toHankakuCase,
  toZenkakuCase  : Pot.Text.toZenkakuCase,
  toHanSpaceCase : Pot.Text.toHanSpaceCase,
  toZenSpaceCase : Pot.Text.toZenSpaceCase,
  toHiraganaCase : Pot.Text.toHiraganaCase,
  toKatakanaCase : Pot.Text.toKatakanaCase,
  toHankanaCase  : Pot.Text.toHankanaCase,
  toZenkanaCase  : Pot.Text.toZenkanaCase
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of DOM.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * DOM utilities.
   *
   * @name Pot.DOM
   * @type Function
   * @function
   * @class
   * @static
   * @public
   */
  DOM : function() {
    return Pot.currentDocument();
  }
});

// Update DOM methods.
(function(DOM) {

update(DOM, {
  /**
   * @lends Pot.DOM
   */
  /**
   * The name of Pot.DOM.
   *
   * @type String
   * @static
   * @private
   * @const
   * @ignore
   */
  NAME : 'DOM',
  /**
   * toString.
   *
   * @return {String}     The string representation of object.
   * @type Function
   * @function
   * @static
   * @public
   */
  toString : PotToString,
  /**
   * Enumeration for DOM node types (for reference)
   *
   * @link http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1950641247
   * @enum {Number}
   * @static
   * @const
   * @public
   */
  NodeType : {
    ELEMENT_NODE                : 1,
    ATTRIBUTE_NODE              : 2,
    TEXT_NODE                   : 3,
    CDATA_SECTION_NODE          : 4,
    ENTITY_REFERENCE_NODE       : 5,
    ENTITY_NODE                 : 6,
    PROCESSING_INSTRUCTION_NODE : 7,
    COMMENT_NODE                : 8,
    DOCUMENT_NODE               : 9,
    DOCUMENT_TYPE_NODE          : 10,
    DOCUMENT_FRAGMENT_NODE      : 11,
    NOTATION_NODE               : 12
  },
  /**
   * Enumeration for DOM XPath result types (for reference)
   *
   * @link http://www.w3.org/TR/DOM-Level-3-XPath/ecma-script-binding.html
   * @enum {Number}
   * @static
   * @const
   * @public
   */
  XPathResult : {
    ANY_TYPE                     : 0,
    NUMBER_TYPE                  : 1,
    STRING_TYPE                  : 2,
    BOOLEAN_TYPE                 : 3,
    UNORDERED_NODE_ITERATOR_TYPE : 4,
    ORDERED_NODE_ITERATOR_TYPE   : 5,
    UNORDERED_NODE_SNAPSHOT_TYPE : 6,
    ORDERED_NODE_SNAPSHOT_TYPE   : 7,
    ANY_UNORDERED_NODE_TYPE      : 8,
    FIRST_ORDERED_NODE_TYPE      : 9
  },
  /**
   * Mapping the attribute names for access to property.
   *
   * @type Object
   * @static
   * @const
   */
  AttrMaps : (function() {
    var maps = {};
    maps.dir = {
      'for'         : 'htmlFor',
      'class'       : 'className',
      'readonly'    : 'readOnly',
      'maxlength'   : 'maxLength',
      'cellpadding' : 'cellPadding',
      'cellspacing' : 'cellSpacing',
      'rowspan'     : 'rowSpan',
      'colspan'     : 'colSpan',
      'tabindex'    : 'tabIndex',
      'usemap'      : 'useMap',
      'frameborder' : 'frameBorder',
      'valign'      : 'vAlign',
      'checked'     : 'defaultChecked',
      'bgcolor'     : 'bgColor'
    };
    maps.raw = {};
    each(maps.dir, function(v, p) {
      maps.raw[v] = p;
    });
    return maps;
  }()),
  /**
   * @lends Pot.DOM
   */
  /**
   * Detect Window object.
   *
   * @param  {Document|Element|Node|*}   x  The target object.
   * @return {Window|undefined}             Result of detected object.
   * @type   Function
   * @function
   * @static
   * @public
   */
  detectWindow : (function() {
    /**@ignore*/
    function detect(o) {
      try {
        return (isWindow(o.window) && o.window) ||
               (isWindow(o.contentWindow) && o.contentWindow) ||
               (isWindow(o.defaultView) && o.defaultView) ||
               (isWindow(o.parentWindow) && o.parentWindow) ||
               (isWindow(o.content) && o.content) ||
               (isWindow(o.top) && o.top);
      } catch (e) {}
    }
    return function(x) {
      var win, doc;
      if (x) {
        if (isWindow(x)) {
          win = x;
        } else {
          try {
            win = detect(x);
            if (!isWindow(win)) {
              doc = DOM.detectDocument(x);
              if (doc) {
                win = detect(doc);
              }
            }
          } catch (e) {}
        }
      }
      return win;
    };
  }()),
  /**
   * @lends Pot.DOM
   */
  /**
   * Detect Document object.
   *
   * @param  {Window|Element|Node|*}   x  The target object.
   * @return {Document|undefined}         Result of detected object.
   * @type   Function
   * @function
   * @static
   * @public
   */
  detectDocument : function(x) {
    var doc;
    if (x) {
      if (isDocument(x)) {
        doc = x;
      } else {
        try {
          doc = (x.ownerDocument || x.document ||
                (x.content && x.content.document));
        } catch (e) {}
      }
    }
    return doc;
  },
  /**
   * Returns the owner document for a node.
   *
   * @param  {Node|Window|Element}  node  The node to get the document for.
   * @return {Document}                   The document owning the node.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getOwnerDocument : function(node) {
    return node != null &&
      ((node.nodeType == DOM.NodeType.DOCUMENT_NODE) ? node :
       (node.ownerDocument || node.document || DOM.detectDocument(node)));
  },
  /**
   * Alias for getElementById.
   *
   * @param  {String|Element}    id     Element ID or a DOM node.
   * @param  {Element|Document}  (doc)  (Optional) A context node.
   * @return {Element}                  The element with the given ID,
   *                                      or the node passed in.
   * @type   Function
   * @function
   * @static
   * @public
   */
  byId : function(id, doc) {
    return isString(id) ?
      (doc || Pot.currentDocument()).getElementById(id) : id;
  },
  /**
   * Get the element(s) by simple CSS selector expression.
   * If .querySelector is available then will use it.
   *
   * @example
   *   var elem;
   *   elem = getElement('#foo');
   *   // @results  elem = Element e.g. <div id="foo"/>
   *   elem = getElement('.bar');
   *   // @results  elem = Element e.g. <div class="bar"/>
   *   elem = getElement('span.bar');
   *   // @results  elem = Element e.g. <span class="bar"/>
   *   elem = getElement('textarea');
   *   // @results  elem = Element e.g. <textarea>...</textarea>
   *   elem = getElement('[name="foo"]');
   *   // @results  elem = Element e.g. <div name="foo"/>
   *   elem = getElement('input[type="text"]');
   *   // @results  elem = Element e.g. <input type="text"/>
   *   elem = getElement('[action]');
   *   // @results  elem = Element e.g. <form action="..."/>
   *   elem = getElement('<div/>');
   *   // @results  elem = new Element e.g. <div/>
   *   elem = getElement('<div name="foo">Hello foo.</div>');
   *   // @results  elem = new Element e.g. <div name="foo">Hello foo.</div>
   *   elem = getElement('*');
   *   // @results  elem = All Elements, but will be returned first item.
   *   //                              e.g. <html lang="ja"/>
   *   // Multiple:
   *   var elems;
   *   elems = getElement('#foo, .bar, *[name="baz"]', document, true);
   *   // @results
   *   //   elems = [<div id="foo"/>, <div class="bar"/>, <div name="baz"/>]
   *   elems = getElement('*', getElement('div#foo'), true);
   *   // @results
   *   //   elems = Return all childNodes in <div id="foo">...</div>
   *
   *
   * @param  {String}            selector   The simple CSS selector.
   * @param  {Document|Element}  (context)  The target context or element.
   * @param  {Boolean}           (multi)    Whether to get the
   *                                          multiple elements.
   *                                        Default is single mode.
   * @return {Array|Element}                The result element(s).
   * @type   Function
   * @function
   * @static
   * @public
   */
  getElement : (function() {
    // http://www.w3.org/TR/css3-selectors/
    // http://www.w3.org/TR/REC-html40/types.html#type-name
    // ID and NAME tokens must begin with a letter ([A-Za-z])
    // and may be followed by any number of letters,
    // digits ([0-9]), hyphens ("-"), underscores ("_"),
    // colons (":"), and periods (".").
    /**@ignore*/
    var PATTERNS = (function() {
      var
      ident = '[\\w\\u00C0-\\uFFFF-]',
      space = '[\\s\\u00A0]',
      /**@ignore*/
      re = function() {
        return new RegExp(arrayize(arguments).join(''));
      };
      /**@ignore*/
      return {
        /**@ignore*/
        TAG : {
          /**@ignore*/
          re   : re('^([*]|', ident, '+)'),
          /**@ignore*/
          func : function(o, m, doc, multi) {
            o.tag = m[1];
            return byTag(o, m[1], doc, multi);
          }
        },
        /**@ignore*/
        ID : {
          /**@ignore*/
          re   : re('^#(', ident, '+)'),
          /**@ignore*/
          func : function(o, m, doc, multi) {
            return byId(o, m[1], doc, multi);
          }
        },
        /**@ignore*/
        CLASS : {
          /**@ignore*/
          re   : re('^[.](', ident, '+)'),
          /**@ignore*/
          func : function(o, m, doc, multi) {
            return byClass(o, m[1], doc, multi);
          }
        },
        /**@ignore*/
        NAME : {
          /**@ignore*/
          re   : re('^\\[', space, '*name', space,
                    '*=', space,
                    '*["\']*(', ident, '+)[\'"]*', space,
                    '*\\]'
                 ),
          /**@ignore*/
          func : function(o, m, doc, multi) {
            return byName(o, m[1], doc, multi);
          }
        },
        /**@ignore*/
        ATTR : {
          /**@ignore*/
          re   : re('^\\[', space, '*(', ident, '+)', space,
                    '*([~*|^$!]?=|)', space,
                    '*["\']?(.*?(?=["\'])|[^\'"[\\]]*)[\'"]?', space,
                    '*\\]'
                 ),
          /**@ignore*/
          func : function(o, m, doc, multi) {
            if (m[2]) {
              return byAttr(o, m[1], m[2], m[3], doc, multi);
            } else {
              return byAttr(o, m[1], null, null, doc, multi);
            }
          }
        },
        /**@ignore*/
        PSEUDO : {
          /**@ignore*/
          re   : re('^::?((?:[()]|', ident, ')+)'),
          /**@ignore*/
          func : function(o, m, doc, multi) {
            return byPseudo(o, m[1], doc, multi);
          }
        },
        /**@ignore*/
        RELATIVE : {
          /**@ignore*/
          re   : re('^', space, '*((?:', space, '+|[>+~])',
                    '(?=', space, '*(?:', ident, '|[*#.[\\]:])))',
                    space, '*'
                 ),
          func : function(o, m, doc, multi) {
            o.relative = trim(m[1]) || ' ';
            o.relFirst = true;
          }
        },
        /**@ignore*/
        SPLIT  : re(space, '*,+', space, '*'),
        /**@ignore*/
        SPACES : re(space, '+'),
        /**@ignore*/
        QUOTES : /"[^"]*?"|'[^']*?'/g,
        /**@ignore*/
        PARSE_ORDER : {
          TAG      : 1,
          ID       : 2,
          CLASS    : 3,
          NAME     : 4,
          ATTR     : 5,
          PSEUDO   : 6,
          RELATIVE : 7
        }
      };
    }());
    /**@ignore*/
    function normalizeElements(elems) {
      var r = [], i, j, len, dups = [];
      len = elems && elems.length;
      if (len) {
        for (i = 0; i < len; i++) {
          for (j = i + 1; j < len; j++) {
            if (elems[i] === elems[j]) {
              dups[j] = i;
            }
          }
          if (elems[i] && !(i in dups)) {
            r[r.length] = elems[i];
          }
        }
      }
      return r;
    }
    /**@ignore*/
    function searchReplace(o, re, sel, doc, multi) {
      var m = sel.match(re.re), result;
      if (m && m[0]) {
        sel = sel.replace(m[0], '');
        result = re.func(o, m, doc, multi);
        if (o.relative) {
          if (!o.relFirst) {
            if (multi) {
              o.relments = result ? arrayize(result) : [];
            } else {
              o.relments = (result && result[0]) || result || null;
            }
            o.relmDone = true;
          }
        } else {
          if (multi) {
            o.elements = result ? arrayize(result) : [];
          } else {
            o.elements = (result && result[0]) || result || null;
          }
          o.elemDone = true;
        }
      }
      return sel;
    }
    /**@ignore*/
    function getCurrentElements(o) {
      var result;
      if (o.relmDone) {
        result = o.relments;
      } else if (o.elemDone) {
        result = o.elements;
      } else {
        return false;
      }
      return result ? arrayize(result) : [];
    }
    /**@ignore*/
    function selectRelative(o, doc, multi) {
      var result = [], parents, childs, child, i, j, len, plen, node, has;
      parents = arrayize(o.elements);
      plen = parents.length;
      if (o.relments) {
        childs = arrayize(o.relments);
        len = childs.length;
        for (i = 0; i < len; i++) {
          child = childs[i];
          node = child;
          has = false;
          try {
            switch (o.relative) {
              case ' ':
                  while ((node = node.parentNode)) {
                    for (j = 0; j < plen; j++) {
                      if (parents[j] === node) {
                        has = true;
                        break;
                      }
                    }
                    if (has) {
                      break;
                    }
                  }
                  break;
              case '>':
                  node = node.parentNode;
                  for (j = 0; j < plen; j++) {
                    if (parents[j] === node) {
                      has = true;
                      break;
                    }
                  }
                  break;
              case '+':
                  while ((node = node.previousSibling)) {
                    if (node.nodeType == DOM.NodeType.ELEMENT_NODE) {
                      for (j = 0; j < plen; j++) {
                        if (parents[j] === node) {
                          has = true;
                          break;
                        }
                      }
                      break;
                    }
                  }
                  break;
              case '~':
                  while ((node = node.previousSibling)) {
                    if (node.nodeType == DOM.NodeType.ELEMENT_NODE) {
                      for (j = 0; j < plen; j++) {
                        if (parents[j] === node) {
                          has = true;
                          break;
                        }
                      }
                      if (has) {
                        break;
                      }
                    }
                  }
                  break;
              default:
                  has = false;
                  break;
            }
          } catch (e) {
            has = false;
          }
          if (has) {
            result[result.length] = child;
          }
        }
      }
      if (multi) {
        o.elements = result || [];
      } else {
        o.elements = (result && result[0]) || null;
      }
    }
    /**@ignore*/
    function getAll(o, doc, multi) {
      var result, context, elems;
      context = doc || Pot.currentDocument();
      o.tag = o.tag || '*';
      elems = getCurrentElements(o);
      if (elems === false) {
        if (context.getElementsByTagName) {
          result = context.getElementsByTagName(o.tag);
        } else if (context.querySelectorAll) {
          result = context.querySelectorAll(o.tag);
        } else {
          result = [];
        }
      } else {
        result = elems;
      }
      if (!result || !result.length) {
        result = [];
      }
      result = arrayize(result);
      if (multi) {
        return result;
      } else {
        return (result && result[0]) || null;
      }
    }
    /**@ignore*/
    function byId(o, id, doc, multi) {
      var result, context, elems, elem, i, len;
      if (!id) {
        return multi ? [] : null;
      }
      context = doc || Pot.currentDocument();
      elems = getCurrentElements(o);
      if (elems === false) {
        result = context.getElementById(id);
      } else if (elems && elems.length) {
        result = null;
        len = elems.length;
        for (i = 0; i < len; i++) {
          elem = elems[i];
          if (elem &&
              (elem.id == id || DOM.getAttr(elem, 'id') == id)) {
            result = elem;
            break;
          }
        }
      }
      if (!result) {
        return multi ? [] : null;
      }
      if (multi) {
        return result ? [result] : [];
      } else {
        return result || null;
      }
    }
    /**@ignore*/
    function byTag(o, tag, doc, multi) {
      var result, elems, context, tagName, elem, i, len;
      o.tag = tag || o.tag || '*';
      context = doc || Pot.currentDocument();
      elems = getCurrentElements(o);
      if (elems === false) {
        if (!o.tag || o.tag === '*') {
          result = getAll(o, context, multi);
        } else {
          result = context.getElementsByTagName(o.tag);
        }
      } else if (elems && elems.length) {
        if (!o.tag || o.tag === '*') {
          result = elems;
        } else {
          tagName = stringify(o.tag).toLowerCase();
          result = [];
          len = elems.length;
          for (i = 0; i < len; i++) {
            elem = elems[i];
            if (elem && DOM.tagNameOf(elem) === tagName) {
              result[result.length] = elem;
            }
          }
        }
      }
      if (multi) {
        if (isArrayLike(result)) {
          result = (result && result.length) ? arrayize(result) : [];
        } else {
          result = result ? arrayize(result) : [];
        }
      } else {
        if (isArrayLike(result)) {
          result = ((result && result.length) ? result[0] : null) || null;
        } else {
          result = result || null;
        }
      }
      return result;
    }
    /**@ignore*/
    function byName(o, name, doc, multi) {
      var result, elems, context, elem, i, len;
      if (!name) {
        return multi ? [] : null;
      }
      context = doc || Pot.currentDocument();
      elems = getCurrentElements(o);
      if (elems === false) {
        result = context.getElementsByName(name);
      } else {
        result = [];
        len = elems.length;
        for (i = 0; i < len; i++) {
          elem = elems[i];
          if (elem &&
              (elem.name == name || DOM.getAttr(elem, 'name') == name)) {
            result[result.length] = elem;
          }
        }
      }
      if (multi) {
        if (isArrayLike(result)) {
          result = (result && result.length) ? arrayize(result) : [];
        } else {
          result = result ? arrayize(result) : [];
        }
      } else {
        if (isArrayLike(result)) {
          result = ((result && result.length) ? result[0] : null) || null;
        } else {
          result = result || null;
        }
      }
      return result;
    }
    /**@ignore*/
    function byClass(o, name, doc, multi) {
      var r = [], re, elems, elem, i, len;
      if (!name) {
        return multi ? [] : null;
      }
      re = PATTERNS.SPACES;
      elems = getCurrentElements(o);
      if (elems === false) {
        elems = getAll(o, doc, multi);
      }
      elems = arrayize(elems);
      len = elems.length;
      for (i = 0; i < len; i++) {
        elem = elems[i];
        if (elem && elem.className && (elem.className == name ||
            Pot.Struct.contains(elem.className.split(re), name))) {
          if (multi) {
            r[r.length] = elem;
          } else {
            r = elem || null;
            break;
          }
        }
      }
      return r;
    }
    /**@ignore*/
    function byAttr(o, name, op, value, doc, multi) {
      var result = [], attr, elems, node, selector, dir, raw,
          elem, i, len, has, aval;
      if (!name) {
        return multi ? [] : null;
      }
      node = doc || Pot.currentDocument();
      dir = DOM.AttrMaps.dir;
      raw = DOM.AttrMaps.raw;
      elems = getCurrentElements(o);
      if (elems === false) {
        if (node.querySelectorAll) {
          attr = raw[name] || name;
          if (op != null) {
            selector = '*[' + attr + op +
                        '"' + Pot.Sanitizer.escapeString(value) + '"]';
          } else {
            selector = '*[' + attr + ']';
          }
          if (multi) {
            result = node.querySelectorAll(selector);
            if (!result || !result.length) {
              result = [];
            } else {
              result = arrayize(result);
            }
          } else {
            result = node.querySelector(selector) || null;
          }
          return result;
        }
        elems = getAll(o, node, multi);
      }
      elems = arrayize(elems);
      len = elems.length;
      for (i = 0; i < len; i++) {
        elem = elems[i];
        has = false;
        if (isElement(elem)) {
          if (op != null) {
            aval = DOM.getAttr(elem, name);
            switch (op) {
              case '=':
                  has = (aval == value);
                  break;
              case '~=':
                  has = new RegExp(
                          '(?:^|\\s)' + rescape(value) + '(?:\\s|$)'
                        ).test(aval);
                  break;
              case '|=':
                  has = (aval == value ||
                         String(aval).indexOf(value + '-') === 0);
                  break;
              case '^=':
                  has = Pot.Text.startsWith(aval, value);
                  break;
              case '$=':
                  has = Pot.Text.endsWith(aval, value);
                  break;
              case '*=':
                  has = Pot.Struct.contains(aval, value);
                  break;
              case '!=':
                  has = (aval != value);
                  break;
              default:
                  has = false;
            }
          } else {
            has = DOM.hasAttr(elem, name);
          }
          if (has) {
            if (multi) {
              result[result.length] = elem;
            } else {
              result = elem || null;
              break;
            }
          }
        }
      }
      if (!multi && isArrayLike(result)) {
        if (result && result.length) {
          result = result.shift() || null;
        } else {
          result = null;
        }
      }
      return result;
    }
    /**@ignore*/
    function byPseudo(o, op, doc, multi) {
      var result = [], elems, context, elem, i, len, node,
          parent, count, ok, attr, type, name, checkSelect,
          pseudo = stringify(op, true).toLowerCase();
      if (!pseudo) {
        return multi ? [] : null;
      }
      context = doc || Pot.currentDocument();
      elems = getCurrentElements(o);
      if (elems === false) {
        elems = getAll(o, context, multi);
      }
      elems = arrayize(elems);
      len = elems.length;
      for (i = 0; i < len; i++) {
        elem = elems[i];
        node = elem;
        try {
          switch (pseudo) {
            case 'first-child':
                while ((node = node.previousSibling)) {
                  if (node.nodeType == DOM.NodeType.ELEMENT_NODE) {
                    throw false;
                  }
                }
                break;
            case 'last-child':
                while ((node = node.nextSibling)) {
                  if (node.nodeType == DOM.NodeType.ELEMENT_NODE) {
                    throw false;
                  }
                }
                break;
            case 'even':
                parent = elem.parentNode;
                if (parent) {
                  count = 0;
                  node = parent.firstChild;
                  for (; node; node = node.nextSibling) {
                    if (node.nodeType == DOM.NodeType.ELEMENT_NODE &&
                        count++ % 2 === 0 && node === elem
                    ) {
                      ok = true;
                      break;
                    }
                  }
                }
                if (!ok) {
                  throw false;
                }
                break;
            case 'odd':
                parent = elem.parentNode;
                if (parent) {
                  count = 0;
                  node = parent.firstChild;
                  for (; node; node = node.nextSibling) {
                    if (node.nodeType == DOM.NodeType.ELEMENT_NODE &&
                        count++ % 2 === 1 && node === elem
                    ) {
                      ok = true;
                      break;
                    }
                  }
                }
                if (!ok) {
                  throw false;
                }
                break;
            case 'focus':
                if (elem === elem.ownerDocument.activeElement) {
                  break;
                }
                throw false;
            case 'enabled':
                if (elem.disabled || elem.type == 'hidden') {
                  throw false;
                }
                break;
            case 'disabled':
                if (!elem.disabled) {
                  throw false;
                }
                break;
            case 'checked':
                if (elem.checked) {
                  break;
                }
                throw false;
            case 'selected':
                if (elem.parentNode) {
                  checkSelect = elem.parentNode.selectedIndex;
                }
                if (elem.selected) {
                  break;
                }
                throw false;
            case 'parent':
                if (!elem.firstChild) {
                  throw false;
                }
                break;
            case 'empty':
                if (elem.firstChild) {
                  throw false;
                }
                break;
            case 'header':
                if (!/h\d/i.test(elem.nodeName)) {
                  throw false;
                }
                break;
            case 'text':
                attr = elem.getAttribute('type');
                type = elem.type;
                if (elem.nodeName.toLowerCase() === 'input' &&
                    'text' === type && (attr === type || attr == null)) {
                  break;
                }
                throw false;
            case 'radio':
                if (elem.nodeName.toLowerCase() === 'input' &&
                    'radio' === elem.type) {
                  break;
                }
                throw false;
            case 'checkbox':
                if (elem.nodeName.toLowerCase() === 'input' &&
                    'checkbox' === elem.type) {
                  break;
                }
                throw false;
            case 'file':
                if (elem.nodeName.toLowerCase() === 'input' &&
                    'file' === elem.type) {
                  break;
                }
                throw false;
            case 'password':
                if (elem.nodeName.toLowerCase() === 'input' &&
                    'password' === elem.type) {
                  break;
                }
                throw false;
            case 'submit':
                name = elem.nodeName.toLowerCase();
                if ((name === 'input' || name === 'button') &&
                    'submit' === elem.type) {
                  break;
                }
                throw false;
            case 'image':
                if (elem.nodeName.toLowerCase() === 'input' &&
                    'image' === elem.type) {
                  break;
                }
                throw false;
            case 'reset':
                name = elem.nodeName.toLowerCase();
                if ((name === 'input' || name === 'button') &&
                    'reset' === elem.type) {
                  break;
                }
                throw false;
            case 'button':
                name = elem.nodeName.toLowerCase();
                if ((name === 'input' && 'button' === elem.type) ||
                    name === 'button') {
                  break;
                }
                throw false;
            case 'input':
                name = elem.nodeName;
                if (/^(?:input|select|textarea|button)$/i.test(name)) {
                  break;
                }
                throw false;
            default:
                throw false;
          }
          result[result.length] = elem;
        } catch (e) {}
        if (!multi && result && result.length) {
          result = result.shift() || null;
          break;
        }
      }
      return result || null;
    }
    /**@ignore*/
    function getElementsBySelector(selector, context, multi, options) {
      var result = [], mark, cc, quotes = [], rep, doc,
          i, len, parts, part, query, o,
          j, q, qlen, regexp,
          beforePart, prevPart, key, k, qLen, qt, regex,
          s = stringify(selector, true);
      if (!s) {
        return null;
      }
      doc = DOM.getOwnerDocument(context) || Pot.currentDocument();
      context || (context = doc);
      if (!selector || !isString(selector)) {
        return multi ? [] : null;
      }
      mark = '';
      do {
        do {
          cc = (Math.random() * 0x7F) >>> 0;
        } while (cc === 0x2C);
        mark += fromCharCode(0, cc, 1);
      } while (~s.indexOf(mark));
      /**@ignore*/
      rep = function(m) {
        var markLen = mark + (quotes.length + 1) + mark;
        quotes[quotes.length] = {
          match : m,
          mark  : markLen
        };
        return markLen;
      };
      s = s.replace(PATTERNS.QUOTES, rep);
      parts = s.split(PATTERNS.SPLIT);
      len = parts.length;
      for (i = 0; i < len; i++) {
        part = parts[i];
        o = {
          tag      : '*',
          elements : null,
          relments : null,
          relative : null,
          relFirst : false,
          elemDone : false,
          relmDone : false
        };
        if (options && options.elements) {
          o.elements = normalizeElements(arrayize(options.elements));
          o.elemDone = true;
        }
        part = trim(part);
        if (part) {
          try {
            query = part;
            qlen = quotes.length;
            for (j = 0; j < qlen; j++) {
              q = quotes[j];
              regexp = new RegExp(rescape(q.mark));
              if (regexp.test(query)) {
                query = query.replace(regexp, q.match);
              }
            }
            if (multi && doc.querySelectorAll) {
              o.elements = Pot.Collection.merge(
                o.elements ? arrayize(o.elements) : [],
                arrayize(doc.querySelectorAll(query))
              );
            } else if (!multi && doc.querySelector) {
              o.elements = doc.querySelector(query) || null;
              throw PotStopIteration;
            }
          } catch (ex) {
            if (ex == PotStopIteration) {
              break;
            }
            do {
              beforePart = part;
              if (o.relFirst) {
                o.relFirst = false;
                o.elemDone = false;
              }
              for (key in PATTERNS.PARSE_ORDER) {
                if (part) {
                  if (key === 'ATTR') {
                    qLen = quotes.length;
                    for (k = 0; k < qLen; k++) {
                      qt = quotes[k];
                      regex = new RegExp(rescape(qt.mark));
                      if (regex.test(part)) {
                        part = part.replace(regex, qt.match);
                        quotes.splice(k, 1);
                      }
                    }
                  }
                  do {
                    prevPart = part;
                    part = searchReplace(
                      o, PATTERNS[key], part, context, multi
                    );
                  } while (prevPart !== part && part && trim(part));
                }
              }
              if (o.relative && !o.relFirst) {
                selectRelative(o, context, multi);
                o.relative = o.relments = null;
                o.relmDone = false;
                o.elemDone = true;
              }
            } while (beforePart !== part && part && trim(part));
          }
        }
        if (multi) {
          result = Pot.Collection.merge(result, arrayize(o.elements));
        } else {
          result = o.elements || null;
          break;
        }
      }
      if (multi) {
        result = normalizeElements(result);
      } else {
        if (isArrayLike(result)) {
          result = result[0] || null;
        } else {
          result = result || null;
        }
      }
      return result;
    }
    return update(function(selector, context, multi) {
      return getElementsBySelector(selector, context, multi);
    }, {
      /**@ignore*/
      find : function(elements, selector, context, multi) {
        var options = {
          elements : elements
        };
        return getElementsBySelector(selector, context, multi, options);
      }
    })
  }()),
  /**
   * @lends Pot.DOM
   */
  /**
   * A shortcut of getElement() method as multiple mode.
   * Get the elements by simple CSS selector expression.
   * If .querySelectorAll is available then will use it.
   *
   * @example
   *   var elems;
   *   elems = getElement('#foo, .bar, *[@name="baz"]', document, true);
   *   // @results
   *   //   elems = [<div id="foo"/>, <div class="bar"/>, <div name="baz"/>]
   *   elems = getElement('*', getElement('div#foo'), true);
   *   // @results
   *   //   elems = Return all childNodes in <div id="foo">...</div>
   *
   *
   * @see    Pot.DOM.getElement
   *
   * @param  {String}            selector   The simple CSS selector.
   * @param  {Document|Element}  (context)  The target context or element.
   * @return {Array}                        The result elements as an Array.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getElements : function(selector, context) {
    return DOM.getElement(selector, context, true);
  },
  /**
   * Check whether the argument object is Window.
   *
   * @see Pot.isWindow
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  isWindow : isWindow,
  /**
   * Check whether the argument object is Document.
   *
   * @see Pot.isDocument
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  isDocument : isDocument,
  /**
   * Check whether the argument object is Element.
   *
   * @see Pot.isElement
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  isElement : isElement,
  /**
   * Check whether the argument object like Node.
   *
   * @see Pot.isNodeLike
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  isNodeLike : isNodeLike,
  /**
   * Check whether the argument object is NodeList.
   *
   * @see Pot.isNodeList
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  isNodeList : isNodeList,
  /**
   * Check whether the argument object is XHTML Document.
   *
   * @param  {Document}  doc  The input document object.
   * @return {Boolean}        Whether `doc` is XHTML.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  isXHTML : function(doc) {
    try {
      return doc != null && doc.documentElement != null &&
             doc.documentElement.tagName !== 'HTML' &&
             doc.createElement('p').tagName === 'p';
    } catch (e) {}
    return false;
  },
  /**
   * Check whether the argument object is XML Document.
   *
   * @param  {Document}  doc  The input document object.
   * @return {Boolean}        Whether `doc` is XML.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  isXML : function(doc) {
    var context = (doc ?
      (doc.ownerDocument || doc.document || doc) : {}).documentElement;
    return context ? context.nodeName !== 'HTML' : false;
  },
  /**
   * Get the tagname of element as lower-case string.
   *
   *
   * @example
   *   var elem = document.getElementsByTagName('*')[15];
   *   if (tagNameOf(elem) === 'div') {
   *     // do something
   *   }
   *
   *
   * @param  {Element}  elem  The target element node.
   * @return {String}         The result of tagname.
   * @type   Function
   * @function
   * @static
   * @public
   */
  tagNameOf : function(elem) {
    return elem ? stringify(elem.tagName).toLowerCase() : '';
  },
  /**
   * Get or set the element's attributes.
   *
   *
   * @param  {Element}        elem  The target element node.
   * @param  {String|Object}  name  Get the attribute if you pass a string.
   *                                Set each attributes if you pass an object.
   * @param  {String|*}             The value to set.
   * @return {*}                    Return the obtained attribute value,
   *                                  or if you set the value then
   *                                  will return the element.
   * @type   Function
   * @function
   * @static
   * @public
   */
  attr : function(elem, name, value) {
    var result, args = arguments;
    each(arrayize(elem), function(el) {
      if (isElement(el) && name != null) {
        switch (args.length) {
          case 0:
          case 1:
              break;
          case 2:
              if (isObject(name)) {
                result = DOM.setAttr(el, name);
              } else {
                result = DOM.getAttr(el, name);
              }
              break;
          case 3:
          default:
              result = DOM.setAttr(el, name, value);
        }
      }
    });
    return result;
  },
  /**
   * Get the node value.
   *
   * @param  {Element}   elem  The input node.
   * @return {String|*}        The result value.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getValue : function(elem) {
    var result, value;
    if (elem) {
      switch (DOM.tagNameOf(elem)) {
        case 'option':
            value = elem.attributes && elem.attributes.value;
            if (!value || value.specified) {
              result = elem.value;
            } else {
              result = elem.text;
            }
            break;
        case 'select':
        default:
            result = elem.value;
      }
      if (isString(result)) {
        result = result.replace(/\r/g, '');
      }
    }
    return stringify(result);
  },
  /**
   * Set the value to element.
   *
   * @param  {Element}  elem   The input element.
   * @param  {*}        value  The value to set.
   * @type   Function
   * @function
   * @static
   * @public
   */
  setValue : function(elem, value) {
    if (isElement(elem)) {
      elem.value = stringify(value, false);
    }
    return elem;
  },
  /**
   * Get the HTML string from element.
   *
   * @param  {Element}  elem  The target element.
   * @return {String}         The result HTML string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getHTMLString : function(elem) {
    var result;
    if (isElement(elem)) {
      try {
        result = elem.innerHTML;
      } catch (e) {}
    }
    return stringify(result);
  },
  /**
   * Set the HTML string to the element.
   *
   * @param  {Element}   elem   The input element.
   * @param  {String|*}  value  The value to set.
   * @type   Function
   * @function
   * @static
   * @public
   */
  setHTMLString : function(elem, value) {
    var html;
    if (isElement(elem)) {
      html = stringify(value);
      try {
        elem.innerHTML = html;
        if (elem.innerHTML != html) {
          throw html;
        }
      } catch (e) {
        try {
          DOM.removeChilds(elem);
          DOM.appendChilds(elem, value);
        } catch (e) {}
      }
    }
    return elem;
  },
  /**
   * Get the outer HTML string to the element.
   *
   * @param  {Element}   elem   The input element.
   * @return {String}           The value of result.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getOuterHTML : function(elem) {
    var result, doc, div;
    if (isElement(elem)) {
      if ('outerHTML' in elem) {
        result = elem.outerHTML;
      } else {
        doc = DOM.getOwnerDocument(elem);
        div = doc.createElement('div');
        div.appendChild(elem.cloneNode(true));
        result = div.innerHTML;
      }
    }
    return stringify(result);
  },
  /**
   * Set the outer HTML string to the element.
   *
   * @param  {Element}   elem   The input element.
   * @param  {String|*}  value  The value to set.
   * @type   Function
   * @function
   * @static
   * @public
   */
  setOuterHTML : function(elem, value) {
    var doc, range, done;
    if (isElement(elem)) {
      value = stringify(value);
      if ('outerHTML' in elem) {
        try {
          elem.outerHTML = value;
          done = true;
        } catch (e) {
          done = false;
        }
      }
      if (!done) {
        try {
          doc = DOM.getOwnerDocument(elem);
          range = doc.createRange();
          range.setStartBefore(elem);
          elem.parentNode.replaceChild(
            range.createContextualFragment(value),
            elem
          );
        } catch (e) {}
      }
    }
    return elem;
  },
  /**
   * Get the text content string from element.
   *
   * @param  {Element}  elem  The target element.
   * @return {String}         The result text content string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getTextContent : update(function(elem) {
    var result, me = DOM.getTextContent, buffer;
    if (isElement(elem)) {
      try {
        if (PotBrowser.msie &&
            Pot.Complex.compareVersions(PotBrowser.msie.version, '9', '<') &&
            ('innerText' in elem)
        ) {
          result = Pot.Text.canonicalizeNL(elem.innerText);
        } else {
          buffer = [];
          me.getTextValue(elem, buffer, true);
          result = buffer.join('');
        }
        if (!result) {
          result = stringify(elem.textContent || elem.innerText, true) || '';
        }
        each(me.NORMALIZE_MAPS, function(map) {
          result = result.replace(map.by, map.to);
        });
        if (/\S/.test(result)) {
          result = trim(result);
        }
      } catch (e) {}
    }
    return stringify(result);
  }, {
    /**
     * @type Array
     * @private
     * @ignore
     */
    NORMALIZE_MAPS : [{
      by : /[\u0009\u0020][\xAD][\u0009\u0020]/g,
      to : ' '
    }, {
      by : /[\xAD]/g,
      to : ''
    }, {
      by : /[\u200B]/g,
      to : ''
    }, {
      by : /[\u0009\u0020\u00A0]+/g,
      to : ' '
    }],
    /**
     * @type {Object}
     * @private
     * @ignore
     */
    IGNORE_TAGS : {
      SCRIPT : 1,
      STYLE  : 1,
      HEAD   : 1,
      IFRAME : 1,
      OBJECT : 1
    },
    /**
     * @type {Object}
     * @private
     * @ignore
     */
    PREDEFINED_TAGS : {
      IMG : ' ',
      BR  : '\n'
    },
    getTextValue : function(node, buffer, normalizeSpace) {
      var that = DOM.getTextContent, value, nodeName, child;
      nodeName = Pot.Text.upper(node.nodeName);
      if (!(nodeName in that.IGNORE_TAGS)) {
        if (node.nodeType == DOM.NodeType.TEXT_NODE) {
          value = stringify(node.nodeValue, true);
          if (normalizeSpace) {
            buffer[buffer.length] = value.replace(/\r\n|\r|\n/g, '');
          } else {
            buffer[buffer.length] = value;
          }
        } else if (nodeName in that.PREDEFINED_TAGS) {
          buffer[buffer.length] = that.PREDEFINED_TAGS[nodeName];
        } else {
          child = node.firstChild;
          while (child) {
            that.getTextValue(child, buffer, normalizeSpace);
            child = child.nextSibling;
          }
        }
      }
    }
  }),
  /**
   * @lends Pot.DOM
   */
  /**
   * Set the Text content string to the element.
   *
   * @param  {Element}   elem   The input element.
   * @param  {String|*}  value  The value to set.
   * @type   Function
   * @function
   * @static
   * @public
   */
  setTextContent : function(elem, value) {
    var text, doc;
    if (isElement(elem)) {
      try {
        text = stringify(value);
        if ('textContent' in elem) {
          elem.textContent = text;
        } else if (elem.firstChild &&
                  elem.firstChild.nodeType == DOM.NodeType.TEXT_NODE) {
          while (elem.lastChild != elem.firstChild) {
            elem.removeChild(elem.lastChild);
          }
          elem.firstChild.data = text;
        } else {
          DOM.removeChilds(elem);
          doc = DOM.getOwnerDocument(elem);
          elem.appendChild(doc.createTextNode(text));
        }
      } catch (e) {}
    }
    return elem;
  },
  /**
   * Get the selection object.
   *
   * @param  {Document|Window|Element|*}  context  The input context.
   * @return {Selection|*}                         The Selection object.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getSelectionObject : function(context) {
    var result, sel, target, doc;
    target = context || Pot.currentWindow();
    if (target) {
      if (target.getSelection) {
        sel = target.getSelection();
      } else if (target.rangeCount) {
        sel = target;
      } else {
        doc = DOM.getOwnerDocument(target);
        if (doc) {
          try {
            sel = doc.documentElement.getSelection();
          } catch (e) {
            try {
              sel = doc.defaultView.getSelection();
            } catch (e) {}
          }
        }
      }
      if (sel && sel.rangeCount && !sel.isCollapsed) {
        result = sel;
      }
    }
    return result;
  },
  /**
   * Get the selection contents.
   *
   * @param  {Window|Document|Node|*}  context  The input context.
   * @return {Object}                           The result contents.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getSelectionContents : function(context) {
    var result, sel;
    sel = DOM.getSelectionObject(context);
    if (sel) {
      result = sel.getRangeAt(0).cloneContents();
    }
    return result;
  },
  /**
   * Get the selection text.
   *
   * @param  {Window|Document|Node|*}  context  The input context.
   * @return {String}                           The selection text.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getSelectionText : function(context) {
    var result = '', sel;
    sel = DOM.getSelectionObject(context);
    if (sel) {
      result = sel.toString();
    }
    return stringify(result);
  },
  /**
   * Get the selection HTML string.
   *
   * @param  {Window|Document|Node|*}  context  The input context.
   * @return {String}                           The selection HTML.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getSelectionHTML : function(context) {
    var result = '', sel, node, doc;
    sel = DOM.getSelectionContents(context);
    doc = DOM.getOwnerDocument(sel);
    if (sel && doc) {
      node = doc.createElement('div');
      node.appendChild(sel);
      result = node.innerHTML;
    }
    return stringify(result);
  },
  /**
   * Coerce to any DOM Node from argument value.
   *
   * @param  {Node|*}  node  The input node.
   * @return {Node|*}        The coerced node.
   * @type   Function
   * @function
   * @static
   * @public
   */
  coerceToNode : function(node) {
    var type;
    if (!node) {
      return node;
    }
    type = typeOf(node);
    switch (type) {
      case 'number':
      case 'boolean':
      case 'string':
          return Pot.currentDocument().createTextNode(node.toString());
    }
    return node;
  },
  /**
   * Remove the element(s) from DOM tree.
   *
   * @param  {Element}  elem  The input elemenet(s).
   * @return {Element}        Returns `elem`.
   * @type   Function
   * @function
   * @static
   * @public
   */
  removeElement : function(elem) {
    var node = DOM.coerceToNode(elem);
    if (node) {
      if (isArrayLike(node)) {
        each(node, function(n) {
          try {
            n.parentNode.removeChild(n);
          } catch (e) {}
        });
      } else {
        try {
          node.parentNode.removeChild(node);
        } catch (e) {}
      }
    }
    return node;
  },
  /**
   * Appends all the child nodes on a DOM node.
   *
   * @param  {Node|Element}  parent  The target parent node.
   * @param  {Node|...Node}  (...)   Nodes to append children from.
   * @return {Node}                  Return the last child node appended.
   * @type   Function
   * @function
   * @static
   * @public
   */
  appendChilds : function(parent/*[, ...childs]*/) {
    var result, childs, args = arrayize(arguments, 1),
        i, j, len, child, chs, n, c;
    if (!parent || !parent.appendChild || args.length === 0) {
      return null;
    }
    if (args.length === 1) {
      childs = arrayize(args[0]);
    } else {
      childs = args;
    }
    len = childs.length;
    for (i = 0; i < len; i++) {
      child = DOM.coerceToNode(childs[i]);
      if (child) {
        try {
          result = parent.appendChild(child);
        } catch (e) {
          chs = child.childNodes;
          if (chs && chs.length) {
            n = chs.length;
            for (j = 0; j < n; j++) {
              c = DOM.coerceToNode(chs[j]);
              if (c) {
                result = parent.appendChild(c);
              }
            }
          }
        }
      }
    }
    return result;
  },
  /**
   * Prepends all the child nodes on a DOM node.
   *
   * @param  {Node|Element}  parent  The target parent node.
   * @param  {Node|...Node}  (...)   Nodes to prepend children from.
   * @return {Node}                  Return the last child node prepended.
   * @type   Function
   * @function
   * @static
   * @public
   */
  prependChilds : function(parent/*[, ...childs]*/) {
    var result, childs, args = arrayize(arguments, 1),
        i, j, len, child, chs, n, c;
    if (!parent || !parent.insertBefore || args.length === 0) {
      return null;
    }
    if (args.length === 1) {
      childs = arrayize(args[0]);
    } else {
      childs = args;
    }
    len = childs.length;
    for (i = 0; i < len; i++) {
      child = DOM.coerceToNode(childs[i]);
      if (child) {
        try {
          result = parent.insertBefore(child, parent.firstChild);
        } catch (e) {
          chs = child.childNodes;
          if (chs && chs.length) {
            n = chs.length;
            for (j = 0; j < n; j++) {
              c = DOM.coerceToNode(chs[j]);
              if (c) {
                result = parent.insertBefore(c, parent.firstChild);
              }
            }
          }
        }
      }
    }
    return result;
  },
  /**
   * Removes all the child nodes on a DOM node.
   *
   * @param  {Node|Element}  node  Node to remove children from.
   * @return {Node|Element}        Returns `node`.
   * @type   Function
   * @function
   * @static
   * @public
   */
  removeChilds : function(node) {
    var child;
    while ((child = node.firstChild)) {
      node.removeChild(child);
    }
    return node;
  },
  /**
   * Get the attribute value.
   *
   * @param  {Element}  node  The target element.
   * @param  {String}   name  The attribute name.
   * @return {String|*}       The arrtibute value.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getAttr : function(node, name) {
    var result = null, dir, raw;
    if (!node) {
      return result;
    }
    dir = DOM.AttrMaps.dir;
    raw = DOM.AttrMaps.raw;
    switch (name) {
      case 'style':
          result = (node.style != null && node.style.cssText) ||
                    (node.getAttribute && node.getAttribute(name)) || null;
          break;
      case 'class':
          result = node.className;
          break;
      case 'for':
          result = node.htmlFor;
          break;
      default:
          try {
            result = node.getAttribute(name) ||
                (name in dir &&
                  (node[dir[name]] || node.getAttribute(dir[name]))) ||
                (name in raw &&
                  (node[raw[name]] || node.getAttribute(raw[name]))) || null;
          } catch (e) {
            result = null;
          }
          break;
    }
    return result;
  },
  /**
   * Set the attribute value(s).
   *
   * @param  {Element}        node   The target element.
   * @param  {String|Object}  name   The attribute name or
   *                                    key-value object.
   * @param  {String|*}      (value) The attribute value to set.
   * @type   Function
   * @function
   * @static
   * @public
   */
  setAttr : function(node, name, value) {
    var args = arguments, attrs = {}, dir, raw;
    if (!node) {
      return false;
    }
    if (args.length >= 3) {
      attrs[name] = value;
    } else {
      attrs = name;
    }
    if (!isObject(attrs)) {
      if (isString(name)) {
        attrs[name] = '';
      } else {
        return false;
      }
    }
    dir = DOM.AttrMaps.dir;
    raw = DOM.AttrMaps.raw;
    each(attrs, function(val, key) {
      try {
        if (key == 'style') {
          if (isObject(val)) {
            each(val, function(v, k) {
              Pot.Style.setStyle(node, k, v);
            });
          } else {
            node.style.cssText = val;
          }
        } else if (key == 'class') {
          node.className = val;
        } else if (key == 'for') {
          node.htmlFor = val;
        } else if (key in dir || key in raw) {
          if (key in dir) {
            node.setAttribute(dir[key], val);
            if (!node.hasAttribute(dir[key])) {
              node.setAttribute(key, val);
            }
          } else {
            node.setAttribute(raw[key], val);
            if (!node.hasAttribute(raw[key])) {
              node.setAttribute(key, val);
            }
          }
        } else {
          node[key] = val;
          if (node[key] != val) {
            node.setAttribute(key, val);
          }
        }
      } catch (e) {}
    });
    return true;
  },
  /**
   * Check whether the attribute is exist.
   *
   * @param  {Element}  node  The target element.
   * @param  {String}   name  The attribute name.
   * @return {Boolean}        Whether the attribute is exist.
   * @type   Function
   * @function
   * @static
   * @public
   */
  hasAttr : function(node, name) {
    var result = false, dir, raw;
    if (!node) {
      return result;
    }
    dir = DOM.AttrMaps.dir;
    raw = DOM.AttrMaps.raw;
    if (node.hasAttribute) {
      try {
        result = node.hasAttribute(name) ||
          (name in dir && node.hasAttribute(dir[name])) ||
          (name in raw && node.hasAttribute(raw[name]));
      } catch (e) {
        result = false;
      }
    } else {
      try {
        result = node.getAttribute(name) != null ||
          (name in dir && node.getAttribute(dir[name]) != null) ||
          (name in raw && node.getAttribute(raw[name]) != null);
      } catch (e) {
        result = false;
      }
    }
    return result;
  },
  /**
   * Remove the attribute.
   *
   * @param  {Element}  node  The target element.
   * @param  {String}   name  The attribute name.
   * @type   Function
   * @function
   * @static
   * @public
   */
  removeAttr : function(node, name) {
    var elem, removals, dir, raw;
    if (!node) {
      return false;
    }
    dir = DOM.AttrMaps.dir;
    raw = DOM.AttrMaps.raw;
    elem = node.ownerElement || node;
    removals = [
      name && name in dir && dir[name],
      name && name in raw && raw[name],
      name || node.name || node
    ];
    each(removals, function(removal) {
      try {
        elem.removeAttribute(removal);
        if (elem.hasAttribute(removal)) {
          throw elem;
        }
      } catch (e) {
        try {
          elem.removeAttributeNode(removal);
        } catch (e) {}
        try {
          elem.removeAttributeNode(elem.getAttributeNode());
        } catch (e) {}
      }
    });
  },
  /**
   * Add the class name to the element.
   *
   * @param  {Element}  elem  The target element.
   * @param  {String}   name  The class name.
   * @return {Element}        Returns `elem`.
   * @type   Function
   * @function
   * @static
   * @public
   */
  addClass : function(elem, name) {
    var names, value, sp;
    if (isElement(elem) && name && isString(name)) {
      names = Pot.Text.splitBySpace(name);
      if (!elem.className && names.length === 1) {
        elem.className = names.join(sp);
      } else {
        value = Pot.Text.wrap(elem.className, sp);
        each(names, function(n) {
          if (n && !~value.indexOf(Pot.Text.wrap(n, sp))) {
            value += n + sp;
          }
        });
        elem.className = trim(Pot.Text.normalizeSpace(value));
      }
    }
    return elem;
  },
  /**
   * Remove the class name from the element.
   *
   * @param  {Element}  elem  The target element.
   * @param  {String}   name  The class name to remove.
   * @return                  Returns `elem`.
   * @type   Function
   * @function
   * @static
   * @public
   */
  removeClass : function(elem, name) {
    var names, value, sp;
    if (isElement(elem) && elem.className) {
      if (name === void 0) {
        elem.className = '';
      } else if (name && isString(name)) {
        sp = ' ';
        names = Pot.Text.splitBySpace(name);
        value = Pot.Text.wrap(
          Pot.Text.splitBySpace(elem.className).join(sp), sp);
        each(names, function(n) {
          if (n) {
            value = value.split(Pot.Text.wrap(n, sp)).join(sp);
          }
        });
        elem.className = trim(Pot.Text.normalizeSpace(value));
      }
    }
    return elem;
  },
  /**
   * Check whether the class name is exist.
   *
   * @param  {Element}  elem  The target element.
   * @param  {String}   name  The class name.
   * @return {Boolean}        Whether the class name is exist.
   * @type   Function
   * @function
   * @static
   * @public
   */
  hasClass : function(elem, name) {
    var result = false, sp = ' ', subject;
    if (isElement(elem) && elem.className && name) {
      subject = Pot.Text.wrap(name, sp);
      if (~(Pot.Text.wrap(
            Pot.Text.normalizeSpace(elem.className),
              sp).indexOf(subject)
           )
      ) {
        result = true;
      }
    }
    return result;
  },
  /**
   * Toggle the specified class name.
   *
   * @param  {Element}  elem  The target element.
   * @param  {String}   name  The class name to toggle.
   * @return {Element}        Returns `elem`.
   * @type   Function
   * @function
   * @static
   * @public
   */
  toggleClass : function(elem, name) {
    if (isElement(elem) && elem.className && name) {
      if (DOM.hasClass(elem, name)) {
        DOM.removeClass(elem, name);
      } else {
        DOM.addClass(elem, name);
      }
    }
    return elem;
  },
  /**
   * Creates an XML document object.
   *
   * @param  {String}   (rootTagName)  (Optional) The root tag name.
   * @param  {String}   (namespaceURI) (Optional) Namespace URI of
   *                                     the document element.
   * @return {Document}                Return the new document.
   * @type   Function
   * @function
   * @static
   * @public
   */
  createDocument : function(rootTagName, namespaceURI) {
    var doc, context, tag, uri;
    tag = stringify(rootTagName);
    uri = stringify(namespaceURI);
    if (uri && !tag) {
      tag = buildSerial(DOM, '');
    }
    context = Pot.currentDocument();
    if (context.implementation &&
        context.implementation.createHTMLDocument) {
      doc = context.implementation.createHTMLDocument('');
    } else if (context.implementation &&
              context.implementation.createDocument) {
      doc = context.implementation.createDocument(uri, tag, null);
    } else if (PotSystem.hasActiveXObject) {
      doc = DOM.createMSXMLDocument();
      if (doc && tag) {
        doc.appendChild(doc.createNode(
          DOM.NodeType.ELEMENT_NODE, tag, uri));
      }
    }
    return doc;
  },
  /**
   * Serialize an element object or subtree to string.
   *
   * @param  {Document|Element}  doc   The document or the root node of
   *                                     the subtree.
   * @return {String}                  The serialized XML/HTML string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  serializeToString : function(doc) {
    var result = '';
    if (doc) {
      if (typeof XMLSerializer !== 'undefined') {
        result = new XMLSerializer().serializeToString(doc);
      } else {
        result = doc.xml || doc.responseXML || doc.outerHTML ||
          (doc.documentElement &&
            (doc.documentElement.xml || doc.documentElement.outerHTML)) ||
          (doc.body &&
            (doc.body.xml || doc.body.outerHTML)) ||
          doc.innerHTML ||
            (doc.documentElement && doc.documentElement.innerHTML) ||
            (doc.body && doc.body.innerHTML) || '';
      }
    }
    return result;
  },
  /**
   * Parse the HTML/XML string and convert to the document object.
   *
   * @param  {String}   string    The target text.
   * @return {Document}           XML/HTML document from the text.
   * @type   Function
   * @function
   * @static
   * @public
   */
  parseFromString : function(string) {
    var doc;
    if (typeof DOMParser !== 'undefined') {
      doc = new DOMParser().parseFromString(string, 'application/xml');
    } else if (PotSystem.hasActiveXObject) {
      doc = DOM.createMSXMLDocument();
      doc.loadXML(string);
    }
    return doc;
  },
  /**
   * Evaluate the XPath expression and select the result node.
   *
   * @param  {String}            exp      The XPath expression.
   * @param  {Document|Element} (context) The conetxt object. e.g. document.
   * @param  {Boolean}          (all)     Whether to make multiple selections.
   * @param  {Boolean}          (asis)    Whether to return the results as is.
   * @return {Array|Element}              Return the selected node(s).
   * @type   Function
   * @function
   * @static
   * @public
   */
  evaluate : update(function(exp, context, all, asis) {
    var doc, expr, xresult = null, result, i, len,
        me = DOM.evaluate,
        item, evaluator, defaultPrefix;
    context || (context = Pot.currentDocument());
    expr = stringify(exp);
    doc = DOM.getOwnerDocument(context);
    if (PotSystem.hasActiveXObject) {
      // Use JavaScript-XPath library in IE.
      // http://coderepos.org/share/wiki/JavaScript-XPath
      if (!doc.evaluate && Pot.currentDocument().evaluate) {
        doc.evaluate = Pot.currentDocument().evaluate;
      }
      if (!doc.evaluate) {
        //TODO: To be able to get the actual node by MSXML XPath.
        try {
          doc = DOM.createMSXMLDocument();
          doc.loadXML(DOM.serializeToString(context));
          doc.setProperty('SelectionLanguage', 'XPath');
          xresult = (doc.documentElement || doc).selectNodes(expr) || [];
          if (!all) {
            return asis ? xresult[0] : me.suitablize(xresult[0]);
          }
          result = [];
          len = xresult.length;
          for (i = 0; i < len; i++) {
            result[result.length] = asis ? xresult[i] :
              me.suitablize(xresult[i]);
          }
          return result;
        } catch (e) {
          return null;
        }
      }
    }
    defaultPrefix = null;
    if (DOM.isXHTML(doc)) {
      defaultPrefix = '__default__';
      expr = me.addDefaultPrefix(expr, defaultPrefix);
    }
    try {
      /**@ignore*/
      evaluator = function(type) {
        /**@ignore*/
        var resolver = function(prefix) {
          return context.lookupNamespaceURI(
            (prefix === defaultPrefix) ? null : prefix
          ) || doc.documentElement && doc.documentElement.namespaceURI || '';
        };
        return doc.evaluate(expr, context, resolver, type, null);
      };
      xresult = evaluator(DOM.XPathResult.ANY_TYPE);
    } catch (e) {
      /**@ignore*/
      evaluator = function(type) {
        try {
          return expr.evaluate(context, type, null);
        } catch (ex) {
          return expr.evaluate(doc, type, null);
        }
      };
      try {
        expr = doc.createExpression(expr, function(prefix) {
          try {
            return doc.createNSResolver(
              context.documentElement ||
              context).lookupNamespaceURI(prefix) ||
              context.namespaceURI || doc.documentElement.namespaceURI || '';
          } catch (er) {
            return false;
          }
        });
        if (!expr || !expr.evaluate) {
          throw expr;
        }
      } catch (e) {
        expr = doc.createExpression(expr, {
          /**@ignore*/
          lookupNamespaceURI : function(prefix) {
            switch (String(prefix).toLowerCase()) {
              case 'xul'   : return XUL_NS_URI;
              case 'html'  : return HTML_NS_URI;
              case 'xhtml' : return XHTML_NS_URI;
              default      : return '';
            }
          }
        });
      }
    }
    if (xresult === null) {
      xresult = evaluator(DOM.XPathResult.ANY_TYPE);
    }
    switch (xresult.resultType) {
      case DOM.XPathResult.NUMBER_TYPE:
          result = xresult.numberValue;
          break;
      case DOM.XPathResult.STRING_TYPE:
          result = xresult.stringValue;
          break;
      case DOM.XPathResult.BOOLEAN_TYPE:
          result = xresult.booleanValue;
          break;
      case DOM.XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
          if (!all) {
            item = xresult.iterateNext();
            result = asis ? item : me.suitablize(item);
            break;
          }
          xresult = evaluator(DOM.XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
          result = [];
          len = xresult.snapshotLength;
          for (i = 0; i < len; i++) {
            item = xresult.snapshotItem(i);
            result[result.length] = asis ? item : me.suitablize(item);
          }
          break;
      default:
          result = null;
          break;
    }
    return result;
  }, {
    /**@ignore*/
    suitablize : function(node) {
      if (node) {
        switch (node.nodeType) {
          case DOM.NodeType.ELEMENT_NODE:
              return node;
          case DOM.NodeType.ATTRIBUTE_NODE:
          case DOM.NodeType.TEXT_NODE:
              return node.textContent || node.innerText || node.value || node;
          default:
              return node;
        }
      }
    },
    /**
     * Add prefix to name-test that has not prefix in XPath expression.
     *
     * e.g.    '//body[@class = "foo"]/p'
     *      -> '//prefix:body[@class = "foo"]/prefix:p'
     *
     * via:
     *   http://gist.github.com/184276
     *   http://nanto.asablo.jp/blog/2008/12/11/4003371
     *
     * @private
     * @ignore
     */
    addDefaultPrefix : function(xpath, prefix) {
      var tokenPattern, tokenType, replacer,
          TERM = 1, OPERATOR = 2, MODIFIER = 3;
      tokenPattern = new RegExp(
            '(' + '[A-Za-z_\\u00C0-\\uFFFD][-.\\w\\u00B7-\\uFFFD]*' +
            '|' + '[*]' +
            ')' +                            // 1 identifier
            '\\s*' +
            '(::?|[(])?' +                   // 2 suffix
        '|' +
                '(' + '".*?"' +              // 3 term
                '|' + "'.*?'" +
                '|' + '\\d+(?:[.]\\d*)?' +
                '|' + '[.](?:[.]|\\d+)?' +
                '|' + '[)\\]]' +
                ')' +
            '|' +
                '(' + '//?' +                // 4 operator
                '|' + '!=' +
                '|' + '[<>]=?' +
                '|' + '[([|,=+-]' +
                ')' +
            '|' +
                '([@$])',                    // 5 modifier
      'g');
      tokenType = OPERATOR;
      prefix += ':';
      /**@ignore*/
      replacer = function(token, identifier, suffix,
                          term, operator, modifier) {
        if (suffix) {
          tokenType =
            (suffix === ':' ||
            (suffix === '::' && (identifier === 'attribute' ||
                                 identifier === 'namespace'))) ?
            MODIFIER : OPERATOR;
        } else if (identifier) {
          if (tokenType === OPERATOR && identifier !== '*') {
            token = prefix + token;
          }
          tokenType = (tokenType === TERM) ? OPERATOR : TERM;
        } else {
          tokenType = term ? TERM : operator ? OPERATOR : MODIFIER;
        }
        return token;
      };
      return xpath.replace(tokenPattern, replacer);
    }
  }),
  /**
   * @lends Pot.DOM
   */
  /**
   * Convert HTML string to HTML Document object.
   *
   * @param  {String}  htmlString   A subject HTML string.
   * @param  {Object}  (context)    (Optional) A context object.
   *                                  e.g. document.
   * @return {Object}               Return the HTML Document object.
   * @type   Function
   * @function
   * @static
   * @public
   */
  convertToHTMLDocument : update(function(htmlString, context) {
    var me = DOM.convertToHTMLDocument,
        doc, html, patterns, xsl, xsltp, range;
    patterns = {
      remove : [
        /<\s*!\s*DOCTYPE[^>]*>/gi,
        /<\s*html\b[^>]*>/gi,
        /<\s*\/\s*html\s*>[\s\S]*/gi
      ]
    };
    html = stringify(htmlString);
    each(patterns.remove, function(re) {
      html = html.replace(re, '');
    });
    xsl = DOM.parseFromString(
      '<' + '?xml version="1.0"?' + '>' +
      '<stylesheet version="1.0" xmlns="' + XSL_NS_URI + '">' +
        '<output method="html" />' +
      '</stylesheet>'
    );
    if (PotSystem.hasActiveXObject) {
      doc = new ActiveXObject('htmlfile');
      doc.open();
      doc.write(html);
      doc.close();
    } else {
      try {
        doc = context || Pot.currentDocument();
        xsltp = new XSLTProcessor();
        xsltp.importStylesheet(xsl);
        doc = xsltp.transformToDocument(
          doc.implementation.createDocument('', '', null)
        );
        doc.appendChild(doc.createElement('html'));
        range = doc.createRange();
        range.selectNodeContents(doc.documentElement);
        doc.documentElement.appendChild(range.createContextualFragment(html));
      } catch (e) {
        try {
          doc = me.createHTMLDocumentFromString(html);
        } catch (e) {}
      }
    }
    return doc;
  }, {
    /**
     * A helper function for convertToHTMLDocument.
     *
     * from: Taberareloo lib.
     * original: http://gist.github.com/198443
     *
     * @private
     * @ignore
     */
    createHTMLDocumentFromString : function(srcString) {
      var doc, context, range, fragment, headElements, child, head, body;
      context = Pot.currentDocument();
      doc = DOM.createDocument('html');
      range = context.createRange();
      range.selectNodeContents(doc.documentElement);
      fragment = range.createContextualFragment(srcString);
      headElements = {
        title   : true,
        meta    : true,
        link    : true,
        script  : true,
        style   : true,
        object  : false,
        base    : true,
        isindex : false
      };
      try {
        head = doc.getElementsByTagName('head')[0];
        if (!head) {
          throw head;
        }
      } catch (e) {
        head = doc.createElement('head');
      }
      try {
        body = doc.getElementsByTagName('body')[0];
        if (!body) {
          throw body;
        }
      } catch (e) {
        body = doc.createElement('body');
      }
      HEADING: {
        while ((child = fragment.firstChild)) {
          switch (child.nodeType) {
            case DOM.NodeType.ELEMENT_NODE:
                if (!headElements[Pot.Text.lower(child.nodeName)]) {
                  break HEADING;
                }
                break;
            case DOM.NodeType.TEXT_NODE:
                if (/\S/.test(child.nodeValue)) {
                  break HEADING;
                }
          }
          head.appendChild(child);
        }
      }
      body.appendChild(fragment);
      doc.documentElement.appendChild(head);
      doc.documentElement.appendChild(body);
      return doc;
    }
  }),
  /**
   * @lends Pot.DOM
   */
  /**
   * Convert to a HTML string from DOM document object.
   *
   * from: Taberareloo lib.
   * via: http://nanto.asablo.jp/blog/2010/02/05/4858761
   *
   * @param  {Document|Node}  context  The input context.
   * @param  {Boolean}        (safe)   Whether sanitize the HTML nodes,
   *                                     for safely.
   * @return {String}                  The result HTML string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  convertToHTMLString : update(function(context, safe) {
    var result, me = DOM.convertToHTMLString, node, doc, root,
        range, uniqid, fragment, re, tag;
    if (!context || (context.getRangeAt && context.isCollapsed)) {
      return '';
    }
    doc = isDocument(context) ? context : Pot.currentDocument();
    tag = buildSerial(DOM, 'tag');
    uniqid = buildSerial(DOM, 'uid');
    re = new RegExp('</?(?:' + uniqid + '|' + tag + ')\\b[^>]*>', 'gi');
    if (context.getRangeAt) {
      range = context.getRangeAt(0);
      node = range.cloneContents();
      root = range.commonAncestorContainer.cloneNode(false);
    } else {
      range = null;
      node = context.cloneNode(true);
      if (!node) {
        node = context.documentElement &&
              context.documentElement.cloneNode(true) ||
              context.body && context.body.cloneNode(true);
      }
      root = null;
    }
    if (!root || root.nodeType != DOM.NodeType.ELEMENT_NODE) {
      try {
        root = node.ownerDocument.createElement(tag);
      } catch (e) {
        root = doc.createElement(tag);
      }
    }
    DOM.appendChilds(root, node);
    if (safe) {
      try {
        each([{
          elems : DOM.evaluate(
            'descendant::*[contains(",' +
            me.UNSAFE_ELEMENTS +
            ',",concat(",",local-name(.),","))]',
            root, true
          ),
          method : DOM.removeElement
        }, {
          elems : DOM.evaluate(
            'descendant::*/@*[not(contains(",' +
            me.SAFE_ATTRIBUTES +
            ',",concat(",",local-name(.),",")))]',
            root, true, true
          ),
          method : DOM.removeAttr
        }, {
          elems : DOM.evaluate(
            'descendant-or-self::a',
            root, true
          ),
          method : me.resetter.href
        }, {
          elems : DOM.evaluate(
            'descendant-or-self::*' +
            '[contains(" img embed ",concat(" ",local-name(.)," "))]',
            root, true
          ),
          method : me.resetter.src
        }, {
          elems : DOM.evaluate(
            'descendant-or-self::object',
            root, true
          ),
          method : me.resetter.data
        }], function(item) {
          each(item.elems || [], item.method);
        });
      } catch (e) {
        if (typeof toStaticHTML !== 'undefined') {
          try {
            root.innerHTML = toStaticHTML(root.innerHTML);
          } catch (e) {}
        }
      }
    }
    fragment = doc.createDocumentFragment();
    result = fragment.appendChild(doc.createElement(uniqid));
    DOM.appendChilds(result, root);
    return trim(DOM.serializeToString(result)).replace(re, '');
  }, {
    /**@ignore*/
    UNSAFE_ELEMENTS :
      'frame,script,style,frame,iframe',
    /**@ignore*/
    SAFE_ATTRIBUTES :
      'action,cellpadding,cellspacing,checked,cite,clear,' +
      'cols,colspan,content,coords,enctype,face,for,href,' +
      'label,method,name,nohref,nowrap,rel,rows,rowspan,'  +
      'shape,span,src,style,title,target,type,usemap,value',
    // resolve relative path
    /**@ignore*/
    resetter : (function(o) {
      each(['href', 'data', 'src'], function(attr) {
        /**@ignore*/
        o[attr] = function(elem) {
          if (elem && DOM.hasAttr(elem, attr)) {
            elem[attr] = elem[attr];
          }
        };
      });
      return o;
    })({})
  }),
  /**
   * @lends Pot.DOM
   */
  /**
   * Get the MSXML Document object.
   *
   * @private
   * @ignore
   */
  createMSXMLDocument : function(count) {
    var result;
    if (PotSystem.hasActiveXObject) {
      each([
        'Msxml2.DOMDocument.3.0',
        'Msxml2.DOMDocument.6.0',
        'Microsoft.XMLDOM.1.0',
        'Microsoft.XMLDOM',
        'Msxml2.DOMDocument.5.0',
        'Msxml2.DOMDocument.4.0',
        'MSXML2.DOMDocument',
        'MSXML.DOMDocument'
      ], function(prog) {
        try {
          result = new ActiveXObject(prog);
        } catch (e) {}
        if (result) {
          if (count == null || count-- <= 0) {
            throw PotStopIteration;
          }
        }
      });
      if (result) {
        result.async = false;
        // Prevent potential vulnerabilities exposed by MSXML2, see
        // http://b/1707300 and http://wiki/Main/ISETeamXMLAttacks for details.
        result.resolveExternals = false;
        result.validateOnParse = false;
        try {
          // IE6 or IE7 that are on XP SP2 or earlier without MSXML updates.
          // See http://msdn.microsoft.com/en-us/library/ms766391(VS.85).aspx
          result.setProperty('ProhibitDTD', true);
          result.setProperty('MaxXMLSize', 2 * 1024);
          result.setProperty('MaxElementDepth', 256);
        } catch (e) {}
      }
    }
    return result;
  },
  /**
   * Checks whether element is in the view.
   *
   * @param  {Element}  element  The target element.
   * @return {Boolean}  Whether element is in the view.
   * @type   Function
   * @function
   * @static
   * @public
   */
  isElementInView : function(element) {
    var result = false,
        win, doc, de, body,
        scrollLeft, scrollTop,
        rect, left, top;
    try {
      elem = element.jquery ? element.get(0) : element;
      rect = elem.getClientRects()[0];
      if (!rect) {
        throw false;
      }
      win = Pot.currentWindow();
      doc = Pot.currentDocument();
      de = doc.documentElement;
      body = doc.body || de;
      scrollLeft = Math.max(de.scrollLeft, body.scrollLeft);
      scrollTop  = Math.max(de.scrollTop, body.scrollTop);
      if (PotBrowser.opera &&
          (rect.left < 0 || rect.left > win.innerWidth ||
           rect.top  < 0 || rect.top  > win.innerHeight)) {
        throw false;
      }
    } catch (e) {
      return false;
    }
    left = (rect.left - 0) || 0;
    top  = (rect.top  - 0) || 0;
    if (PotBrowser.opera || PotBrowser.safari) {
      left += scrollLeft;
      top  += scrollTop;
    } else if (PotBrowser.firefox) {
      left += 1;
      top  += 1;
    }
    try {
      if (doc.elementFromPoint(left, top) === elem) {
        result = true;
      }
    } catch (e) {}
    return result
  }
});
}(Pot.DOM));

// Update Pot object.
Pot.update({
  detectWindow          : Pot.DOM.detectWindow,
  detectDocument        : Pot.DOM.detectDocument,
  getOwnerDocument      : Pot.DOM.getOwnerDocument,
  getElement            : Pot.DOM.getElement,
  getElements           : Pot.DOM.getElements,
  isXHTML               : Pot.DOM.isXHTML,
  isXML                 : Pot.DOM.isXML,
  tagNameOf             : Pot.DOM.tagNameOf,
  getNodeValue          : Pot.DOM.getValue,
  setNodeValue          : Pot.DOM.setValue,
  getHTMLString         : Pot.DOM.getHTMLString,
  setHTMLString         : Pot.DOM.setHTMLString,
  getOuterHTML          : Pot.DOM.getOuterHTML,
  setOuterHTML          : Pot.DOM.setOuterHTML,
  getTextContent        : Pot.DOM.getTextContent,
  setTextContent        : Pot.DOM.setTextContent,
  getSelectionObject    : Pot.DOM.getSelectionObject,
  getSelectionContents  : Pot.DOM.getSelectionContents,
  getSelectionText      : Pot.DOM.getSelectionText,
  getSelectionHTML      : Pot.DOM.getSelectionHTML,
  coerceToNode          : Pot.DOM.coerceToNode,
  removeElement         : Pot.DOM.removeElement,
  appendChilds          : Pot.DOM.appendChilds,
  prependChilds         : Pot.DOM.prependChilds,
  removeChilds          : Pot.DOM.removeChilds,
  getAttr               : Pot.DOM.getAttr,
  setAttr               : Pot.DOM.setAttr,
  hasAttr               : Pot.DOM.hasAttr,
  removeAttr            : Pot.DOM.removeAttr,
  addClass              : Pot.DOM.addClass,
  removeClass           : Pot.DOM.removeClass,
  hasClass              : Pot.DOM.hasClass,
  toggleClass           : Pot.DOM.toggleClass,
  serializeToXMLString  : Pot.DOM.serializeToString,
  parseFromXMLString    : Pot.DOM.parseFromString,
  evaluate              : Pot.DOM.evaluate,
  attr                  : Pot.DOM.attr,
  convertToHTMLDocument : Pot.DOM.convertToHTMLDocument,
  convertToHTMLString   : Pot.DOM.convertToHTMLString,
  isElementInView       : Pot.DOM.isElementInView
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Style.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * CSS utilities.
   *
   * @name  Pot.Style
   * @type  Object
   * @class
   * @static
   * @public
   */
  Style : {}
});

update(Pot.Style, {
  /**
   * @lends Pot.Style
   */
  /**
   * @const
   * @ignore
   */
  NAME : 'Style',
  /**
   * Return the string representation of object.
   *
   * @return {String}  The string representation of object.
   * @type   Function
   * @function
   * @static
   * @public
   */
  toString : PotToString,
  /**
   * Exclude the following css properties to add px
   *
   * @private
   * @ignore
   */
  NumberTypes : {
    fillOpacity : true,
    fontWeight  : true,
    lineHeight  : true,
    opacity     : true,
    orphans     : true,
    widows      : true,
    zIndex      : true,
    zoom        : true
  },
  /**
   * Normalize float css property.
   * Add in properties whose names you wish to fix before
   *   setting or getting the value.
   *
   * @private
   * @ignore
   */
  PropMaps : (function() {
    var maps = {}, p;
    maps.dir = {
      'float' : PotBrowser.msie ? 'styleFloat' : 'cssFloat'
    };
    maps.raw = {};
    for (p in maps.dir) {
      maps.raw[maps.dir[p]] = p;
    }
    maps.ref = {
      /**@ignore*/
      whiteSpace : function(elem, key, val) {
        if (/pre-?wrap/i.test(val)) {
          return {
            /**@ignore*/
            get : function() {
              return Pot.Style.getStyle(elem, key);
            },
            /**@ignore*/
            set : function() {
              return Pot.Style.setPreWrap(elem);
            }
          };
        } else {
          return {
            /**@ignore*/
            get : function() {
              return Pot.Style.getStyle(elem, key);
            },
            /**@ignore*/
            set : function() {
              return Pot.Style.setStyle(elem, key, val);
            }
          };
        }
      },
      /**@ignore*/
      opacity : function(elem, key, val) {
        return {
          /**@ignore*/
          get : function() {
            return Pot.Style.getOpacity(elem, key);
          },
          /**@ignore*/
          set : function() {
            return Pot.Style.setOpacity(elem, val);
          }
        }
      }
    };
    return maps;
  }()),
  /**
   * @lends Pot.Style
   */
  /**
   * Get or set the element's style.
   *
   *
   * @param  {Element}        elem  The target element node.
   * @param  {String|Object}  name  Get the style if you pass a string.
   *                                Set each styles if you pass an object.
   * @param  {String|*}             The value to set.
   * @return {*}                    Return the obtained style value,
   *                                  or if you set the value then
   *                                  will return the element.
   * @type   Function
   * @function
   * @static
   * @public
   */
  css : function(elem, name, value) {
    var result, args = arguments;
    each(arrayize(elem), function(el) {
      if (isElement(el) && name != null) {
        switch (args.length) {
          case 0:
          case 1:
              break;
          case 2:
              if (isObject(name)) {
                result = Pot.Style.setStyle(el, name);
              } else {
                result = Pot.Style.getStyle(el, name);
              }
              break;
          default:
              result = Pot.Style.setStyle(el, name, value);
        }
      }
    });
    return result;
  },
  /**
   * Get the computed style value of a node.
   *
   * @param  {Element}  elem   Element to get style of.
   * @param  {String}   prop   Property to get (camel-case).
   * @return {String}          Style value.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getComputedStyle : function(elem, prop) {
    var result = '', doc, styles;
    doc = Pot.DOM.getOwnerDocument(elem);
    if (doc.defaultView && doc.defaultView.getComputedStyle) {
      styles = doc.defaultView.getComputedStyle(elem, null);
      if (styles) {
        result = styles[prop] || styles.getPropertyValue(prop) || '';
      }
    }
    return result;
  },
  /**
   * Gets the cascaded style value of a node, or null.
   *
   * @param  {Element}  elem   Element to get style of.
   * @param  {String}   style  Property to get (camel-case).
   * @return {String}          Style value.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getCascadedStyle : function(elem, style) {
    return (elem && elem.currentStyle) ?
      (elem.currentStyle[style] || '') : '';
  },
  /**
   * Get the style value.
   *
   * @param  {Element}  elem       Element to get style of.
   * @param  {String}   styleName  Property to get.
   * @return {String}              Style value.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getStyle : update(function(elem, styleName) {
    var result = '', me = Pot.Style.getStyle, style, camel, dir, raw, ref;
    dir = Pot.Style.PropMaps.dir;
    raw = Pot.Style.PropMaps.raw;
    ref = Pot.Style.PropMaps.ref;
    if (elem) {
      style = stringify(styleName);
      camel = Pot.Text.camelize(style);
      if (camel in ref) {
        result = ref[camel](elem, style).get();
      } else {
        result = me.find(elem, style) ||
          (style in dir && me.find(elem, dir[style])) ||
          (style in raw && me.find(elem, raw[style])) || '';
      }
    }
    return result;
  }, {
    /**@ignore*/
    find : function(elem, style) {
      var c, camel;
      c = (~style.indexOf('-'));
      camel = c ? Pot.Text.camelize(style) : style;
      return Pot.Style.getComputedStyle(elem, style)  || (c &&
             Pot.Style.getComputedStyle(elem, camel)) ||
             Pot.Style.getCascadedStyle(elem, style)  || (c &&
             Pot.Style.getCascadedStyle(elem, camel)) ||
             elem.style[camel] || '';
    }
  }),
  /**
   * Set the style value.
   *
   * @param  {Element}         elem    Element to set style of.
   * @param  {String|Object}   name    Style name string or
   *                                     key-value object.
   * @param  {String|*}       (value)  Style value.
   * @return {Boolean}                 Success or failure.
   * @type   Function
   * @function
   * @static
   * @public
   */
  setStyle : function(elem, name, value) {
    var result = false, args = arguments, styles = {}, dir, ref;
    switch (args.length) {
      case 0:
      case 1:
          return false;
      case 2:
          if (isObject(name)) {
            styles = name;
          } else {
            return false;
          }
          break;
      default:
          styles[stringify(name)] = value;
    }
    if (isElement(elem)) {
      dir = Pot.Style.PropMaps.dir;
      ref = Pot.Style.PropMaps.ref;
      each.quick(styles, function(v, k) {
        var key = stringify(k), val = v;
        if (~key.indexOf('-')) {
          key = Pot.Text.camelize(key);
        }
        if (key in dir) {
          key = dir[key];
        }
        if ((isNumber(val) || !/[^\d.]/.test(val)) &&
            !(key in Pot.Style.NumberTypes)) {
          val = Pot.Style.pxize(val);
        }
        if (key in ref) {
          try {
            ref[key](elem, key, val).set();
            result = true;
            return;
          } catch (e) {}
        }
        try {
          elem.style[key] = val;
          result = true;
        } catch (e) {}
      });
    }
    return result;
  },
  /**
   * Gets the opacity of a node.
   *
   * @param  {Element}        el     Element whose opacity has to be found.
   * @return {Number|String}         Opacity between 0 and 1 or
   *                                   an empty string.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getOpacity : function(el) {
    var result, style, match, re;
    if (el) {
      style = el.style;
      if ('opacity' in style) {
        result = style.opacity - 0;
      } else if ('MozOpacity' in style) {
        result = style.MozOpacity - 0;
      } else if ('filter' in style) {
        re = /alpha\s*[(]\s*opacity\s*=\s*([\d.]+)\s*[)]/i;
        match = stringify(style.filter).match(re);
        if (match) {
          result = String(match[1] / 100) - 0;
        }
      }
    }
    return result;
  },
  /**
   * Sets the opacity of a node.
   *
   * @param  {Element}         el      Elements whose opacity has to be set.
   * @param  {Number|String}  alpha    Opacity between 0 and 1 or
   *                                     an empty string to clear the opacity.
   * @type   Function
   * @function
   * @static
   * @public
   */
  setOpacity : function(el, alpha) {
    var style;
    if (el) {
      style = el.style;
      if ('opacity' in style) {
        style.opacity = alpha;
      } else if ('MozOpacity' in style) {
        style.MozOpacity = alpha;
      } else if ('filter' in style) {
        if (isNumeric(alpha)) {
          style.filter = 'alpha(opacity=' + (alpha * 100) + ')';
        } else {
          style.filter = '';
        }
      }
    }
  },
  /**
   * Sets 'white-space: pre-wrap' for a node.
   *
   * There are as many ways of specifying pre-wrap as there are browsers.
   * <pre>
   * CSS3/IE8: white-space: pre-wrap;
   * Mozilla:  white-space: -moz-pre-wrap;
   * Opera:    white-space: -o-pre-wrap;
   * IE6/7:    white-space: pre; word-wrap: break-word;
   * </pre>
   *
   * @param  {Element}   el   Element to enable pre-wrap for.
   * @type   Function
   * @function
   * @static
   * @public
   */
  setPreWrap : function(el) {
    var style;
    if (el) {
      style = el.style;
      if (PotBrowser.msie &&
          Pot.Complex.compareVersions(PotBrowser.msie.version, '8', '<')
      ) {
        style.whiteSpace = 'pre';
        style.wordWrap   = 'break-word';
      } else if (PotBrowser.mozilla) {
        style.whiteSpace = '-moz-pre-wrap';
      } else {
        style.whiteSpace = 'pre-wrap';
      }
    }
  },
  /**
   * Check whether the element is shown.
   *
   *
   * @param  {Element}        elem  The target element node.
   * @return {*}                    Return whether the element is shown.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  isShown : function(elem) {
    return isElement(elem) &&
           Pot.Style.getStyle(elem, 'display') != 'none';
  },
  /**
   * Check whether the element is visible.
   *
   *
   * @param  {Element}        elem  The target element node.
   * @return {*}                    Return whether the element is visible.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  isVisible : function(elem) {
    return isElement(elem) &&
           Pot.Style.getStyle(elem, 'visibility') != 'hidden';
  },
  /**
   * Add 'px' suffix to integer value.
   *
   * @param  {String|Number}   value    The numeric value.
   * @param  {Boolean}         round    Whether to round the nearest integer.
   * @return {String}                   The string value for the property.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  pxize : function(value, round) {
    var n = (isNumeric(value) ? value : numeric(value)) - 0;
    if (round) {
      n = Math.round(n);
    }
    return n + 'px';
  },
  /**
   * Gets the height and width and position of an element.
   *
   * @param  {Element}    elem    Element to get width of.
   * @return {Object}             Object with
   *                                width/height/left/top properties.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getSizePos : function(elem) {
    var result, x, y, w, h, org, style;
    //XXX: Implements "Rect", "Box", "Coordinate" constructors.
    result = {
      left   : null,
      top    : null,
      width  : null,
      height : null
    };
    if (!elem || !isNodeLike(elem)) {
      return result;
    }
    style = elem.style;
    if (!Pot.Style.isShown(elem) ||
        ((elem.offsetParent == null ||
         (elem.offsetWidth  == 0 && elem.offsetHeight == 0)) &&
         Pot.DOM.tagNameOf(elem) !== 'body')
    ) {
      org = {
        display    : style.display,
        visibility : style.visibility,
        position   : style.position
      };
      style.visibility = 'hidden';
      style.position   = 'absolute';
      style.display    = 'inline';
    }
    x = elem.offsetLeft   || style.pixelLeft   || 0;
    y = elem.offsetTop    || style.pixelTop    || 0;
    w = elem.offsetWidth  || style.pixelWidth  || 0;
    h = elem.offsetHeight || style.pixelHeight || 0;
    if (org) {
      style.display    = org.display;
      style.position   = org.position;
      style.visibility = org.visibility;
    }
    result.left   = x - 0;
    result.top    = y - 0;
    result.width  = w - 0;
    result.height = h - 0;
    return result;
  },
  /**
   * Gets the height and width of an element.
   *
   * @param  {Element}   elem    Element to get width of.
   * @param  {Boolean}  (extra)  Whether include margin.
   * @return {Object}            Object with width/height properties.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  getPixelSize : function(elem, extra) {
    var result = {}, maps;
    result.width  = null;
    result.height = null;
    if (isElement(elem)) {
      maps = {
        Width : {
          Left  : 1,
          Right : 1
        },
        Height : {
          Top    : 1,
          Bottom : 1
        }
      };
      each(maps, function(map, key) {
        var value = elem['offset' + key];
        if (value > 0) {
          each(map, function(n, ax) {
            if (!extra) {
              value -= parseFloat(
                Pot.Style.getStyle(elem, 'padding' + ax)
              ) || 0;
            }
            if (extra) {
              value += parseFloat(
                Pot.Style.getStyle(elem, 'margin' + ax)
              ) || 0;
            } else {
              value -= parseFloat(
                Pot.Style.getStyle(elem, 'border' + ax + 'Width')
              ) || 0;
            }
          });
        } else {
          // Fall back to computed then uncomputed css if necessary
          value = Pot.Style.getStyle(elem, key);
          if (value < 0 || value == null) {
            value = elem.style[key] || 0;
          }
          value = parseFloat(value) || 0;
          if (extra) {
            each(map, function(n, ax) {
              value += parseFloat(
                Pot.Style.getStyle(elem, 'padding' + ax)
              ) || 0;
              value += parseFloat(
                Pot.Style.getStyle(elem, 'margin' + ax)
              ) || 0;
            });
          }
        }
        result[Pot.Text.lower(key)] = Pot.Style.pxize(value);
      });
    }
    return result;
  },
  /**
   * Sets the width and height to the element.
   *
   * @param  {Element}    elem    Element to get width of.
   * @param  {Number}     width   Specify width.
   * @param  {Number}     height  Specify height.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  setSize : function(elem, width, height) {
    var size = {};
    if (isObject(width)) {
      size = width;
    } else {
      size.width  = width;
      size.height = height;
    }
    Pot.Style.setWidth(elem, size.width);
    Pot.Style.setHeight(elem, size.height);
  },
  /**
   * Gets the width to the element.
   *
   * @param  {Element}    elem    Element to get width of.
   * @return {Number}             Object width.
   * @type   Function
   * @function
   * @static
   * @public
   */
  getWidth : function(elem, extra) {
    var size = Pot.Style.getPixelSize(elem, extra);
    return size.width;
  },
  /**
   * Gets the width to the element.
   *
   * @param  {Element}    elem    Element to get width of.
   * @param  {Number}     height  Specify width.
   * @return {Number}             Object width.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  getHeight : function(elem, extra) {
    var size = Pot.Style.getPixelSize(elem, extra);
    return size.height;
  },
  /**
   * Sets the width to the element.
   *
   * @param  {Element}    elem    Element to get width of.
   * @param  {Number}     width   Specify width.
   * @return {Number}             Object width.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  setWidth : function(elem, width) {
    if (elem) {
      Pot.Style.setStyle(elem, {
        width : width
      });
    }
  },
  /**
   * Sets the height to the element.
   *
   * @param  {Element}    elem    Element to get height of.
   * @param  {Number}     width   Specify height.
   * @return {Number}             Object height.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  setHeight : function(elem, height) {
    if (elem) {
      Pot.Style.setStyle(elem, {
        height : height
      });
    }
  },
  /**
   * Gets the resize size.
   *
   * @param  {Number} orgWidth    Original width.
   * @param  {Number} orgHeight   Original height.
   * @param  {Number} maxWidth    Maximum width.
   * @param  {(Number)} (maxHeight)   (Optional) Maximum height.
   *
   * @type   Function
   * @function
   * @static
   * @public
   */
  getResizeSize : function(orgWidth, orgHeight, maxWidth, maxHeight) {
    var result, percent, ratioX, ratioY;
    if (maxHeight == null) {
      maxHeight = maxWidth;
      if (orgHeight > maxHeight) {
        percent = maxHeight / orgHeight * 100;
      } else {
        percent = 100;
      }
    } else if (maxWidth == null) {
      maxWidth = maxHeight;
      if (orgWidth > maxWidth) {
        percent = maxWidth / orgWidth * 100;
      } else {
        percent = 100;
      }
    } else {
      if (orgWidth > maxWidth) {
        ratioX = maxWidth / orgWidth * 100;
      } else {
        ratioX = 100;
      }
      if (orgHeight > maxHeight) {
        ratioY = maxHeight / orgHeight * 100;
      } else {
        ratioY = 100;
      }
      if (ratioX < ratioY) {
        percent = ratioX;
      } else if (ratioX > ratioY) {
        percent = ratioY;
      } else {
        percent = 0;
      }
    }
    if (percent === 0) {
      result = {
        width  : maxWidth,
        height : maxHeight
      };
    } else {
      result = {
        width  : Math.round(orgWidth  * percent / 100),
        height : Math.round(orgHeight * percent / 100)
      };
    }
    return result;
  }
});

// Update Pot object.
Pot.update({
  css           : Pot.Style.css,
  getStyle      : Pot.Style.getStyle,
  setStyle      : Pot.Style.setStyle,
  isShown       : Pot.Style.isShown,
  isVisible     : Pot.Style.isVisible,
  pxize         : Pot.Style.pxize,
  getSizePos    : Pot.Style.getSizePos,
  getPixelSize  : Pot.Style.getPixelSize,
  setSize       : Pot.Style.setSize,
  getWidth      : Pot.Style.getWidth,
  setWidth      : Pot.Style.setWidth,
  getHeight     : Pot.Style.getHeight,
  setHeight     : Pot.Style.setHeight,
  getResizeSize : Pot.Style.getResizeSize
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of Debug.
Pot.update({
  /**
   * @lends Pot.Debug
   */
  /**
   * Debugging utilities.
   *
   * @name Pot.Debug
   * @type Object
   * @class
   * @static
   * @public
   */
  Debug : {}
});

update(Pot.Debug, {
  /**
   * @lends Pot.Debug
   */
  /**
   * Output to the console using log function for debug.
   *
   *
   * @example
   *   debug('hoge'); // hoge
   *
   *
   * @param  {*}  msg  A log message, or variable.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  debug : debug,
  /**
   * Output to the console using 'error' function for error logging.
   *
   *
   * @example
   *   Pot.error('Error!'); // Error!
   *
   *
   * @param  {*}  msg  An error message, or variable.
   * @type Function
   * @function
   * @public
   * @static
   */
  error : error,
  /**
   * Dump and returns all of object as string.
   *
   *
   * @example
   *   var reg = /^[a-z]+$/g;
   *   var err = new Error('error!');
   *   var str = new String('hello');
   *   var arr = [1, 2, 3, {a: 4, b: 5, c: true}, false, null, void 0];
   *   var obj = {
   *     key1 : 'val1',
   *     key2 : 'val2',
   *     arr  : arr,
   *     arr2 : arr,
   *     strs : [str, str],
   *     err  : err,
   *     err2 : err,
   *     reg1 : reg,
   *     reg2 : reg,
   *     reg3 : reg
   *   };
   *   obj.obj = obj;
   *   Pot.debug( Pot.dump(obj) );
   *   // @results
   *   //   #0 {
   *   //     key1: "val1",
   *   //     key2: "val2",
   *   //     arr: #3 [
   *   //       1,
   *   //       2,
   *   //       3,
   *   //       {
   *   //         a: 4,
   *   //         b: 5,
   *   //         c: true
   *   //       },
   *   //       false,
   *   //       null,
   *   //       undefined
   *   //     ],
   *   //     arr2: #3,
   *   //     strs: [
   *   //       #5 (new String("hello")),
   *   //       #5
   *   //     ],
   *   //     err: #6 (new Error("error!")),
   *   //     err2: #6,
   *   //     reg1: #8 (new RegExp(/^[a-z]+$/g)),
   *   //     reg2: #8,
   *   //     reg3: #8,
   *   //     obj: #0
   *   //   }
   *
   *
   * @param  {*}  val  A target object/value.
   * @param  {(Number)} (recursiveLimit) (Optional) recursive limit.
   *                                     (default = 16)
   * @param  {(Number)} (lengthLimit) (Optional) length limit.
   *                                     (default = 1024)
   * @return {String} dumped string.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  dump : (function() {
    /**@ignore*/
    var Dumper = function() {
      return this.init.apply(this, arguments);
    };
    Dumper.prototype = {
      /**@ignore*/
      data : null,
      /**@ignore*/
      refs : null,
      /**@ignore*/
      first : true,
      /**@ignore*/
      recursiveLimit : 16,
      /**@ignore*/
      lengthLimit : 1024,
      /**@ignore*/
      isStop : false,
      /**@ignore*/
      init : function(recursiveLimit, lengthLimit) {
        this.data = [];
        this.refs = [];
        if (isNumeric(recursiveLimit)) {
          this.recursiveLimit = recursiveLimit - 0;
        }
        if (isNumeric(lengthLimit)) {
          this.lengthLimit = lengthLimit - 0;
        }
        return this;
      },
      /**@ignore*/
      typeOf : function(v) {
        return (v === null) ? 'null' : typeof v;
      },
      /**@ignore*/
      add : function(value, object, isRef, isNull) {
        this.refs[this.refs.length] = isNull ? null : object;
        this.data[this.data.length] = [value, isRef];
      },
      /**@ignore*/
      getReferenceNumber : function(object) {
        var i = 0, len = this.refs.length;
        for (; i < len; i++) {
          if (this.refs[i] === object) {
            if (i === 0 && this.first) {
              this.first = false;
              continue;
            }
            if (this.data[i] && !this.data[i][1]) {
              this.data[i][1] = true;
              this.data[i][2] = '#' + i + ' ';
            }
            return i;
          }
        }
        return false;
      },
      /**@ignore*/
      dump : function(object) {
        var r = [], i = 0, len, recursiveCount = 0;
        this.add('', object);
        try {
          this.dumpAll(object, recursiveCount);
        } catch (e) {
          return Pot.getErrorMessage(e);
        }
        len = this.data.length;
        for (; i < len; i++) {
          r[r.length] = (this.data[i][2] || '') + this.data[i][0];
        }
        this.data = this.refs = [];
        return r.join('');
      },
      /**@ignore*/
      dumpAll : function(object, recursiveCount) {
        if (this.lengthLimit >= 0 &&
            this.data.length > this.lengthLimit) {
          this.add('\n...\n', object);
          this.isStop = true;
          return;
        }
        if (this.recursiveLimit >= 0 &&
            recursiveCount > this.recursiveLimit) {
          this.add('[RECURSIVE LIMIT]', object);
          return;
        }
        switch (this.typeOf(object)) {
          case 'null':
              this.add('null', object);
              break;
          case 'string':
              this.add('"' + object + '"', object);
              break;
          case 'number':
          case 'boolean':
          case 'xml':
              this.add(object.toString(), object);
              break;
          case 'function':
              this.dumpFunction(object);
              break;
          case 'object':
              this.dumpObject(object, recursiveCount);
              break;
          default:
              this.add('undefined', object);
        }
      },
      /**@ignore*/
      dumpFunction : function(object) {
        var n = this.getReferenceNumber(object);
        if (n !== false) {
          this.add('#' + n, object, true);
        } else {
          this.add(Pot.getFunctionCode(object), object);
        }
      },
      /**@ignore*/
      dumpObject : function(object, recursiveCount) {
        var that = this, rs, rv, p, k, keys, val, index, wrap, n;
        n = this.getReferenceNumber(object);
        if (n !== false) {
          this.add('#' + n, object, true, true);
        } else if (isString(object)) {
          this.add('(new String("' + object + '"))', object);
        } else if (isNumber(object)) {
          this.add('(new Number(' + object + '))', object);
        } else if (isBoolean(object)) {
          this.add('(new Boolean(' + object.toString() + '))', object);
        } else if (isRegExp(object)) {
          this.add('(new RegExp(' + object.toString() + '))', object);
        } else if (isError(object)) {
          this.add(
            '(new ' + (object.name || 'Error') +
            '("' + Pot.getErrorMessage(object) + '"))',
            object
          );
        } else if (isDate(object)) {
          this.add('(new Date("' + object.toString() + '"))', object);
        } else if (isFunction(object)) {
          this.add(Pot.getFunctionCode(object), object);
        } else {
          index = this.data.length;
          if (isArray(object)) {
            wrap = ['[', ']'];
            each(object, function(v) {
              that.dumpAll(v, recursiveCount + 1);
              if (that.isStop) {
                throw PotStopIteration;
              }
            });
          } else {
            wrap = ['{', '}'];
            k = ': ';
            keys = [];
            for (p in object) {
              keys[keys.length] = p;
            }
            each(keys, function(p) {
              try {
                val = object[p];
              } catch (e) {
                return;
              }
              that.dumpAll(val, recursiveCount + 1);
              if (that.isStop) {
                throw PotStopIteration;
              }
            });
          }
          this.refs.splice(index, this.refs.length);
          rs = this.data.splice(index, this.data.length);
          rv = [];
          each(rs, function(r, i) {
            rv[rv.length] = (k ? keys[i] + k : '') +
                            (r[2] || '') +
                            r[0];
          });
          this.add(wrap[0] + rv.join(', ') + wrap[1], object);
        }
      }
    };
    return function(val, recursiveLimit, lengthLimit) {
      return new Dumper(recursiveLimit, lengthLimit).dump(val);
    };
  }())
});

// Update Pot object.
Pot.update({
  debug : Pot.Debug.debug,
  dump  : Pot.Debug.dump
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of jQuery plugin and convert Ajax function to deferred.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Definition of jQuery plugin and convert Ajax function to deferred.
   *
   * <pre>
   *   - $.pot
   *       {Object}    Pot object.
   *
   *   - $.fn.deferred
   *       {Function}  Deferrize jQuery method.
   *                     function(method, (original arguments))
   *                       - method :
   *                           {String} method name.
   *                       - (...)  :
   *                           {*}      original arguments.
   *  </pre>
   *
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  deferrizejQueryAjax : (function() {
    return function() {
      if (typeof jQuery !== 'function' || !jQuery.fn) {
        return false;
      }
      return (function($) {
        var orgAjax = $.ajax;
        $.pot = Pot;
        $.fn.extend({
          /**@ignore*/
          deferred : function(method) {
            var func, args = arrayize(arguments, 1), exists = false;
            each(args, function(arg) {
              if (isFunction(arg)) {
                exists = true;
                throw PotStopIteration;
              }
            });
            if (!exists) {
              args.push(function() {
                return arrayize(arguments);
              });
            }
            func = Deferred.deferrize(method, this);
            return func.apply(this, args);
          }
        });
        /**@ignore*/
        $.ajax = function(options) {
          var er, d = new Deferred(),
              opts = update({}, options || {}),
              orgs = update({}, opts);
          update(opts, {
            /**@ignore*/
            success : function() {
              var args = arrayize(arguments), err, done;
              try {
                if (orgs.success) {
                  orgs.success.apply(this, args);
                }
              } catch (e) {
                done = true;
                err = e || new Error(e);
                args.push(err);
                d.raise.apply(d, args);
              }
              if (!done) {
                d.destAssign = true;
                d.begin.apply(d, args);
              }
            },
            /**@ignore*/
            error : function() {
              var args = arrayize(arguments), err;
              try {
                if (orgs.error) {
                  orgs.error.apply(this, args);
                }
              } catch (e) {
                err = e || new Error(e);
                args.unshift(err);
              } finally {
                d.raise.apply(d, args);
              }
            }
          });
          try {
            d.data({
              result : orgAjax(opts)
            });
          } catch (e) {
            er = e;
            d.raise(er);
          }
          return d;
        };
      }(jQuery));
    };
  }())
});

// Update Pot.Plugin object methods.
update(PotPlugin, {
  /**
   * @lends Pot.Plugin
   */
  /**
   * @private
   * @ignore
   */
  storage : {},
  /**
   * @private
   * @ignore
   */
  shelter : {},
  /**
   * Add plugin function.
   *
   *
   * @example
   *   Pot.addPlugin('foo', function() { alert('foo!') });
   *   Pot.foo(); // 'foo!'
   *
   *
   * @param  {String|Object}  name     A name of Plugin function. or object.
   * @param  {Function}      (method)  A plugin function.
   * @param  {Boolean}       (force)   Whether overwrite plugin.
   *                                     (default=false).
   * @return {Boolean}                 Return success or failure.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  add : function(name, method, force) {
    var result = true, pairs, overwrite;
    if (isObject(name)) {
      pairs = name;
      overwrite = !!(force || method);
    } else {
      pairs = {};
      pairs[stringify(name, true)] = method;
      overwrite = !!force;
    }
    each(pairs, function(v, k) {
      var key = stringify(k, true), func;
      if (isFunction(v)) {
        /**@ignore*/
        func = function() {
          return v.apply(v, arguments);
        };
        update(func, {
          deferred : (function() {
            try {
              return Deferred.deferreed(func);
            } catch (e) {
              return Deferred.deferrize(func);
            }
          }())
        });
      } else {
        func = v;
      }
      if (key && (overwrite || !PotPlugin.has(key))) {
        if (key in Pot) {
          PotPlugin.shelter[key] = Pot[key];
        }
        Pot[key] = PotPlugin.storage[key] =
                   PotInternal.PotExportProps[key] = func;
      } else {
        result = false;
      }
    });
    return result;
  },
  /**
   * Check whether Pot.Plugin has already specific name.
   *
   *
   * @example
   *   debug( Pot.hasPlugin('hoge') ); // false
   *   Pot.addPlugin('hoge', function() {});
   *   debug( Pot.hasPlugin('hoge') ); // true
   *
   *
   * @param  {String|Array}  name   A name of Plugin function. or Array.
   * @return {Boolean}              Returns whether Pot.Plugin has
   *                                  already specific name.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  has : function(name) {
    var result = true;
    each(arrayize(name), function(k) {
      var key = stringify(k, true);
      if (!(key in PotPlugin.storage)) {
        result = false;
        throw PotStopIteration;
      }
    });
    return result;
  },
  /**
   * Removes Pot.Plugin's function.
   *
   *
   * @example
   *   Pot.addPlugin('hoge', function() {});
   *   debug( Pot.removePlugin('hoge') ); // true
   *   Pot.hoge(); // (Error: hoge is undefined)
   *
   *
   * @param  {String|Array}  name   A name of Plugin function. or Array.
   * @return {Boolean}              Returns success or failure.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  remove : function(name) {
    var result = true;
    each(arrayize(name), function(k) {
      var key = stringify(k, true);
      if (PotPlugin.has(key)) {
        try {
          if (key in PotPlugin.shelter) {
            Pot[key] = PotInternal.PotExportProps[key] =
                                        PotPlugin.shelter[key];
            delete PotPlugin.shelter[key];
          } else {
            if (key in Pot) {
              delete Pot[key];
            }
            if (key in PotInternal.PotExportProps) {
              delete PotInternal.PotExportProps[key];
            }
          }
          delete PotPlugin.storage[key];
          if (PotPlugin.has(key)) {
            throw false;
          }
        } catch (e) {
          result = false;
        }
      }
    });
    return result;
  },
  /**
   * List the Pot.Plugin function names.
   *
   *
   * @example
   *   Pot.addPlugin('foo', function() { alert('foo!') });
   *   Pot.addPlugin('bar', function() { alert('bar!') });
   *   debug( Pot.listPlugin() ); // ['foo', 'bar']
   *
   *
   * @return {Array} Returns an array of function names.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  list : function() {
    var result = Pot.keys(PotPlugin.storage);
    return result;
  }
});

// Update Pot object.
Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Add plugin function.
   *
   *
   * @example
   *   Pot.addPlugin('foo', function() { alert('foo!') });
   *   Pot.foo(); // 'foo!'
   *
   *
   * @param  {String|Object}  name     A name of Plugin function. or object.
   * @param  {Function}      (method)  A plugin function.
   * @param  {Boolean}       (force)   Whether overwrite plugin.
   *                                     (default=false).
   * @return {Boolean}                 Return success or failure.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  addPlugin : PotPlugin.add,
  /**
   * Check whether Pot.Plugin has already specific name.
   *
   *
   * @example
   *   debug( Pot.hasPlugin('hoge') ); // false
   *   Pot.addPlugin('hoge', function() {});
   *   debug( Pot.hasPlugin('hoge') ); // true
   *
   *
   * @param  {String|Array}  name   A name of Plugin function. or Array.
   * @return {Boolean}              Returns whether Pot.Plugin has
   *                                  already specific name.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  hasPlugin : PotPlugin.has,
  /**
   * Removes Pot.Plugin's function.
   *
   *
   * @example
   *   Pot.addPlugin('hoge', function() {});
   *   debug( Pot.removePlugin('hoge') ); // true
   *   Pot.hoge(); // (Error: hoge is undefined)
   *
   *
   * @param  {String|Array}  name   A name of Plugin function. or Array.
   * @return {Boolean}              Returns success or failure.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  removePlugin : PotPlugin.remove,
  /**
   * List the Pot.Plugin function names.
   *
   *
   * @example
   *   Pot.addPlugin('foo', function() { alert('foo!') });
   *   Pot.addPlugin('bar', function() { alert('bar!') });
   *   debug( Pot.listPlugin() ); // ['foo', 'bar']
   *
   *
   * @return {Array} Returns an array of function names.
   *
   * @type Function
   * @function
   * @public
   * @static
   */
  listPlugin : PotPlugin.list
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Definition of globalize method.

Pot.update({
  /**
   * @lends Pot
   */
  /**
   * Globalizes the Pot object properties.
   *
   *
   * @example
   *   var obj = {
   *     foo : function() { return 'foo'; },
   *     bar : function() { return 'bar'; }
   *   };
   *   globalize(obj);
   *   // e.g.,
   *   debug(window.foo()); // 'foo'
   *   debug(bar());        // 'bar'
   *
   *
   * @example
   *   var result, obj = [1, 2, 3];
   *   //
   *   // Test for before globalization.
   *   try {
   *     result = succeed(obj);
   *   } catch (e) {
   *     // Will be Error: ReferenceError: unique is not defined.
   *     // Call by method to see a long object name from Pot.
   *     result = Pot.Deferred.succeed(obj);
   *     result.map(function(val) {
   *       return val + 100;
   *     }).then(function(res) {
   *       debug(res);
   *       // @results  res = [101, 102, 103]
   *     });
   *   }
   *   //
   *   // Globalize the Pot object methods.
   *   //
   *   Pot.globalize();
   *   //
   *   // Then you can call the short method name easy.
   *   var s = '';
   *   forEach(range('A', 'C'), function(val, key) {
   *     s += val + key;
   *   });
   *   debug(s);
   *   // @results 'A0B0C0'
   *
   *
   * @param  {Object}   (target)    A target object to globalize.
   * @param  {Boolean}  (advised)   (Optional) Whether to not overwrite the
   *                                  global object property names 
   *                                  if a conflict with the Pot object
   *                                  property name.
   * @return {Array}                The property name(s) that not defined by
   *                                  conflict as an array.
   * @type  Function
   * @function
   * @static
   * @public
   */
  globalize : function(target, advised) {
    var result = false, args = arrayize(arguments),
        inputs, outputs, len = args.length, noops = [];
    if (len <= 1 && this === Pot && !isObject(target)) {
      inputs = this;
      if (len >= 1 && isBoolean(target)) {
        advised = target;
      } else {
        advised = !!target;
      }
    } else if (target && (isObject(target) ||
               isFunction(target) || isArray(target))) {
      inputs = target;
    }
    outputs = PotInternal.getExportObject(true);
    if (inputs && outputs) {
      if (inputs === Pot) {
        if (PotInternal.exportPot && PotInternal.PotExportProps) {
          result = PotInternal.exportPot(advised, true, true);
        }
      } else {
        each(inputs, function(prop, name) {
          if (advised && name in outputs) {
            noops[noops.length] = name;
          } else {
            outputs[name] = prop;
          }
        });
        result = noops;
      }
    }
    return result;
  }
});

// Define the export method.
update(PotInternal, {
  /**
   * @lends Pot.Internal
   */
  /**
   * Export the Pot properties.
   *
   * @private
   * @ignore
   * @internal
   */
  exportPot : function(advised, forGlobalScope, allProps, initialize) {
    var outputs, noops = [];
    outputs = PotInternal.getExportObject(forGlobalScope);
    if (outputs) {
      if (allProps) {
        each(PotInternal.PotExportProps, function(prop, name) {
          if (advised && name in outputs) {
            noops[noops.length] = name;
          } else {
            outputs[name] = prop;
          }
        });
      } else {
        each(PotInternal.PotExportObject, function(prop, name) {
          if (advised && name in outputs) {
            noops[noops.length] = name;
          } else {
            outputs[name] = prop;
          }
        });
      }
    }
    if (initialize) {
      outputs = PotInternal.getExportObject(
        PotSystem.isNodeJS ? false : true
      );
      if (outputs) {
        update(outputs, PotInternal.PotExportObject);
      }
      // for Node.js and CommonJS.
      if ((PotSystem.isNonBrowser ||
           !PotSystem.isNotExtension) && typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
          exports = module.exports = Pot;
        }
        exports.Pot = Pot;
      } else if (typeof define === 'function' && define.amd) {
        // for AMD.
        define('pot', function() {
          return Pot;
        });
      }
      if (outputs && !outputs.Pot) {
        outputs['Pot'] = Pot;
      }
    }
    return noops;
  },
  /**
   * The object to export.
   *
   * @private
   * @ignore
   * @internal
   */
  PotExportObject : {
    Pot : Pot
  },
  /**
   * The properties to export.
   *
   * @private
   * @ignore
   * @internal
   */
  PotExportProps : {
    Pot                      : Pot,
    update                   : update,
    PATH_DELIMITER           : Pot.PATH_DELIMITER,
    DIR_DELIMITER            : Pot.DIR_DELIMITER,
    XML_NS_URI               : Pot.XML_NS_URI,
    HTML_NS_URI              : Pot.HTML_NS_URI,
    XHTML_NS_URI             : Pot.XHTML_NS_URI,
    XLINK_NS_URI             : Pot.XLINK_NS_URI,
    XSL_NS_URI               : Pot.XSL_NS_URI,
    SVG_NS_URI               : Pot.SVG_NS_URI,
    XUL_NS_URI               : Pot.XUL_NS_URI,
    JS_VOID_URI              : Pot.JS_VOID_URI,
    isBoolean                : Pot.isBoolean,
    isNumber                 : Pot.isNumber,
    isString                 : Pot.isString,
    isFunction               : Pot.isFunction,
    isArray                  : Pot.isArray,
    isDate                   : Pot.isDate,
    isRegExp                 : Pot.isRegExp,
    isObject                 : Pot.isObject,
    isError                  : Pot.isError,
    typeOf                   : Pot.typeOf,
    typeLikeOf               : Pot.typeLikeOf,
    StopIteration            : Pot.StopIteration,
    isStopIter               : Pot.isStopIter,
    isIterable               : Pot.isIterable,
    isScalar                 : Pot.isScalar,
    isBlob                   : Pot.isBlob,
    isFileReader             : Pot.isFileReader,
    isImage                  : Pot.isImage,
    isArguments              : Pot.isArguments,
    isTypedArray             : Pot.isTypedArray,
    isArrayBuffer            : Pot.isArrayBuffer,
    isArrayLike              : Pot.isArrayLike,
    isPlainObject            : Pot.isPlainObject,
    isEmpty                  : Pot.isEmpty,
    isDeferred               : Pot.isDeferred,
    isIter                   : Pot.isIter,
    isWorkeroid              : Pot.isWorkeroid,
    isArrayBufferoid         : Pot.isArrayBufferoid,
    isHash                   : Pot.isHash,
    isJSEscaped              : Pot.isJSEscaped,
    isPercentEncoded         : Pot.isPercentEncoded,
    isHTMLEscaped            : Pot.isHTMLEscaped,
    isNumeric                : Pot.isNumeric,
    isInt                    : Pot.isInt,
    isNativeCode             : Pot.isNativeCode,
    isBuiltinMethod          : Pot.isBuiltinMethod,
    isWindow                 : Pot.isWindow,
    isDocument               : Pot.isDocument,
    isElement                : Pot.isElement,
    isNodeLike               : Pot.isNodeLike,
    isNodeList               : Pot.isNodeList,
    isDOMLike                : Pot.isDOMLike,
    Cc                       : Pot.Cc,
    Ci                       : Pot.Ci,
    Cr                       : Pot.Cr,
    Cu                       : Pot.Cu,
    Deferred                 : Pot.Deferred,
    succeed                  : Pot.Deferred.succeed,
    failure                  : Pot.Deferred.failure,
    wait                     : Pot.Deferred.wait,
    callLater                : Pot.Deferred.callLater,
    callLazy                 : Pot.Deferred.callLazy,
    maybeDeferred            : Pot.Deferred.maybeDeferred,
    isFired                  : Pot.Deferred.isFired,
    lastResult               : Pot.Deferred.lastResult,
    lastError                : Pot.Deferred.lastError,
    register                 : Pot.Deferred.register,
    unregister               : Pot.Deferred.unregister,
    deferrize                : Pot.Deferred.deferrize,
    deferreed                : Pot.Deferred.deferreed,
    begin                    : Pot.Deferred.begin,
    flush                    : Pot.Deferred.flush,
    till                     : Pot.Deferred.till,
    parallel                 : Pot.Deferred.parallel,
    chain                    : Pot.Deferred.chain,
    forEach                  : Pot.forEach,
    repeat                   : Pot.repeat,
    forEver                  : Pot.forEver,
    iterate                  : Pot.iterate,
    items                    : Pot.items,
    zip                      : Pot.zip,
    Iter                     : Pot.Iter,
    toIter                   : Pot.Iter.toIter,
    map                      : Pot.map,
    filter                   : Pot.filter,
    reduce                   : Pot.reduce,
    every                    : Pot.every,
    some                     : Pot.some,
    range                    : Pot.range,
    indexOf                  : Pot.indexOf,
    lastIndexOf              : Pot.lastIndexOf,
    globalEval               : Pot.globalEval,
    localEval                : Pot.localEval,
    tokenize                 : Pot.tokenize,
    joinTokens               : Pot.joinTokens,
    isWords                  : Pot.isWords,
    isNL                     : Pot.isNL,
    hasReturn                : Pot.hasReturn,
    override                 : Pot.override,
    createBlob               : Pot.createBlob,
    createConstructor        : Pot.createConstructor,
    getErrorMessage          : Pot.getErrorMessage,
    getFunctionCode          : Pot.getFunctionCode,
    currentWindow            : Pot.currentWindow,
    currentDocument          : Pot.currentDocument,
    currentURI               : Pot.currentURI,
    serializeToJSON          : Pot.Serializer.serializeToJSON,
    parseFromJSON            : Pot.Serializer.parseFromJSON,
    serializeToQueryString   : Pot.Serializer.serializeToQueryString,
    parseFromQueryString     : Pot.Serializer.parseFromQueryString,
    urlEncode                : Pot.URI.urlEncode,
    urlDecode                : Pot.URI.urlDecode,
    parseURI                 : Pot.URI.parseURI,
    buildURI                 : Pot.URI.buildURI,
    resolveRelativeURI       : Pot.URI.resolveRelativeURI,
    getExt                   : Pot.URI.getExt,
    toDataURI                : Pot.URI.toDataURI,
    request                  : Pot.Net.request,
    jsonp                    : Pot.Net.requestByJSONP,
    getJSON                  : Pot.Net.getJSON,
    loadScript               : Pot.Net.loadScript,
    hashCode                 : Pot.Crypt.hashCode,
    md5                      : Pot.Crypt.md5,
    crc32                    : Pot.Crypt.crc32,
    sha1                     : Pot.Crypt.sha1,
    Arc4                     : Pot.Crypt.Arc4,
    evalInSandbox            : Pot.XPCOM.evalInSandbox,
    throughout               : Pot.XPCOM.throughout,
    getMostRecentWindow      : Pot.XPCOM.getMostRecentWindow,
    getChromeWindow          : Pot.XPCOM.getChromeWindow,
    ArrayBufferoid           : Pot.ArrayBufferoid,
    Workeroid                : Pot.Workeroid,
    attach                   : Pot.Signal.attach,
    attachBefore             : Pot.Signal.attachBefore,
    attachAfter              : Pot.Signal.attachAfter,
    attachPropBefore         : Pot.Signal.attachPropBefore,
    attachPropAfter          : Pot.Signal.attachPropAfter,
    detach                   : Pot.Signal.detach,
    detachAll                : Pot.Signal.detachAll,
    signal                   : Pot.Signal.signal,
    cancelEvent              : Pot.Signal.cancelEvent,
    DropFile                 : Pot.Signal.DropFile,
    Hash                     : Pot.Hash,
    merge                    : Pot.Collection.merge,
    unique                   : Pot.Collection.unique,
    flatten                  : Pot.Collection.flatten,
    alphanumSort             : Pot.Collection.alphanumSort,
    clone                    : Pot.Struct.clone,
    bind                     : Pot.Struct.bind,
    partial                  : Pot.Struct.partial,
    keys                     : Pot.Struct.keys,
    values                   : Pot.Struct.values,
    tuple                    : Pot.Struct.tuple,
    unzip                    : Pot.Struct.unzip,
    pairs                    : Pot.Struct.pairs,
    count                    : Pot.Struct.count,
    first                    : Pot.Struct.first,
    firstKey                 : Pot.Struct.firstKey,
    last                     : Pot.Struct.last,
    lastKey                  : Pot.Struct.lastKey,
    contains                 : Pot.Struct.contains,
    remove                   : Pot.Struct.remove,
    removeAll                : Pot.Struct.removeAll,
    removeAt                 : Pot.Struct.removeAt,
    equals                   : Pot.Struct.equals,
    reverse                  : Pot.Struct.reverse,
    flip                     : Pot.Struct.flip,
    shuffle                  : Pot.Struct.shuffle,
    fill                     : Pot.Struct.fill,
    implode                  : Pot.Struct.implode,
    explode                  : Pot.Struct.explode,
    glue                     : Pot.Struct.glue,
    clearObject              : Pot.Struct.clearObject,
    time                     : Pot.DateTime.time,
    date                     : Pot.DateTime.format,
    prettyDate               : Pot.DateTime.prettyDate,
    rand                     : Pot.Complex.rand,
    limit                    : Pot.Complex.limit,
    convertToBase            : Pot.Complex.convertToBase,
    compareVersions          : Pot.Complex.compareVersions,
    escapeRegExp             : Pot.Sanitizer.escapeRegExp,
    escapeHTML               : Pot.Sanitizer.escapeHTML,
    unescapeHTML             : Pot.Sanitizer.unescapeHTML,
    escapeXPathText          : Pot.Sanitizer.escapeXPathText,
    escapeAppleScriptString  : Pot.Sanitizer.escapeAppleScriptString,
    escapeString             : Pot.Sanitizer.escapeString,
    unescapeString           : Pot.Sanitizer.unescapeString,
    escapeFileName           : Pot.Sanitizer.escapeFileName,
    escapeSequence           : Pot.Sanitizer.escapeSequence,
    unescapeSequence         : Pot.Sanitizer.unescapeSequence,
    utf8Encode               : Pot.UTF8.encode,
    utf8Decode               : Pot.UTF8.decode,
    utf8ByteOf               : Pot.UTF8.byteOf,
    convertEncodingToUnicode : Pot.UTF8.convertEncodingToUnicode,
    base64Encode             : Pot.Base64.encode,
    base64Decode             : Pot.Base64.decode,
    base64URLEncode          : Pot.Base64.urlEncode,
    base64URLDecode          : Pot.Base64.urlDecode,
    alphamericStringEncode   : Pot.Archive.AlphamericString.encode,
    alphamericStringDecode   : Pot.Archive.AlphamericString.decode,
    sprintf                  : Pot.Format.sprintf,
    format                   : Pot.Format.format,
    getExtByMimeType         : Pot.MimeType.getExtByMimeType,
    getMimeTypeByExt         : Pot.MimeType.getMimeTypeByExt,
    ReplaceSaver             : Pot.Text.ReplaceSaver,
    chr                      : Pot.Text.chr,
    ord                      : Pot.Text.ord,
    ltrim                    : Pot.Text.ltrim,
    rtrim                    : Pot.Text.rtrim,
    strip                    : Pot.Text.strip,
    indent                   : Pot.Text.indent,
    unindent                 : Pot.Text.unindent,
    normalizeSpace           : Pot.Text.normalizeSpace,
    splitBySpace             : Pot.Text.splitBySpace,
    canonicalizeNL           : Pot.Text.canonicalizeNL,
    wrap                     : Pot.Text.wrap,
    unwrap                   : Pot.Text.unwrap,
    startsWith               : Pot.Text.startsWith,
    endsWith                 : Pot.Text.endsWith,
    lower                    : Pot.Text.lower,
    upper                    : Pot.Text.upper,
    camelize                 : Pot.Text.camelize,
    hyphenize                : Pot.Text.hyphenize,
    underscore               : Pot.Text.underscore,
    extract                  : Pot.Text.extract,
    inc                      : Pot.Text.inc,
    dec                      : Pot.Text.dec,
    br                       : Pot.Text.br,
    stripTags                : Pot.Text.stripTags,
    truncate                 : Pot.Text.truncate,
    truncateMiddle           : Pot.Text.truncateMiddle,
    toCharCode               : Pot.Text.toCharCode,
    toHankakuCase            : Pot.Text.toHankakuCase,
    toZenkakuCase            : Pot.Text.toZenkakuCase,
    toHanSpaceCase           : Pot.Text.toHanSpaceCase,
    toZenSpaceCase           : Pot.Text.toZenSpaceCase,
    toHiraganaCase           : Pot.Text.toHiraganaCase,
    toKatakanaCase           : Pot.Text.toKatakanaCase,
    toHankanaCase            : Pot.Text.toHankanaCase,
    toZenkanaCase            : Pot.Text.toZenkanaCase,
    detectWindow             : Pot.DOM.detectWindow,
    detectDocument           : Pot.DOM.detectDocument,
    getOwnerDocument         : Pot.DOM.getOwnerDocument,
    getElement               : Pot.DOM.getElement,
    getElements              : Pot.DOM.getElements,
    isXHTML                  : Pot.DOM.isXHTML,
    isXML                    : Pot.DOM.isXML,
    tagNameOf                : Pot.DOM.tagNameOf,
    getNodeValue             : Pot.DOM.getValue,
    setNodeValue             : Pot.DOM.setValue,
    getHTMLString            : Pot.DOM.getHTMLString,
    setHTMLString            : Pot.DOM.setHTMLString,
    getOuterHTML             : Pot.DOM.getOuterHTML,
    setOuterHTML             : Pot.DOM.setOuterHTML,
    getTextContent           : Pot.DOM.getTextContent,
    setTextContent           : Pot.DOM.setTextContent,
    getSelectionObject       : Pot.DOM.getSelectionObject,
    getSelectionContents     : Pot.DOM.getSelectionContents,
    getSelectionText         : Pot.DOM.getSelectionText,
    getSelectionHTML         : Pot.DOM.getSelectionHTML,
    coerceToNode             : Pot.DOM.coerceToNode,
    removeElement            : Pot.DOM.removeElement,
    appendChilds             : Pot.DOM.appendChilds,
    prependChilds            : Pot.DOM.prependChilds,
    removeChilds             : Pot.DOM.removeChilds,
    getAttr                  : Pot.DOM.getAttr,
    setAttr                  : Pot.DOM.setAttr,
    hasAttr                  : Pot.DOM.hasAttr,
    removeAttr               : Pot.DOM.removeAttr,
    addClass                 : Pot.DOM.addClass,
    removeClass              : Pot.DOM.removeClass,
    hasClass                 : Pot.DOM.hasClass,
    toggleClass              : Pot.DOM.toggleClass,
    serializeToXMLString     : Pot.DOM.serializeToString,
    parseFromXMLString       : Pot.DOM.parseFromString,
    evaluate                 : Pot.DOM.evaluate,
    attr                     : Pot.DOM.attr,
    convertToHTMLDocument    : Pot.DOM.convertToHTMLDocument,
    convertToHTMLString      : Pot.DOM.convertToHTMLString,
    isElementInView          : Pot.DOM.isElementInView,
    css                      : Pot.Style.css,
    getStyle                 : Pot.Style.getStyle,
    setStyle                 : Pot.Style.setStyle,
    isShown                  : Pot.Style.isShown,
    isVisible                : Pot.Style.isVisible,
    pxize                    : Pot.Style.pxize,
    getSizePos               : Pot.Style.getSizePos,
    getPixelSize             : Pot.Style.getPixelSize,
    setSize                  : Pot.Style.setSize,
    getWidth                 : Pot.Style.getWidth,
    setWidth                 : Pot.Style.setWidth,
    getHeight                : Pot.Style.getHeight,
    setHeight                : Pot.Style.setHeight,
    getResizeSize            : Pot.Style.getResizeSize,
    rescape                  : rescape,
    arrayize                 : arrayize,
    numeric                  : numeric,
    invoke                   : invoke,
    stringify                : stringify,
    trim                     : trim,
    now                      : now,
    globalize                : Pot.globalize,
    debug                    : Pot.Debug.debug,
    error                    : Pot.Debug.error,
    dump                     : Pot.Debug.dump,
    addPlugin                : Pot.Plugin.add,
    hasPlugin                : Pot.Plugin.has,
    removePlugin             : Pot.Plugin.remove,
    listPlugin               : Pot.Plugin.list
  }
});

//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
// Register the Pot object into global.

// Export the Pot object.
PotInternal.exportPot(false, false, false, true);

return Pot;


}(this || {}));
